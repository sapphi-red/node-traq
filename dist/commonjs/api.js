"use strict";
// tslint:disable
/**
 * traQ v3
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var BotStateEnum;
(function (BotStateEnum) {
    BotStateEnum[BotStateEnum["NUMBER_0"] = 0] = "NUMBER_0";
    BotStateEnum[BotStateEnum["NUMBER_1"] = 1] = "NUMBER_1";
    BotStateEnum[BotStateEnum["NUMBER_2"] = 2] = "NUMBER_2";
})(BotStateEnum = exports.BotStateEnum || (exports.BotStateEnum = {}));
/**
    * @export
    * @enum {string}
    */
var BotDetailStateEnum;
(function (BotDetailStateEnum) {
    BotDetailStateEnum[BotDetailStateEnum["NUMBER_0"] = 0] = "NUMBER_0";
    BotDetailStateEnum[BotDetailStateEnum["NUMBER_1"] = 1] = "NUMBER_1";
    BotDetailStateEnum[BotDetailStateEnum["NUMBER_2"] = 2] = "NUMBER_2";
})(BotDetailStateEnum = exports.BotDetailStateEnum || (exports.BotDetailStateEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ChannelEventTypeEnum;
(function (ChannelEventTypeEnum) {
    ChannelEventTypeEnum["TopicChanged"] = "TopicChanged";
    ChannelEventTypeEnum["SubscribersChanged"] = "SubscribersChanged";
    ChannelEventTypeEnum["PinAdded"] = "PinAdded";
    ChannelEventTypeEnum["PinRemoved"] = "PinRemoved";
    ChannelEventTypeEnum["NameChanged"] = "NameChanged";
    ChannelEventTypeEnum["ParentChanged"] = "ParentChanged";
    ChannelEventTypeEnum["VisibilityChanged"] = "VisibilityChanged";
    ChannelEventTypeEnum["ForcedNotificationChanged"] = "ForcedNotificationChanged";
    ChannelEventTypeEnum["ChildCreated"] = "ChildCreated";
})(ChannelEventTypeEnum = exports.ChannelEventTypeEnum || (exports.ChannelEventTypeEnum = {}));
/**
 * チャンネル購読レベル 0：無し 1：未読管理 2：未読管理+通知
 * @export
 * @enum {string}
 */
var ChannelSubscribeLevel;
(function (ChannelSubscribeLevel) {
    ChannelSubscribeLevel[ChannelSubscribeLevel["NUMBER_0"] = 0] = "NUMBER_0";
    ChannelSubscribeLevel[ChannelSubscribeLevel["NUMBER_1"] = 1] = "NUMBER_1";
    ChannelSubscribeLevel[ChannelSubscribeLevel["NUMBER_2"] = 2] = "NUMBER_2";
})(ChannelSubscribeLevel = exports.ChannelSubscribeLevel || (exports.ChannelSubscribeLevel = {}));
/**
 * 閲覧状態
 * @export
 * @enum {string}
 */
var ChannelViewState;
(function (ChannelViewState) {
    ChannelViewState["None"] = "none";
    ChannelViewState["Monitoring"] = "monitoring";
    ChannelViewState["Editing"] = "editing";
})(ChannelViewState = exports.ChannelViewState || (exports.ChannelViewState = {}));
/**
 * OAuth2スコープ
 * @export
 * @enum {string}
 */
var OAuth2Scope;
(function (OAuth2Scope) {
    OAuth2Scope["Read"] = "read";
    OAuth2Scope["Write"] = "write";
    OAuth2Scope["ManageBot"] = "manage_bot";
})(OAuth2Scope = exports.OAuth2Scope || (exports.OAuth2Scope = {}));
/**
 * ユーザーアカウント状態
 * @export
 * @enum {string}
 */
var UserAccountState;
(function (UserAccountState) {
    UserAccountState[UserAccountState["NUMBER_0"] = 0] = "NUMBER_0";
    UserAccountState[UserAccountState["NUMBER_1"] = 1] = "NUMBER_1";
    UserAccountState[UserAccountState["NUMBER_2"] = 2] = "NUMBER_2";
})(UserAccountState = exports.UserAccountState || (exports.UserAccountState = {}));
/**
 * ActivityApi - axios parameter creator
 * @export
 */
exports.ActivityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @summary アクテビティタイムラインを取得
         * @param {number} [limit] 取得する件数
         * @param {boolean} [subscribeOnly] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityTimeline(limit, subscribeOnly, options = {}) {
            const localVarPath = `/activity/timeline`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (subscribeOnly !== undefined) {
                localVarQueryParameter['subscribe-only'] = subscribeOnly;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 現在オンラインな(SSEまたはWSが接続中)ユーザーのUUIDのリストを返します。
         * @summary オンラインユーザーリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnlineUsers(options = {}) {
            const localVarPath = `/activity/onlines`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivityApi - functional programming interface
 * @export
 */
exports.ActivityApiFp = function (configuration) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @summary アクテビティタイムラインを取得
         * @param {number} [limit] 取得する件数
         * @param {boolean} [subscribeOnly] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityTimeline(limit, subscribeOnly, options) {
            const localVarAxiosArgs = exports.ActivityApiAxiosParamCreator(configuration).getActivityTimeline(limit, subscribeOnly, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 現在オンラインな(SSEまたはWSが接続中)ユーザーのUUIDのリストを返します。
         * @summary オンラインユーザーリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnlineUsers(options) {
            const localVarAxiosArgs = exports.ActivityApiAxiosParamCreator(configuration).getOnlineUsers(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ActivityApi - factory interface
 * @export
 */
exports.ActivityApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @summary アクテビティタイムラインを取得
         * @param {number} [limit] 取得する件数
         * @param {boolean} [subscribeOnly] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityTimeline(limit, subscribeOnly, options) {
            return exports.ActivityApiFp(configuration).getActivityTimeline(limit, subscribeOnly, options)(axios, basePath);
        },
        /**
         * 現在オンラインな(SSEまたはWSが接続中)ユーザーのUUIDのリストを返します。
         * @summary オンラインユーザーリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnlineUsers(options) {
            return exports.ActivityApiFp(configuration).getOnlineUsers(options)(axios, basePath);
        },
    };
};
/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
class ActivityApi extends base_1.BaseAPI {
    /**
     * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
     * @summary アクテビティタイムラインを取得
     * @param {number} [limit] 取得する件数
     * @param {boolean} [subscribeOnly] 購読チャンネルのみを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    getActivityTimeline(limit, subscribeOnly, options) {
        return exports.ActivityApiFp(this.configuration).getActivityTimeline(limit, subscribeOnly, options)(this.axios, this.basePath);
    }
    /**
     * 現在オンラインな(SSEまたはWSが接続中)ユーザーのUUIDのリストを返します。
     * @summary オンラインユーザーリストを取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    getOnlineUsers(options) {
        return exports.ActivityApiFp(this.configuration).getOnlineUsers(options)(this.axios, this.basePath);
    }
}
exports.ActivityApi = ActivityApi;
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
exports.AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary 自分のログインセッションリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySessions(options = {}) {
            const localVarPath = `/users/me/sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログインします。
         * @summary ログイン
         * @param {string} [redirect] リダイレクト先
         * @param {PostLoginRequest} [postLoginRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(redirect, postLoginRequest, options = {}) {
            const localVarPath = `/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postLoginRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postLoginRequest !== undefined ? postLoginRequest : {}) : (postLoginRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログアウトします。
         * @summary ログアウト
         * @param {string} [redirect] リダイレクト先
         * @param {boolean} [all] 全てのセッションでログアウトするかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, all, options = {}) {
            const localVarPath = `/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary セッションを無効化します
         * @param {string} sessionId セッションUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMySession(sessionId, options = {}) {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new base_1.RequiredError('sessionId', 'Required parameter sessionId was null or undefined when calling revokeMySession.');
            }
            const localVarPath = `/users/me/sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
exports.AuthenticationApiFp = function (configuration) {
    return {
        /**
         *
         * @summary 自分のログインセッションリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySessions(options) {
            const localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).getMySessions(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ログインします。
         * @summary ログイン
         * @param {string} [redirect] リダイレクト先
         * @param {PostLoginRequest} [postLoginRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(redirect, postLoginRequest, options) {
            const localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).login(redirect, postLoginRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ログアウトします。
         * @summary ログアウト
         * @param {string} [redirect] リダイレクト先
         * @param {boolean} [all] 全てのセッションでログアウトするかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, all, options) {
            const localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).logout(redirect, all, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary セッションを無効化します
         * @param {string} sessionId セッションUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMySession(sessionId, options) {
            const localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).revokeMySession(sessionId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
exports.AuthenticationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary 自分のログインセッションリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySessions(options) {
            return exports.AuthenticationApiFp(configuration).getMySessions(options)(axios, basePath);
        },
        /**
         * ログインします。
         * @summary ログイン
         * @param {string} [redirect] リダイレクト先
         * @param {PostLoginRequest} [postLoginRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(redirect, postLoginRequest, options) {
            return exports.AuthenticationApiFp(configuration).login(redirect, postLoginRequest, options)(axios, basePath);
        },
        /**
         * ログアウトします。
         * @summary ログアウト
         * @param {string} [redirect] リダイレクト先
         * @param {boolean} [all] 全てのセッションでログアウトするかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, all, options) {
            return exports.AuthenticationApiFp(configuration).logout(redirect, all, options)(axios, basePath);
        },
        /**
         *
         * @summary セッションを無効化します
         * @param {string} sessionId セッションUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMySession(sessionId, options) {
            return exports.AuthenticationApiFp(configuration).revokeMySession(sessionId, options)(axios, basePath);
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
class AuthenticationApi extends base_1.BaseAPI {
    /**
     *
     * @summary 自分のログインセッションリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getMySessions(options) {
        return exports.AuthenticationApiFp(this.configuration).getMySessions(options)(this.axios, this.basePath);
    }
    /**
     * ログインします。
     * @summary ログイン
     * @param {string} [redirect] リダイレクト先
     * @param {PostLoginRequest} [postLoginRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    login(redirect, postLoginRequest, options) {
        return exports.AuthenticationApiFp(this.configuration).login(redirect, postLoginRequest, options)(this.axios, this.basePath);
    }
    /**
     * ログアウトします。
     * @summary ログアウト
     * @param {string} [redirect] リダイレクト先
     * @param {boolean} [all] 全てのセッションでログアウトするかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logout(redirect, all, options) {
        return exports.AuthenticationApiFp(this.configuration).logout(redirect, all, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary セッションを無効化します
     * @param {string} sessionId セッションUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    revokeMySession(sessionId, options) {
        return exports.AuthenticationApiFp(this.configuration).revokeMySession(sessionId, options)(this.axios, this.basePath);
    }
}
exports.AuthenticationApi = AuthenticationApi;
/**
 * BotApi - axios parameter creator
 * @export
 */
exports.BotApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したBOTを有効化します。 対象のBOTの管理権限が必要です。
         * @summary BOTをアクティベート
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateBot(botId, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling activateBot.');
            }
            const localVarPath = `/bots/{botId}/actions/activate`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTのアイコン画像を変更を変更します。 対象のBOTの管理権限が必要です。
         * @summary BOTのアイコン画像を変更
         * @param {string} botId BOTUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botId, file, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling changeBotIcon.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling changeBotIcon.');
            }
            const localVarPath = `/bots/{botId}/icon`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * BOTを作成します。 作成後にアクティベーション・購読イベントの設定を行う必要があります。
         * @summary BOTを作成
         * @param {PostBotRequest} [postBotRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot(postBotRequest, options = {}) {
            const localVarPath = `/bots`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postBotRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBotRequest !== undefined ? postBotRequest : {}) : (postBotRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTを削除します。 対象のBOTの管理権限が必要です。
         * @summary BOTを削除
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botId, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling deleteBot.');
            }
            const localVarPath = `/bots/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTの情報を変更します。 対象のBOTの管理権限が必要です。 BOT開発者UUIDを変更した場合は、変更先ユーザーにBOT管理権限が移譲され、自分自身は権限を失います。
         * @summary BOT情報を変更
         * @param {string} botId BOTUUID
         * @param {PatchBotRequest} [patchBotRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botId, patchBotRequest, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling editBot.');
            }
            const localVarPath = `/bots/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchBotRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchBotRequest !== undefined ? patchBotRequest : {}) : (patchBotRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTのBOT情報を取得します。 BOT詳細情報を取得する場合は、対象のBOTの管理権限が必要です。
         * @summary BOT情報を取得
         * @param {string} botId BOTUUID
         * @param {boolean} [detail] 詳細情報を含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botId, detail, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling getBot.');
            }
            const localVarPath = `/bots/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTのアイコン画像を取得を取得します。
         * @summary BOTのアイコン画像を取得
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botId, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling getBotIcon.');
            }
            const localVarPath = `/bots/{botId}/icon`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTのイベントログを取得します。 対象のBOTの管理権限が必要です。
         * @summary BOTのイベントログを取得
         * @param {string} botId BOTUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotLogs(botId, limit, offset, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling getBotLogs.');
            }
            const localVarPath = `/bots/{botId}/logs`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * BOT情報のリストを取得します。
         * @summary BOTリストを取得
         * @param {boolean} [all] 全てのBOTを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(all, options = {}) {
            const localVarPath = `/bots`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルに参加しているBOTのリストを取得します。
         * @summary チャンネル参加中のBOTのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelBots.');
            }
            const localVarPath = `/channels/{channelId}/bots`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTを無効化します。対象のBOTの管理権限が必要です。
         * @summary BOTをインアクティベート
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateBot(botId, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling inactivateBot.');
            }
            const localVarPath = `/bots/{botId}/actions/inactivate`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTを指定したチャンネルに参加させます。 チャンネルに参加したBOTは、そのチャンネルの各種イベントを受け取るようになります。 対象のBOTの管理権限が必要です。
         * @summary BOTをチャンネルに参加させる
         * @param {string} botId BOTUUID
         * @param {PostBotActionJoinRequest} [postBotActionJoinRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letBotJoinChannel(botId, postBotActionJoinRequest, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling letBotJoinChannel.');
            }
            const localVarPath = `/bots/{botId}/actions/join`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postBotActionJoinRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBotActionJoinRequest !== undefined ? postBotActionJoinRequest : {}) : (postBotActionJoinRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTを指定したチャンネルから退出させます。 対象のBOTの管理権限が必要です。
         * @summary BOTをチャンネルから退出させる
         * @param {string} botId BOTUUID
         * @param {PostBotActionLeaveRequest} [postBotActionLeaveRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letBotLeaveChannel(botId, postBotActionLeaveRequest, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling letBotLeaveChannel.');
            }
            const localVarPath = `/bots/{botId}/actions/leave`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postBotActionLeaveRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBotActionLeaveRequest !== undefined ? postBotActionLeaveRequest : {}) : (postBotActionLeaveRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBOTの現在の各種トークンを無効化し、再発行を行います。 対象のBOTの管理権限が必要です。
         * @summary BOTのトークンを再発行
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBot(botId, options = {}) {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new base_1.RequiredError('botId', 'Required parameter botId was null or undefined when calling reissueBot.');
            }
            const localVarPath = `/bots/{botId}/actions/reissue`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BotApi - functional programming interface
 * @export
 */
exports.BotApiFp = function (configuration) {
    return {
        /**
         * 指定したBOTを有効化します。 対象のBOTの管理権限が必要です。
         * @summary BOTをアクティベート
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateBot(botId, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).activateBot(botId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTのアイコン画像を変更を変更します。 対象のBOTの管理権限が必要です。
         * @summary BOTのアイコン画像を変更
         * @param {string} botId BOTUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botId, file, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).changeBotIcon(botId, file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * BOTを作成します。 作成後にアクティベーション・購読イベントの設定を行う必要があります。
         * @summary BOTを作成
         * @param {PostBotRequest} [postBotRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot(postBotRequest, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).createBot(postBotRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTを削除します。 対象のBOTの管理権限が必要です。
         * @summary BOTを削除
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botId, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).deleteBot(botId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTの情報を変更します。 対象のBOTの管理権限が必要です。 BOT開発者UUIDを変更した場合は、変更先ユーザーにBOT管理権限が移譲され、自分自身は権限を失います。
         * @summary BOT情報を変更
         * @param {string} botId BOTUUID
         * @param {PatchBotRequest} [patchBotRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botId, patchBotRequest, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).editBot(botId, patchBotRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTのBOT情報を取得します。 BOT詳細情報を取得する場合は、対象のBOTの管理権限が必要です。
         * @summary BOT情報を取得
         * @param {string} botId BOTUUID
         * @param {boolean} [detail] 詳細情報を含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botId, detail, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBot(botId, detail, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTのアイコン画像を取得を取得します。
         * @summary BOTのアイコン画像を取得
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botId, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBotIcon(botId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTのイベントログを取得します。 対象のBOTの管理権限が必要です。
         * @summary BOTのイベントログを取得
         * @param {string} botId BOTUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotLogs(botId, limit, offset, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBotLogs(botId, limit, offset, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * BOT情報のリストを取得します。
         * @summary BOTリストを取得
         * @param {boolean} [all] 全てのBOTを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(all, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBots(all, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルに参加しているBOTのリストを取得します。
         * @summary チャンネル参加中のBOTのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelId, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getChannelBots(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTを無効化します。対象のBOTの管理権限が必要です。
         * @summary BOTをインアクティベート
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateBot(botId, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).inactivateBot(botId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTを指定したチャンネルに参加させます。 チャンネルに参加したBOTは、そのチャンネルの各種イベントを受け取るようになります。 対象のBOTの管理権限が必要です。
         * @summary BOTをチャンネルに参加させる
         * @param {string} botId BOTUUID
         * @param {PostBotActionJoinRequest} [postBotActionJoinRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letBotJoinChannel(botId, postBotActionJoinRequest, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).letBotJoinChannel(botId, postBotActionJoinRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTを指定したチャンネルから退出させます。 対象のBOTの管理権限が必要です。
         * @summary BOTをチャンネルから退出させる
         * @param {string} botId BOTUUID
         * @param {PostBotActionLeaveRequest} [postBotActionLeaveRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letBotLeaveChannel(botId, postBotActionLeaveRequest, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).letBotLeaveChannel(botId, postBotActionLeaveRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBOTの現在の各種トークンを無効化し、再発行を行います。 対象のBOTの管理権限が必要です。
         * @summary BOTのトークンを再発行
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBot(botId, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).reissueBot(botId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * BotApi - factory interface
 * @export
 */
exports.BotApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したBOTを有効化します。 対象のBOTの管理権限が必要です。
         * @summary BOTをアクティベート
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateBot(botId, options) {
            return exports.BotApiFp(configuration).activateBot(botId, options)(axios, basePath);
        },
        /**
         * 指定したBOTのアイコン画像を変更を変更します。 対象のBOTの管理権限が必要です。
         * @summary BOTのアイコン画像を変更
         * @param {string} botId BOTUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botId, file, options) {
            return exports.BotApiFp(configuration).changeBotIcon(botId, file, options)(axios, basePath);
        },
        /**
         * BOTを作成します。 作成後にアクティベーション・購読イベントの設定を行う必要があります。
         * @summary BOTを作成
         * @param {PostBotRequest} [postBotRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot(postBotRequest, options) {
            return exports.BotApiFp(configuration).createBot(postBotRequest, options)(axios, basePath);
        },
        /**
         * 指定したBOTを削除します。 対象のBOTの管理権限が必要です。
         * @summary BOTを削除
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botId, options) {
            return exports.BotApiFp(configuration).deleteBot(botId, options)(axios, basePath);
        },
        /**
         * 指定したBOTの情報を変更します。 対象のBOTの管理権限が必要です。 BOT開発者UUIDを変更した場合は、変更先ユーザーにBOT管理権限が移譲され、自分自身は権限を失います。
         * @summary BOT情報を変更
         * @param {string} botId BOTUUID
         * @param {PatchBotRequest} [patchBotRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botId, patchBotRequest, options) {
            return exports.BotApiFp(configuration).editBot(botId, patchBotRequest, options)(axios, basePath);
        },
        /**
         * 指定したBOTのBOT情報を取得します。 BOT詳細情報を取得する場合は、対象のBOTの管理権限が必要です。
         * @summary BOT情報を取得
         * @param {string} botId BOTUUID
         * @param {boolean} [detail] 詳細情報を含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botId, detail, options) {
            return exports.BotApiFp(configuration).getBot(botId, detail, options)(axios, basePath);
        },
        /**
         * 指定したBOTのアイコン画像を取得を取得します。
         * @summary BOTのアイコン画像を取得
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botId, options) {
            return exports.BotApiFp(configuration).getBotIcon(botId, options)(axios, basePath);
        },
        /**
         * 指定したBOTのイベントログを取得します。 対象のBOTの管理権限が必要です。
         * @summary BOTのイベントログを取得
         * @param {string} botId BOTUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotLogs(botId, limit, offset, options) {
            return exports.BotApiFp(configuration).getBotLogs(botId, limit, offset, options)(axios, basePath);
        },
        /**
         * BOT情報のリストを取得します。
         * @summary BOTリストを取得
         * @param {boolean} [all] 全てのBOTを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(all, options) {
            return exports.BotApiFp(configuration).getBots(all, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルに参加しているBOTのリストを取得します。
         * @summary チャンネル参加中のBOTのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelId, options) {
            return exports.BotApiFp(configuration).getChannelBots(channelId, options)(axios, basePath);
        },
        /**
         * 指定したBOTを無効化します。対象のBOTの管理権限が必要です。
         * @summary BOTをインアクティベート
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inactivateBot(botId, options) {
            return exports.BotApiFp(configuration).inactivateBot(botId, options)(axios, basePath);
        },
        /**
         * 指定したBOTを指定したチャンネルに参加させます。 チャンネルに参加したBOTは、そのチャンネルの各種イベントを受け取るようになります。 対象のBOTの管理権限が必要です。
         * @summary BOTをチャンネルに参加させる
         * @param {string} botId BOTUUID
         * @param {PostBotActionJoinRequest} [postBotActionJoinRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letBotJoinChannel(botId, postBotActionJoinRequest, options) {
            return exports.BotApiFp(configuration).letBotJoinChannel(botId, postBotActionJoinRequest, options)(axios, basePath);
        },
        /**
         * 指定したBOTを指定したチャンネルから退出させます。 対象のBOTの管理権限が必要です。
         * @summary BOTをチャンネルから退出させる
         * @param {string} botId BOTUUID
         * @param {PostBotActionLeaveRequest} [postBotActionLeaveRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letBotLeaveChannel(botId, postBotActionLeaveRequest, options) {
            return exports.BotApiFp(configuration).letBotLeaveChannel(botId, postBotActionLeaveRequest, options)(axios, basePath);
        },
        /**
         * 指定したBOTの現在の各種トークンを無効化し、再発行を行います。 対象のBOTの管理権限が必要です。
         * @summary BOTのトークンを再発行
         * @param {string} botId BOTUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBot(botId, options) {
            return exports.BotApiFp(configuration).reissueBot(botId, options)(axios, basePath);
        },
    };
};
/**
 * BotApi - object-oriented interface
 * @export
 * @class BotApi
 * @extends {BaseAPI}
 */
class BotApi extends base_1.BaseAPI {
    /**
     * 指定したBOTを有効化します。 対象のBOTの管理権限が必要です。
     * @summary BOTをアクティベート
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    activateBot(botId, options) {
        return exports.BotApiFp(this.configuration).activateBot(botId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTのアイコン画像を変更を変更します。 対象のBOTの管理権限が必要です。
     * @summary BOTのアイコン画像を変更
     * @param {string} botId BOTUUID
     * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotIcon(botId, file, options) {
        return exports.BotApiFp(this.configuration).changeBotIcon(botId, file, options)(this.axios, this.basePath);
    }
    /**
     * BOTを作成します。 作成後にアクティベーション・購読イベントの設定を行う必要があります。
     * @summary BOTを作成
     * @param {PostBotRequest} [postBotRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    createBot(postBotRequest, options) {
        return exports.BotApiFp(this.configuration).createBot(postBotRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを削除します。 対象のBOTの管理権限が必要です。
     * @summary BOTを削除
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    deleteBot(botId, options) {
        return exports.BotApiFp(this.configuration).deleteBot(botId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTの情報を変更します。 対象のBOTの管理権限が必要です。 BOT開発者UUIDを変更した場合は、変更先ユーザーにBOT管理権限が移譲され、自分自身は権限を失います。
     * @summary BOT情報を変更
     * @param {string} botId BOTUUID
     * @param {PatchBotRequest} [patchBotRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    editBot(botId, patchBotRequest, options) {
        return exports.BotApiFp(this.configuration).editBot(botId, patchBotRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTのBOT情報を取得します。 BOT詳細情報を取得する場合は、対象のBOTの管理権限が必要です。
     * @summary BOT情報を取得
     * @param {string} botId BOTUUID
     * @param {boolean} [detail] 詳細情報を含めるかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBot(botId, detail, options) {
        return exports.BotApiFp(this.configuration).getBot(botId, detail, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTのアイコン画像を取得を取得します。
     * @summary BOTのアイコン画像を取得
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotIcon(botId, options) {
        return exports.BotApiFp(this.configuration).getBotIcon(botId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTのイベントログを取得します。 対象のBOTの管理権限が必要です。
     * @summary BOTのイベントログを取得
     * @param {string} botId BOTUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotLogs(botId, limit, offset, options) {
        return exports.BotApiFp(this.configuration).getBotLogs(botId, limit, offset, options)(this.axios, this.basePath);
    }
    /**
     * BOT情報のリストを取得します。
     * @summary BOTリストを取得
     * @param {boolean} [all] 全てのBOTを取得するかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBots(all, options) {
        return exports.BotApiFp(this.configuration).getBots(all, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルに参加しているBOTのリストを取得します。
     * @summary チャンネル参加中のBOTのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getChannelBots(channelId, options) {
        return exports.BotApiFp(this.configuration).getChannelBots(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを無効化します。対象のBOTの管理権限が必要です。
     * @summary BOTをインアクティベート
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    inactivateBot(botId, options) {
        return exports.BotApiFp(this.configuration).inactivateBot(botId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを指定したチャンネルに参加させます。 チャンネルに参加したBOTは、そのチャンネルの各種イベントを受け取るようになります。 対象のBOTの管理権限が必要です。
     * @summary BOTをチャンネルに参加させる
     * @param {string} botId BOTUUID
     * @param {PostBotActionJoinRequest} [postBotActionJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    letBotJoinChannel(botId, postBotActionJoinRequest, options) {
        return exports.BotApiFp(this.configuration).letBotJoinChannel(botId, postBotActionJoinRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを指定したチャンネルから退出させます。 対象のBOTの管理権限が必要です。
     * @summary BOTをチャンネルから退出させる
     * @param {string} botId BOTUUID
     * @param {PostBotActionLeaveRequest} [postBotActionLeaveRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    letBotLeaveChannel(botId, postBotActionLeaveRequest, options) {
        return exports.BotApiFp(this.configuration).letBotLeaveChannel(botId, postBotActionLeaveRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTの現在の各種トークンを無効化し、再発行を行います。 対象のBOTの管理権限が必要です。
     * @summary BOTのトークンを再発行
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    reissueBot(botId, options) {
        return exports.BotApiFp(this.configuration).reissueBot(botId, options)(this.axios, this.basePath);
    }
}
exports.BotApi = BotApi;
/**
 * ChannelApi - axios parameter creator
 * @export
 */
exports.ChannelApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルを作成します。 階層が6以上になるチャンネルは作成できません。
         * @summary チャンネルを作成
         * @param {PostChannelRequest} [postChannelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(postChannelRequest, options = {}) {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postChannelRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postChannelRequest !== undefined ? postChannelRequest : {}) : (postChannelRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルの情報を変更します。 変更には権限が必要です。
         * @summary チャンネル情報を変更
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelRequest} [patchChannelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelId, patchChannelRequest, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling editChannel.');
            }
            const localVarPath = `/channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchChannelRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchChannelRequest !== undefined ? patchChannelRequest : {}) : (patchChannelRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
         * @summary チャンネルの通知購読者を編集
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelSubscribers(channelId, patchChannelSubscribersRequest, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling editChannelSubscribers.');
            }
            const localVarPath = `/channels/{channelId}/subscribers`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchChannelSubscribersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchChannelSubscribersRequest !== undefined ? patchChannelSubscribersRequest : {}) : (patchChannelSubscribersRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルのトピックを編集します。
         * @summary チャンネルトピックを編集
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelTopicRequest} [putChannelTopicRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelTopic(channelId, putChannelTopicRequest, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling editChannelTopic.');
            }
            const localVarPath = `/channels/{channelId}/topic`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putChannelTopicRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putChannelTopicRequest !== undefined ? putChannelTopicRequest : {}) : (putChannelTopicRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルの情報を取得します。
         * @summary チャンネル情報を取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannel.');
            }
            const localVarPath = `/channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルに参加しているBOTのリストを取得します。
         * @summary チャンネル参加中のBOTのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelBots.');
            }
            const localVarPath = `/channels/{channelId}/bots`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルのイベントリストを取得します。
         * @summary チャンネルイベントのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelEvents.');
            }
            const localVarPath = `/channels/{channelId}/events`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
         * @summary チャンネルピンのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelPins(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelPins.');
            }
            const localVarPath = `/channels/{channelId}/pins`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルの統計情報を取得します。
         * @summary チャンネル統計情報を取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelStats.');
            }
            const localVarPath = `/channels/{channelId}/stats`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
         * @summary チャンネルの通知購読者のリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelSubscribers(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelSubscribers.');
            }
            const localVarPath = `/channels/{channelId}/subscribers`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルのトピックを取得します。
         * @summary チャンネルトピックを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelTopic.');
            }
            const localVarPath = `/channels/{channelId}/topic`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルの閲覧者のリストを取得します。
         * @summary チャンネル閲覧者リストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelViewers.');
            }
            const localVarPath = `/channels/{channelId}/viewers`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルのリストを取得します。
         * @summary チャンネルリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options = {}) {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルのメッセージのリストを取得します。
         * @summary チャンネルメッセージのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelId, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getMessages.');
            }
            const localVarPath = `/channels/{channelId}/messages`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
         * @summary チャンネルにメッセージを投稿
         * @param {string} channelId チャンネルUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelId, postMessageRequest, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling postMessage.');
            }
            const localVarPath = `/channels/{channelId}/messages`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMessageRequest !== undefined ? postMessageRequest : {}) : (postMessageRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
         * @summary チャンネルの通知購読者を設定
         * @param {string} channelId チャンネルUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribers(channelId, requestBody, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling setChannelSubscribers.');
            }
            const localVarPath = `/channels/{channelId}/subscribers`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChannelApi - functional programming interface
 * @export
 */
exports.ChannelApiFp = function (configuration) {
    return {
        /**
         * チャンネルを作成します。 階層が6以上になるチャンネルは作成できません。
         * @summary チャンネルを作成
         * @param {PostChannelRequest} [postChannelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(postChannelRequest, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).createChannel(postChannelRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルの情報を変更します。 変更には権限が必要です。
         * @summary チャンネル情報を変更
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelRequest} [patchChannelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelId, patchChannelRequest, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).editChannel(channelId, patchChannelRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
         * @summary チャンネルの通知購読者を編集
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelSubscribers(channelId, patchChannelSubscribersRequest, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).editChannelSubscribers(channelId, patchChannelSubscribersRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルのトピックを編集します。
         * @summary チャンネルトピックを編集
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelTopicRequest} [putChannelTopicRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelTopic(channelId, putChannelTopicRequest, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).editChannelTopic(channelId, putChannelTopicRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルの情報を取得します。
         * @summary チャンネル情報を取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannel(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルに参加しているBOTのリストを取得します。
         * @summary チャンネル参加中のBOTのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelId, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelBots(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルのイベントリストを取得します。
         * @summary チャンネルイベントのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
         * @summary チャンネルピンのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelPins(channelId, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelPins(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルの統計情報を取得します。
         * @summary チャンネル統計情報を取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelId, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelStats(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
         * @summary チャンネルの通知購読者のリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelSubscribers(channelId, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelSubscribers(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルのトピックを取得します。
         * @summary チャンネルトピックを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelId, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelTopic(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルの閲覧者のリストを取得します。
         * @summary チャンネル閲覧者リストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelId, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelViewers(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルのリストを取得します。
         * @summary チャンネルリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannels(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルのメッセージのリストを取得します。
         * @summary チャンネルメッセージのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelId, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getMessages(channelId, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
         * @summary チャンネルにメッセージを投稿
         * @param {string} channelId チャンネルUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelId, postMessageRequest, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).postMessage(channelId, postMessageRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
         * @summary チャンネルの通知購読者を設定
         * @param {string} channelId チャンネルUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribers(channelId, requestBody, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).setChannelSubscribers(channelId, requestBody, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ChannelApi - factory interface
 * @export
 */
exports.ChannelApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルを作成します。 階層が6以上になるチャンネルは作成できません。
         * @summary チャンネルを作成
         * @param {PostChannelRequest} [postChannelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(postChannelRequest, options) {
            return exports.ChannelApiFp(configuration).createChannel(postChannelRequest, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルの情報を変更します。 変更には権限が必要です。
         * @summary チャンネル情報を変更
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelRequest} [patchChannelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelId, patchChannelRequest, options) {
            return exports.ChannelApiFp(configuration).editChannel(channelId, patchChannelRequest, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
         * @summary チャンネルの通知購読者を編集
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelSubscribers(channelId, patchChannelSubscribersRequest, options) {
            return exports.ChannelApiFp(configuration).editChannelSubscribers(channelId, patchChannelSubscribersRequest, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルのトピックを編集します。
         * @summary チャンネルトピックを編集
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelTopicRequest} [putChannelTopicRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelTopic(channelId, putChannelTopicRequest, options) {
            return exports.ChannelApiFp(configuration).editChannelTopic(channelId, putChannelTopicRequest, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルの情報を取得します。
         * @summary チャンネル情報を取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId, options) {
            return exports.ChannelApiFp(configuration).getChannel(channelId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルに参加しているBOTのリストを取得します。
         * @summary チャンネル参加中のBOTのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelId, options) {
            return exports.ChannelApiFp(configuration).getChannelBots(channelId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルのイベントリストを取得します。
         * @summary チャンネルイベントのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options) {
            return exports.ChannelApiFp(configuration).getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
         * @summary チャンネルピンのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelPins(channelId, options) {
            return exports.ChannelApiFp(configuration).getChannelPins(channelId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルの統計情報を取得します。
         * @summary チャンネル統計情報を取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelId, options) {
            return exports.ChannelApiFp(configuration).getChannelStats(channelId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
         * @summary チャンネルの通知購読者のリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelSubscribers(channelId, options) {
            return exports.ChannelApiFp(configuration).getChannelSubscribers(channelId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルのトピックを取得します。
         * @summary チャンネルトピックを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelId, options) {
            return exports.ChannelApiFp(configuration).getChannelTopic(channelId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルの閲覧者のリストを取得します。
         * @summary チャンネル閲覧者リストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelId, options) {
            return exports.ChannelApiFp(configuration).getChannelViewers(channelId, options)(axios, basePath);
        },
        /**
         * チャンネルのリストを取得します。
         * @summary チャンネルリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options) {
            return exports.ChannelApiFp(configuration).getChannels(options)(axios, basePath);
        },
        /**
         * 指定したチャンネルのメッセージのリストを取得します。
         * @summary チャンネルメッセージのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelId, limit, offset, since, until, inclusive, order, options) {
            return exports.ChannelApiFp(configuration).getMessages(channelId, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
         * @summary チャンネルにメッセージを投稿
         * @param {string} channelId チャンネルUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelId, postMessageRequest, options) {
            return exports.ChannelApiFp(configuration).postMessage(channelId, postMessageRequest, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
         * @summary チャンネルの通知購読者を設定
         * @param {string} channelId チャンネルUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribers(channelId, requestBody, options) {
            return exports.ChannelApiFp(configuration).setChannelSubscribers(channelId, requestBody, options)(axios, basePath);
        },
    };
};
/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
class ChannelApi extends base_1.BaseAPI {
    /**
     * チャンネルを作成します。 階層が6以上になるチャンネルは作成できません。
     * @summary チャンネルを作成
     * @param {PostChannelRequest} [postChannelRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannel(postChannelRequest, options) {
        return exports.ChannelApiFp(this.configuration).createChannel(postChannelRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの情報を変更します。 変更には権限が必要です。
     * @summary チャンネル情報を変更
     * @param {string} channelId チャンネルUUID
     * @param {PatchChannelRequest} [patchChannelRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannel(channelId, patchChannelRequest, options) {
        return exports.ChannelApiFp(this.configuration).editChannel(channelId, patchChannelRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
     * @summary チャンネルの通知購読者を編集
     * @param {string} channelId チャンネルUUID
     * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannelSubscribers(channelId, patchChannelSubscribersRequest, options) {
        return exports.ChannelApiFp(this.configuration).editChannelSubscribers(channelId, patchChannelSubscribersRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのトピックを編集します。
     * @summary チャンネルトピックを編集
     * @param {string} channelId チャンネルUUID
     * @param {PutChannelTopicRequest} [putChannelTopicRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannelTopic(channelId, putChannelTopicRequest, options) {
        return exports.ChannelApiFp(this.configuration).editChannelTopic(channelId, putChannelTopicRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの情報を取得します。
     * @summary チャンネル情報を取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannel(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannel(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルに参加しているBOTのリストを取得します。
     * @summary チャンネル参加中のBOTのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelBots(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelBots(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのイベントリストを取得します。
     * @summary チャンネルイベントのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options) {
        return exports.ChannelApiFp(this.configuration).getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
     * @summary チャンネルピンのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelPins(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelPins(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの統計情報を取得します。
     * @summary チャンネル統計情報を取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelStats(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelStats(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
     * @summary チャンネルの通知購読者のリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelSubscribers(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelSubscribers(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのトピックを取得します。
     * @summary チャンネルトピックを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelTopic(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelTopic(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの閲覧者のリストを取得します。
     * @summary チャンネル閲覧者リストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelViewers(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelViewers(channelId, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのリストを取得します。
     * @summary チャンネルリストを取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannels(options) {
        return exports.ChannelApiFp(this.configuration).getChannels(options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのメッセージのリストを取得します。
     * @summary チャンネルメッセージのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getMessages(channelId, limit, offset, since, until, inclusive, order, options) {
        return exports.ChannelApiFp(this.configuration).getMessages(channelId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
     * @summary チャンネルにメッセージを投稿
     * @param {string} channelId チャンネルUUID
     * @param {PostMessageRequest} [postMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    postMessage(channelId, postMessageRequest, options) {
        return exports.ChannelApiFp(this.configuration).postMessage(channelId, postMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
     * @summary チャンネルの通知購読者を設定
     * @param {string} channelId チャンネルUUID
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    setChannelSubscribers(channelId, requestBody, options) {
        return exports.ChannelApiFp(this.configuration).setChannelSubscribers(channelId, requestBody, options)(this.axios, this.basePath);
    }
}
exports.ChannelApi = ChannelApi;
/**
 * ClipApi - axios parameter creator
 * @export
 */
exports.ClipApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したメッセージを指定したクリップフォルダに追加します。
         * @summary メッセージをクリップフォルダに追加
         * @param {string} folderId クリップフォルダUUID
         * @param {PostClipFolderMessageRequest} [postClipFolderMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clipMessage(folderId, postClipFolderMessageRequest, options = {}) {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new base_1.RequiredError('folderId', 'Required parameter folderId was null or undefined when calling clipMessage.');
            }
            const localVarPath = `/clip-folders/{folderId}/messages`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postClipFolderMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postClipFolderMessageRequest !== undefined ? postClipFolderMessageRequest : {}) : (postClipFolderMessageRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
         * @summary クリップフォルダを作成
         * @param {PostClipFolderRequest} [postClipFolderRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClipFolder(postClipFolderRequest, options = {}) {
            const localVarPath = `/clip-folders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postClipFolderRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postClipFolderRequest !== undefined ? postClipFolderRequest : {}) : (postClipFolderRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクリップフォルダを削除します。
         * @summary クリップフォルダを削除
         * @param {string} folderId クリップフォルダUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClipFolder(folderId, options = {}) {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new base_1.RequiredError('folderId', 'Required parameter folderId was null or undefined when calling deleteClipFolder.');
            }
            const localVarPath = `/clip-folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクリップフォルダの情報を編集します。
         * @summary クリップフォルダ情報を編集
         * @param {string} folderId クリップフォルダUUID
         * @param {PatchClipFolderRequest} [patchClipFolderRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClipFolder(folderId, patchClipFolderRequest, options = {}) {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new base_1.RequiredError('folderId', 'Required parameter folderId was null or undefined when calling editClipFolder.');
            }
            const localVarPath = `/clip-folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchClipFolderRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchClipFolderRequest !== undefined ? patchClipFolderRequest : {}) : (patchClipFolderRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクリップフォルダの情報を取得します。
         * @summary クリップフォルダ情報を取得
         * @param {string} folderId クリップフォルダUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipFolder(folderId, options = {}) {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new base_1.RequiredError('folderId', 'Required parameter folderId was null or undefined when calling getClipFolder.');
            }
            const localVarPath = `/clip-folders/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身が所有するクリップフォルダのリストを取得します。
         * @summary クリップフォルダのリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipFolders(options = {}) {
            const localVarPath = `/clip-folders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したフォルダ内のクリップのリストを取得します。
         * @summary フォルダ内のクリップのリストを取得
         * @param {string} folderId クリップフォルダUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClips(folderId, limit, offset, options = {}) {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new base_1.RequiredError('folderId', 'Required parameter folderId was null or undefined when calling getClips.');
            }
            const localVarPath = `/clip-folders/{folderId}/messages`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
         * @summary メッセージをクリップフォルダから除外
         * @param {string} folderId クリップフォルダUUID
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclipMessage(folderId, messageId, options = {}) {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new base_1.RequiredError('folderId', 'Required parameter folderId was null or undefined when calling unclipMessage.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling unclipMessage.');
            }
            const localVarPath = `/clip-folders/{folderId}/messages/{messageId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ClipApi - functional programming interface
 * @export
 */
exports.ClipApiFp = function (configuration) {
    return {
        /**
         * 指定したメッセージを指定したクリップフォルダに追加します。
         * @summary メッセージをクリップフォルダに追加
         * @param {string} folderId クリップフォルダUUID
         * @param {PostClipFolderMessageRequest} [postClipFolderMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clipMessage(folderId, postClipFolderMessageRequest, options) {
            const localVarAxiosArgs = exports.ClipApiAxiosParamCreator(configuration).clipMessage(folderId, postClipFolderMessageRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
         * @summary クリップフォルダを作成
         * @param {PostClipFolderRequest} [postClipFolderRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClipFolder(postClipFolderRequest, options) {
            const localVarAxiosArgs = exports.ClipApiAxiosParamCreator(configuration).createClipFolder(postClipFolderRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクリップフォルダを削除します。
         * @summary クリップフォルダを削除
         * @param {string} folderId クリップフォルダUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClipFolder(folderId, options) {
            const localVarAxiosArgs = exports.ClipApiAxiosParamCreator(configuration).deleteClipFolder(folderId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクリップフォルダの情報を編集します。
         * @summary クリップフォルダ情報を編集
         * @param {string} folderId クリップフォルダUUID
         * @param {PatchClipFolderRequest} [patchClipFolderRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClipFolder(folderId, patchClipFolderRequest, options) {
            const localVarAxiosArgs = exports.ClipApiAxiosParamCreator(configuration).editClipFolder(folderId, patchClipFolderRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクリップフォルダの情報を取得します。
         * @summary クリップフォルダ情報を取得
         * @param {string} folderId クリップフォルダUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipFolder(folderId, options) {
            const localVarAxiosArgs = exports.ClipApiAxiosParamCreator(configuration).getClipFolder(folderId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身が所有するクリップフォルダのリストを取得します。
         * @summary クリップフォルダのリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipFolders(options) {
            const localVarAxiosArgs = exports.ClipApiAxiosParamCreator(configuration).getClipFolders(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したフォルダ内のクリップのリストを取得します。
         * @summary フォルダ内のクリップのリストを取得
         * @param {string} folderId クリップフォルダUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClips(folderId, limit, offset, options) {
            const localVarAxiosArgs = exports.ClipApiAxiosParamCreator(configuration).getClips(folderId, limit, offset, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
         * @summary メッセージをクリップフォルダから除外
         * @param {string} folderId クリップフォルダUUID
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclipMessage(folderId, messageId, options) {
            const localVarAxiosArgs = exports.ClipApiAxiosParamCreator(configuration).unclipMessage(folderId, messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ClipApi - factory interface
 * @export
 */
exports.ClipApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したメッセージを指定したクリップフォルダに追加します。
         * @summary メッセージをクリップフォルダに追加
         * @param {string} folderId クリップフォルダUUID
         * @param {PostClipFolderMessageRequest} [postClipFolderMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clipMessage(folderId, postClipFolderMessageRequest, options) {
            return exports.ClipApiFp(configuration).clipMessage(folderId, postClipFolderMessageRequest, options)(axios, basePath);
        },
        /**
         * クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
         * @summary クリップフォルダを作成
         * @param {PostClipFolderRequest} [postClipFolderRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClipFolder(postClipFolderRequest, options) {
            return exports.ClipApiFp(configuration).createClipFolder(postClipFolderRequest, options)(axios, basePath);
        },
        /**
         * 指定したクリップフォルダを削除します。
         * @summary クリップフォルダを削除
         * @param {string} folderId クリップフォルダUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClipFolder(folderId, options) {
            return exports.ClipApiFp(configuration).deleteClipFolder(folderId, options)(axios, basePath);
        },
        /**
         * 指定したクリップフォルダの情報を編集します。
         * @summary クリップフォルダ情報を編集
         * @param {string} folderId クリップフォルダUUID
         * @param {PatchClipFolderRequest} [patchClipFolderRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClipFolder(folderId, patchClipFolderRequest, options) {
            return exports.ClipApiFp(configuration).editClipFolder(folderId, patchClipFolderRequest, options)(axios, basePath);
        },
        /**
         * 指定したクリップフォルダの情報を取得します。
         * @summary クリップフォルダ情報を取得
         * @param {string} folderId クリップフォルダUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipFolder(folderId, options) {
            return exports.ClipApiFp(configuration).getClipFolder(folderId, options)(axios, basePath);
        },
        /**
         * 自身が所有するクリップフォルダのリストを取得します。
         * @summary クリップフォルダのリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClipFolders(options) {
            return exports.ClipApiFp(configuration).getClipFolders(options)(axios, basePath);
        },
        /**
         * 指定したフォルダ内のクリップのリストを取得します。
         * @summary フォルダ内のクリップのリストを取得
         * @param {string} folderId クリップフォルダUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClips(folderId, limit, offset, options) {
            return exports.ClipApiFp(configuration).getClips(folderId, limit, offset, options)(axios, basePath);
        },
        /**
         * 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
         * @summary メッセージをクリップフォルダから除外
         * @param {string} folderId クリップフォルダUUID
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclipMessage(folderId, messageId, options) {
            return exports.ClipApiFp(configuration).unclipMessage(folderId, messageId, options)(axios, basePath);
        },
    };
};
/**
 * ClipApi - object-oriented interface
 * @export
 * @class ClipApi
 * @extends {BaseAPI}
 */
class ClipApi extends base_1.BaseAPI {
    /**
     * 指定したメッセージを指定したクリップフォルダに追加します。
     * @summary メッセージをクリップフォルダに追加
     * @param {string} folderId クリップフォルダUUID
     * @param {PostClipFolderMessageRequest} [postClipFolderMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    clipMessage(folderId, postClipFolderMessageRequest, options) {
        return exports.ClipApiFp(this.configuration).clipMessage(folderId, postClipFolderMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
     * @summary クリップフォルダを作成
     * @param {PostClipFolderRequest} [postClipFolderRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    createClipFolder(postClipFolderRequest, options) {
        return exports.ClipApiFp(this.configuration).createClipFolder(postClipFolderRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップフォルダを削除します。
     * @summary クリップフォルダを削除
     * @param {string} folderId クリップフォルダUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    deleteClipFolder(folderId, options) {
        return exports.ClipApiFp(this.configuration).deleteClipFolder(folderId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップフォルダの情報を編集します。
     * @summary クリップフォルダ情報を編集
     * @param {string} folderId クリップフォルダUUID
     * @param {PatchClipFolderRequest} [patchClipFolderRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    editClipFolder(folderId, patchClipFolderRequest, options) {
        return exports.ClipApiFp(this.configuration).editClipFolder(folderId, patchClipFolderRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップフォルダの情報を取得します。
     * @summary クリップフォルダ情報を取得
     * @param {string} folderId クリップフォルダUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    getClipFolder(folderId, options) {
        return exports.ClipApiFp(this.configuration).getClipFolder(folderId, options)(this.axios, this.basePath);
    }
    /**
     * 自身が所有するクリップフォルダのリストを取得します。
     * @summary クリップフォルダのリストを取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    getClipFolders(options) {
        return exports.ClipApiFp(this.configuration).getClipFolders(options)(this.axios, this.basePath);
    }
    /**
     * 指定したフォルダ内のクリップのリストを取得します。
     * @summary フォルダ内のクリップのリストを取得
     * @param {string} folderId クリップフォルダUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    getClips(folderId, limit, offset, options) {
        return exports.ClipApiFp(this.configuration).getClips(folderId, limit, offset, options)(this.axios, this.basePath);
    }
    /**
     * 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
     * @summary メッセージをクリップフォルダから除外
     * @param {string} folderId クリップフォルダUUID
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    unclipMessage(folderId, messageId, options) {
        return exports.ClipApiFp(this.configuration).unclipMessage(folderId, messageId, options)(this.axios, this.basePath);
    }
}
exports.ClipApi = ClipApi;
/**
 * FileApi - axios parameter creator
 * @export
 */
exports.FileApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したファイルを削除します。 指定したファイルの削除権限が必要です。
         * @summary ファイルを削除
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId, options = {}) {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new base_1.RequiredError('fileId', 'Required parameter fileId was null or undefined when calling deleteFile.');
            }
            const localVarPath = `/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイル本体を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary ファイルをダウンロード
         * @param {string} fileId ファイルUUID
         * @param {number} [dl] 1を指定するとレスポンスにContent-Dispositionヘッダーが付与されます
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileId, dl, options = {}) {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new base_1.RequiredError('fileId', 'Required parameter fileId was null or undefined when calling getFile.');
            }
            const localVarPath = `/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (dl !== undefined) {
                localVarQueryParameter['dl'] = dl;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルのメタ情報を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary ファイルメタを取得
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileId, options = {}) {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new base_1.RequiredError('fileId', 'Required parameter fileId was null or undefined when calling getFileMeta.');
            }
            const localVarPath = `/files/{fileId}/meta`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクエリでファイルメタのリストを取得します。
         * @summary ファイルメタのリストを取得
         * @param {string} channelId アップロード先チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {string} [mime] MIMEタイプ
         * @param {string} [uploaderId] アップロード者UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getFiles.');
            }
            const localVarPath = `/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (mime !== undefined) {
                localVarQueryParameter['mime'] = mime;
            }
            if (uploaderId !== undefined) {
                localVarQueryParameter['uploaderId'] = uploaderId;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルのサムネイル画像を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary サムネイル画像を取得
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailImage(fileId, options = {}) {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new base_1.RequiredError('fileId', 'Required parameter fileId was null or undefined when calling getThumbnailImage.');
            }
            const localVarPath = `/files/{fileId}/thumbnail`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルにファイルをアップロードします。
         * @summary ファイルをアップロード
         * @param {any} file ファイル本体
         * @param {string} channelId アップロード先チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFile(file, channelId, options = {}) {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling postFile.');
            }
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling postFile.');
            }
            const localVarPath = `/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (channelId !== undefined) {
                localVarFormParams.append('channelId', channelId);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FileApi - functional programming interface
 * @export
 */
exports.FileApiFp = function (configuration) {
    return {
        /**
         * 指定したファイルを削除します。 指定したファイルの削除権限が必要です。
         * @summary ファイルを削除
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).deleteFile(fileId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイル本体を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary ファイルをダウンロード
         * @param {string} fileId ファイルUUID
         * @param {number} [dl] 1を指定するとレスポンスにContent-Dispositionヘッダーが付与されます
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileId, dl, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).getFile(fileId, dl, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルのメタ情報を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary ファイルメタを取得
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileId, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).getFileMeta(fileId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクエリでファイルメタのリストを取得します。
         * @summary ファイルメタのリストを取得
         * @param {string} channelId アップロード先チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {string} [mime] MIMEタイプ
         * @param {string} [uploaderId] アップロード者UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルのサムネイル画像を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary サムネイル画像を取得
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailImage(fileId, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).getThumbnailImage(fileId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルにファイルをアップロードします。
         * @summary ファイルをアップロード
         * @param {any} file ファイル本体
         * @param {string} channelId アップロード先チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFile(file, channelId, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).postFile(file, channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * FileApi - factory interface
 * @export
 */
exports.FileApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したファイルを削除します。 指定したファイルの削除権限が必要です。
         * @summary ファイルを削除
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId, options) {
            return exports.FileApiFp(configuration).deleteFile(fileId, options)(axios, basePath);
        },
        /**
         * 指定したファイル本体を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary ファイルをダウンロード
         * @param {string} fileId ファイルUUID
         * @param {number} [dl] 1を指定するとレスポンスにContent-Dispositionヘッダーが付与されます
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileId, dl, options) {
            return exports.FileApiFp(configuration).getFile(fileId, dl, options)(axios, basePath);
        },
        /**
         * 指定したファイルのメタ情報を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary ファイルメタを取得
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileId, options) {
            return exports.FileApiFp(configuration).getFileMeta(fileId, options)(axios, basePath);
        },
        /**
         * 指定したクエリでファイルメタのリストを取得します。
         * @summary ファイルメタのリストを取得
         * @param {string} channelId アップロード先チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {string} [mime] MIMEタイプ
         * @param {string} [uploaderId] アップロード者UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options) {
            return exports.FileApiFp(configuration).getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options)(axios, basePath);
        },
        /**
         * 指定したファイルのサムネイル画像を取得します。 指定したファイルへのアクセス権限が必要です。
         * @summary サムネイル画像を取得
         * @param {string} fileId ファイルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailImage(fileId, options) {
            return exports.FileApiFp(configuration).getThumbnailImage(fileId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルにファイルをアップロードします。
         * @summary ファイルをアップロード
         * @param {any} file ファイル本体
         * @param {string} channelId アップロード先チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFile(file, channelId, options) {
            return exports.FileApiFp(configuration).postFile(file, channelId, options)(axios, basePath);
        },
    };
};
/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
class FileApi extends base_1.BaseAPI {
    /**
     * 指定したファイルを削除します。 指定したファイルの削除権限が必要です。
     * @summary ファイルを削除
     * @param {string} fileId ファイルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    deleteFile(fileId, options) {
        return exports.FileApiFp(this.configuration).deleteFile(fileId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイル本体を取得します。 指定したファイルへのアクセス権限が必要です。
     * @summary ファイルをダウンロード
     * @param {string} fileId ファイルUUID
     * @param {number} [dl] 1を指定するとレスポンスにContent-Dispositionヘッダーが付与されます
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFile(fileId, dl, options) {
        return exports.FileApiFp(this.configuration).getFile(fileId, dl, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのメタ情報を取得します。 指定したファイルへのアクセス権限が必要です。
     * @summary ファイルメタを取得
     * @param {string} fileId ファイルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileMeta(fileId, options) {
        return exports.FileApiFp(this.configuration).getFileMeta(fileId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクエリでファイルメタのリストを取得します。
     * @summary ファイルメタのリストを取得
     * @param {string} channelId アップロード先チャンネルUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {string} [mime] MIMEタイプ
     * @param {string} [uploaderId] アップロード者UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options) {
        return exports.FileApiFp(this.configuration).getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのサムネイル画像を取得します。 指定したファイルへのアクセス権限が必要です。
     * @summary サムネイル画像を取得
     * @param {string} fileId ファイルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getThumbnailImage(fileId, options) {
        return exports.FileApiFp(this.configuration).getThumbnailImage(fileId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルにファイルをアップロードします。
     * @summary ファイルをアップロード
     * @param {any} file ファイル本体
     * @param {string} channelId アップロード先チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    postFile(file, channelId, options) {
        return exports.FileApiFp(this.configuration).postFile(file, channelId, options)(this.axios, this.basePath);
    }
}
exports.FileApi = FileApi;
/**
 * GroupApi - axios parameter creator
 * @export
 */
exports.GroupApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したグループにメンバーを追加します。 対象のユーザーグループの管理者権限が必要です。
         * @summary グループメンバーを追加
         * @param {string} groupId ユーザーグループUUID
         * @param {UserGroupMember} [userGroupMember]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserGroupMember(groupId, userGroupMember, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new base_1.RequiredError('groupId', 'Required parameter groupId was null or undefined when calling addUserGroupMember.');
            }
            const localVarPath = `/groups/{groupId}/members`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof userGroupMember !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userGroupMember !== undefined ? userGroupMember : {}) : (userGroupMember || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを作成します。 作成者は自動的にメンバーに追加され、グループ管理者になります。
         * @summary ユーザーグループを作成
         * @param {PostUserGroupRequest} [postUserGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup(postUserGroupRequest, options = {}) {
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postUserGroupRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserGroupRequest !== undefined ? postUserGroupRequest : {}) : (postUserGroupRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーグループを削除します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループを削除
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup(groupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new base_1.RequiredError('groupId', 'Required parameter groupId was null or undefined when calling deleteUserGroup.');
            }
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーグループの情報を編集します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループを編集
         * @param {string} groupId ユーザーグループUUID
         * @param {PatchUserGroupRequest} [patchUserGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserGroup(groupId, patchUserGroupRequest, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new base_1.RequiredError('groupId', 'Required parameter groupId was null or undefined when calling editUserGroup.');
            }
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchUserGroupRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserGroupRequest !== undefined ? patchUserGroupRequest : {}) : (patchUserGroupRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーグループ内の指定したユーザーの属性を編集します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループメンバーを編集
         * @param {string} groupId ユーザーグループUUID
         * @param {string} userId ユーザーUUID
         * @param {PatchGroupMemberRequest} [patchGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserGroupMember(groupId, userId, patchGroupMemberRequest, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new base_1.RequiredError('groupId', 'Required parameter groupId was null or undefined when calling editUserGroupMember.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling editUserGroupMember.');
            }
            const localVarPath = `/groups/{groupId}/members/{userId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchGroupMemberRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchGroupMemberRequest !== undefined ? patchGroupMemberRequest : {}) : (patchGroupMemberRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーグループの情報を取得します。
         * @summary ユーザーグループを取得
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroup(groupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new base_1.RequiredError('groupId', 'Required parameter groupId was null or undefined when calling getUserGroup.');
            }
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したグループのメンバーのリストを取得します。
         * @summary グループメンバーを取得
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupMembers(groupId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new base_1.RequiredError('groupId', 'Required parameter groupId was null or undefined when calling getUserGroupMembers.');
            }
            const localVarPath = `/groups/{groupId}/members`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループのリストを取得します。
         * @summary ユーザーグループのリストを取得
         * @param {string} [type] グループタイプ
         * @param {boolean} [admin] 自分が管理者のグループのみを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(type, admin, options = {}) {
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーグループから指定したユーザーを削除します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループから削除
         * @param {string} groupId ユーザーグループUUID
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserGroupMember(groupId, userId, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new base_1.RequiredError('groupId', 'Required parameter groupId was null or undefined when calling removeUserGroupMember.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling removeUserGroupMember.');
            }
            const localVarPath = `/groups/{groupId}/members/{userId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したグループのメンバーをリクエストのメンバーに置き換えます。 リクエスト内に含まれないメンバーはグループから削除されます。 対象のユーザーグループの管理者権限が必要です。
         * @summary グループメンバーを設定
         * @param {string} groupId ユーザーグループUUID
         * @param {Array<UserGroupMember>} [userGroupMember]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroupMembers(groupId, userGroupMember, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new base_1.RequiredError('groupId', 'Required parameter groupId was null or undefined when calling setUserGroupMembers.');
            }
            const localVarPath = `/groups/{groupId}/members`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof userGroupMember !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userGroupMember !== undefined ? userGroupMember : {}) : (userGroupMember || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * GroupApi - functional programming interface
 * @export
 */
exports.GroupApiFp = function (configuration) {
    return {
        /**
         * 指定したグループにメンバーを追加します。 対象のユーザーグループの管理者権限が必要です。
         * @summary グループメンバーを追加
         * @param {string} groupId ユーザーグループUUID
         * @param {UserGroupMember} [userGroupMember]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserGroupMember(groupId, userGroupMember, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).addUserGroupMember(groupId, userGroupMember, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを作成します。 作成者は自動的にメンバーに追加され、グループ管理者になります。
         * @summary ユーザーグループを作成
         * @param {PostUserGroupRequest} [postUserGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup(postUserGroupRequest, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).createUserGroup(postUserGroupRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーグループを削除します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループを削除
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup(groupId, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).deleteUserGroup(groupId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーグループの情報を編集します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループを編集
         * @param {string} groupId ユーザーグループUUID
         * @param {PatchUserGroupRequest} [patchUserGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserGroup(groupId, patchUserGroupRequest, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).editUserGroup(groupId, patchUserGroupRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーグループ内の指定したユーザーの属性を編集します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループメンバーを編集
         * @param {string} groupId ユーザーグループUUID
         * @param {string} userId ユーザーUUID
         * @param {PatchGroupMemberRequest} [patchGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserGroupMember(groupId, userId, patchGroupMemberRequest, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).editUserGroupMember(groupId, userId, patchGroupMemberRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーグループの情報を取得します。
         * @summary ユーザーグループを取得
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroup(groupId, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).getUserGroup(groupId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したグループのメンバーのリストを取得します。
         * @summary グループメンバーを取得
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupMembers(groupId, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).getUserGroupMembers(groupId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループのリストを取得します。
         * @summary ユーザーグループのリストを取得
         * @param {string} [type] グループタイプ
         * @param {boolean} [admin] 自分が管理者のグループのみを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(type, admin, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).getUserGroups(type, admin, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーグループから指定したユーザーを削除します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループから削除
         * @param {string} groupId ユーザーグループUUID
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserGroupMember(groupId, userId, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).removeUserGroupMember(groupId, userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したグループのメンバーをリクエストのメンバーに置き換えます。 リクエスト内に含まれないメンバーはグループから削除されます。 対象のユーザーグループの管理者権限が必要です。
         * @summary グループメンバーを設定
         * @param {string} groupId ユーザーグループUUID
         * @param {Array<UserGroupMember>} [userGroupMember]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroupMembers(groupId, userGroupMember, options) {
            const localVarAxiosArgs = exports.GroupApiAxiosParamCreator(configuration).setUserGroupMembers(groupId, userGroupMember, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * GroupApi - factory interface
 * @export
 */
exports.GroupApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したグループにメンバーを追加します。 対象のユーザーグループの管理者権限が必要です。
         * @summary グループメンバーを追加
         * @param {string} groupId ユーザーグループUUID
         * @param {UserGroupMember} [userGroupMember]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserGroupMember(groupId, userGroupMember, options) {
            return exports.GroupApiFp(configuration).addUserGroupMember(groupId, userGroupMember, options)(axios, basePath);
        },
        /**
         * ユーザーグループを作成します。 作成者は自動的にメンバーに追加され、グループ管理者になります。
         * @summary ユーザーグループを作成
         * @param {PostUserGroupRequest} [postUserGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup(postUserGroupRequest, options) {
            return exports.GroupApiFp(configuration).createUserGroup(postUserGroupRequest, options)(axios, basePath);
        },
        /**
         * 指定したユーザーグループを削除します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループを削除
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserGroup(groupId, options) {
            return exports.GroupApiFp(configuration).deleteUserGroup(groupId, options)(axios, basePath);
        },
        /**
         * 指定したユーザーグループの情報を編集します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループを編集
         * @param {string} groupId ユーザーグループUUID
         * @param {PatchUserGroupRequest} [patchUserGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserGroup(groupId, patchUserGroupRequest, options) {
            return exports.GroupApiFp(configuration).editUserGroup(groupId, patchUserGroupRequest, options)(axios, basePath);
        },
        /**
         * 指定したユーザーグループ内の指定したユーザーの属性を編集します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループメンバーを編集
         * @param {string} groupId ユーザーグループUUID
         * @param {string} userId ユーザーUUID
         * @param {PatchGroupMemberRequest} [patchGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserGroupMember(groupId, userId, patchGroupMemberRequest, options) {
            return exports.GroupApiFp(configuration).editUserGroupMember(groupId, userId, patchGroupMemberRequest, options)(axios, basePath);
        },
        /**
         * 指定したユーザーグループの情報を取得します。
         * @summary ユーザーグループを取得
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroup(groupId, options) {
            return exports.GroupApiFp(configuration).getUserGroup(groupId, options)(axios, basePath);
        },
        /**
         * 指定したグループのメンバーのリストを取得します。
         * @summary グループメンバーを取得
         * @param {string} groupId ユーザーグループUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupMembers(groupId, options) {
            return exports.GroupApiFp(configuration).getUserGroupMembers(groupId, options)(axios, basePath);
        },
        /**
         * ユーザーグループのリストを取得します。
         * @summary ユーザーグループのリストを取得
         * @param {string} [type] グループタイプ
         * @param {boolean} [admin] 自分が管理者のグループのみを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(type, admin, options) {
            return exports.GroupApiFp(configuration).getUserGroups(type, admin, options)(axios, basePath);
        },
        /**
         * 指定したユーザーグループから指定したユーザーを削除します。 対象のユーザーグループの管理者権限が必要です。
         * @summary ユーザーグループから削除
         * @param {string} groupId ユーザーグループUUID
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserGroupMember(groupId, userId, options) {
            return exports.GroupApiFp(configuration).removeUserGroupMember(groupId, userId, options)(axios, basePath);
        },
        /**
         * 指定したグループのメンバーをリクエストのメンバーに置き換えます。 リクエスト内に含まれないメンバーはグループから削除されます。 対象のユーザーグループの管理者権限が必要です。
         * @summary グループメンバーを設定
         * @param {string} groupId ユーザーグループUUID
         * @param {Array<UserGroupMember>} [userGroupMember]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroupMembers(groupId, userGroupMember, options) {
            return exports.GroupApiFp(configuration).setUserGroupMembers(groupId, userGroupMember, options)(axios, basePath);
        },
    };
};
/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
class GroupApi extends base_1.BaseAPI {
    /**
     * 指定したグループにメンバーを追加します。 対象のユーザーグループの管理者権限が必要です。
     * @summary グループメンバーを追加
     * @param {string} groupId ユーザーグループUUID
     * @param {UserGroupMember} [userGroupMember]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    addUserGroupMember(groupId, userGroupMember, options) {
        return exports.GroupApiFp(this.configuration).addUserGroupMember(groupId, userGroupMember, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを作成します。 作成者は自動的にメンバーに追加され、グループ管理者になります。
     * @summary ユーザーグループを作成
     * @param {PostUserGroupRequest} [postUserGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    createUserGroup(postUserGroupRequest, options) {
        return exports.GroupApiFp(this.configuration).createUserGroup(postUserGroupRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループを削除します。 対象のユーザーグループの管理者権限が必要です。
     * @summary ユーザーグループを削除
     * @param {string} groupId ユーザーグループUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    deleteUserGroup(groupId, options) {
        return exports.GroupApiFp(this.configuration).deleteUserGroup(groupId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループの情報を編集します。 対象のユーザーグループの管理者権限が必要です。
     * @summary ユーザーグループを編集
     * @param {string} groupId ユーザーグループUUID
     * @param {PatchUserGroupRequest} [patchUserGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    editUserGroup(groupId, patchUserGroupRequest, options) {
        return exports.GroupApiFp(this.configuration).editUserGroup(groupId, patchUserGroupRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループ内の指定したユーザーの属性を編集します。 対象のユーザーグループの管理者権限が必要です。
     * @summary ユーザーグループメンバーを編集
     * @param {string} groupId ユーザーグループUUID
     * @param {string} userId ユーザーUUID
     * @param {PatchGroupMemberRequest} [patchGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    editUserGroupMember(groupId, userId, patchGroupMemberRequest, options) {
        return exports.GroupApiFp(this.configuration).editUserGroupMember(groupId, userId, patchGroupMemberRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループの情報を取得します。
     * @summary ユーザーグループを取得
     * @param {string} groupId ユーザーグループUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    getUserGroup(groupId, options) {
        return exports.GroupApiFp(this.configuration).getUserGroup(groupId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したグループのメンバーのリストを取得します。
     * @summary グループメンバーを取得
     * @param {string} groupId ユーザーグループUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    getUserGroupMembers(groupId, options) {
        return exports.GroupApiFp(this.configuration).getUserGroupMembers(groupId, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループのリストを取得します。
     * @summary ユーザーグループのリストを取得
     * @param {string} [type] グループタイプ
     * @param {boolean} [admin] 自分が管理者のグループのみを取得するかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    getUserGroups(type, admin, options) {
        return exports.GroupApiFp(this.configuration).getUserGroups(type, admin, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループから指定したユーザーを削除します。 対象のユーザーグループの管理者権限が必要です。
     * @summary ユーザーグループから削除
     * @param {string} groupId ユーザーグループUUID
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    removeUserGroupMember(groupId, userId, options) {
        return exports.GroupApiFp(this.configuration).removeUserGroupMember(groupId, userId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したグループのメンバーをリクエストのメンバーに置き換えます。 リクエスト内に含まれないメンバーはグループから削除されます。 対象のユーザーグループの管理者権限が必要です。
     * @summary グループメンバーを設定
     * @param {string} groupId ユーザーグループUUID
     * @param {Array<UserGroupMember>} [userGroupMember]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    setUserGroupMembers(groupId, userGroupMember, options) {
        return exports.GroupApiFp(this.configuration).setUserGroupMembers(groupId, userGroupMember, options)(this.axios, this.basePath);
    }
}
exports.GroupApi = GroupApi;
/**
 * MeApi - axios parameter creator
 * @export
 */
exports.MeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary チャンネルをスターします
         * @param {PostStarRequest} [postStarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyStar(postStarRequest, options = {}) {
            const localVarPath = `/users/me/stars`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postStarRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postStarRequest !== undefined ? postStarRequest : {}) : (postStarRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 自分にタグを追加します
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyUserTag(postUserTagRequest, options = {}) {
            const localVarPath = `/users/me/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postUserTagRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserTagRequest !== undefined ? postUserTagRequest : {}) : (postUserTagRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のアイコン画像を変更します。
         * @summary 自分のアイコン画像を変更
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options = {}) {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling changeMyIcon.');
            }
            const localVarPath = `/users/me/icon`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のパスワードを変更します。
         * @summary 自分のパスワードを変更
         * @param {PutMyPasswordRequest} [putMyPasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyPassword(putMyPasswordRequest, options = {}) {
            const localVarPath = `/users/me/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putMyPasswordRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putMyPasswordRequest !== undefined ? putMyPasswordRequest : {}) : (putMyPasswordRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のユーザー情報を変更します。
         * @summary 自分のユーザー情報を変更
         * @param {PatchMeRequest} [patchMeRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMe(patchMeRequest, options = {}) {
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchMeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchMeRequest !== undefined ? patchMeRequest : {}) : (patchMeRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 自分のタグを編集します
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMyUserTag(tagId, patchUserTagRequest, options = {}) {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling editMyUserTag.');
            }
            const localVarPath = `/users/me/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchUserTagRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserTagRequest !== undefined ? patchUserTagRequest : {}) : (patchUserTagRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のユーザー詳細情報を取得します。
         * @summary 自分のユーザー詳細を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options = {}) {
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のチャンネル購読状態を取得します。
         * @summary 自分のチャンネル購読状態を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyChannelSubscriptions(options = {}) {
            const localVarPath = `/users/me/subscriptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のアイコン画像を取得します。
         * @summary 自分のアイコン画像を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options = {}) {
            const localVarPath = `/users/me/icon`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のQRコードを取得します。 返されたQRコードまたはトークンは、発行後の5分間のみ有効です
         * @summary QRコードを取得
         * @param {boolean} [token] 画像でなくトークン文字列で返すかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyQRCode(token, options = {}) {
            const localVarPath = `/users/me/qr-code`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 自分のログインセッションリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySessions(options = {}) {
            const localVarPath = `/users/me/sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
         * @summary スタンプ履歴を取得
         * @param {number} [limit] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStampHistory(limit, options = {}) {
            const localVarPath = `/users/me/stamp-history`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary スターチャンネルリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStars(options = {}) {
            const localVarPath = `/users/me/stars`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 有効なOAuth2トークンのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyTokens(options = {}) {
            const localVarPath = `/users/me/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 未読チャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUnreadChannels(options = {}) {
            const localVarPath = `/users/me/unread`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 自分のタグリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserTags(options = {}) {
            const localVarPath = `/users/me/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
         * @summary 未読チャンネルを既読にします
         * @param {string} [channelId] 既読にするチャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readChannels(channelId, options = {}) {
            const localVarPath = `/users/me/unread`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のFCMデバイスを登録します。
         * @summary FCMデバイスを登録
         * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerFCMDevice(postMyFCMDeviceRequest, options = {}) {
            const localVarPath = `/users/me/fcm-device`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMyFCMDeviceRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMyFCMDeviceRequest !== undefined ? postMyFCMDeviceRequest : {}) : (postMyFCMDeviceRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 既にスターから削除されているチャンネルを指定した場合は204を返します。
         * @summary チャンネルをスターから削除します
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyStar(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling removeMyStar.');
            }
            const localVarPath = `/users/me/stars/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary 自分からタグを削除します
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyUserTag(tagId, options = {}) {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling removeMyUserTag.');
            }
            const localVarPath = `/users/me/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary セッションを無効化します
         * @param {string} sessionId セッションUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMySession(sessionId, options = {}) {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new base_1.RequiredError('sessionId', 'Required parameter sessionId was null or undefined when calling revokeMySession.');
            }
            const localVarPath = `/users/me/sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary トークンの認可を取り消します
         * @param {string} tokenId OAuth2トークンUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMyToken(tokenId, options = {}) {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new base_1.RequiredError('tokenId', 'Required parameter tokenId was null or undefined when calling revokeMyToken.');
            }
            const localVarPath = `/users/me/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身の指定したチャンネルの購読レベルを設定します。
         * @summary チャンネル購読レベルを設定
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling setChannelSubscribeLevel.');
            }
            const localVarPath = `/users/me/subscriptions/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putChannelSubscribeLevelRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putChannelSubscribeLevelRequest !== undefined ? putChannelSubscribeLevelRequest : {}) : (putChannelSubscribeLevelRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MeApi - functional programming interface
 * @export
 */
exports.MeApiFp = function (configuration) {
    return {
        /**
         *
         * @summary チャンネルをスターします
         * @param {PostStarRequest} [postStarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyStar(postStarRequest, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).addMyStar(postStarRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 自分にタグを追加します
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyUserTag(postUserTagRequest, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).addMyUserTag(postUserTagRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のアイコン画像を変更します。
         * @summary 自分のアイコン画像を変更
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).changeMyIcon(file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のパスワードを変更します。
         * @summary 自分のパスワードを変更
         * @param {PutMyPasswordRequest} [putMyPasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyPassword(putMyPasswordRequest, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).changeMyPassword(putMyPasswordRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のユーザー情報を変更します。
         * @summary 自分のユーザー情報を変更
         * @param {PatchMeRequest} [patchMeRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMe(patchMeRequest, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).editMe(patchMeRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 自分のタグを編集します
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMyUserTag(tagId, patchUserTagRequest, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).editMyUserTag(tagId, patchUserTagRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のユーザー詳細情報を取得します。
         * @summary 自分のユーザー詳細を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMe(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のチャンネル購読状態を取得します。
         * @summary 自分のチャンネル購読状態を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyChannelSubscriptions(options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMyChannelSubscriptions(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のアイコン画像を取得します。
         * @summary 自分のアイコン画像を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMyIcon(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のQRコードを取得します。 返されたQRコードまたはトークンは、発行後の5分間のみ有効です
         * @summary QRコードを取得
         * @param {boolean} [token] 画像でなくトークン文字列で返すかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyQRCode(token, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMyQRCode(token, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 自分のログインセッションリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySessions(options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMySessions(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
         * @summary スタンプ履歴を取得
         * @param {number} [limit] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStampHistory(limit, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMyStampHistory(limit, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary スターチャンネルリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStars(options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMyStars(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 有効なOAuth2トークンのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyTokens(options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMyTokens(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 未読チャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUnreadChannels(options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMyUnreadChannels(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 自分のタグリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserTags(options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).getMyUserTags(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
         * @summary 未読チャンネルを既読にします
         * @param {string} [channelId] 既読にするチャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readChannels(channelId, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).readChannels(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のFCMデバイスを登録します。
         * @summary FCMデバイスを登録
         * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerFCMDevice(postMyFCMDeviceRequest, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).registerFCMDevice(postMyFCMDeviceRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 既にスターから削除されているチャンネルを指定した場合は204を返します。
         * @summary チャンネルをスターから削除します
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyStar(channelId, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).removeMyStar(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary 自分からタグを削除します
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyUserTag(tagId, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).removeMyUserTag(tagId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary セッションを無効化します
         * @param {string} sessionId セッションUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMySession(sessionId, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).revokeMySession(sessionId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary トークンの認可を取り消します
         * @param {string} tokenId OAuth2トークンUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMyToken(tokenId, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).revokeMyToken(tokenId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身の指定したチャンネルの購読レベルを設定します。
         * @summary チャンネル購読レベルを設定
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options) {
            const localVarAxiosArgs = exports.MeApiAxiosParamCreator(configuration).setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * MeApi - factory interface
 * @export
 */
exports.MeApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary チャンネルをスターします
         * @param {PostStarRequest} [postStarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyStar(postStarRequest, options) {
            return exports.MeApiFp(configuration).addMyStar(postStarRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary 自分にタグを追加します
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyUserTag(postUserTagRequest, options) {
            return exports.MeApiFp(configuration).addMyUserTag(postUserTagRequest, options)(axios, basePath);
        },
        /**
         * 自分のアイコン画像を変更します。
         * @summary 自分のアイコン画像を変更
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options) {
            return exports.MeApiFp(configuration).changeMyIcon(file, options)(axios, basePath);
        },
        /**
         * 自身のパスワードを変更します。
         * @summary 自分のパスワードを変更
         * @param {PutMyPasswordRequest} [putMyPasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyPassword(putMyPasswordRequest, options) {
            return exports.MeApiFp(configuration).changeMyPassword(putMyPasswordRequest, options)(axios, basePath);
        },
        /**
         * 自身のユーザー情報を変更します。
         * @summary 自分のユーザー情報を変更
         * @param {PatchMeRequest} [patchMeRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMe(patchMeRequest, options) {
            return exports.MeApiFp(configuration).editMe(patchMeRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary 自分のタグを編集します
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMyUserTag(tagId, patchUserTagRequest, options) {
            return exports.MeApiFp(configuration).editMyUserTag(tagId, patchUserTagRequest, options)(axios, basePath);
        },
        /**
         * 自身のユーザー詳細情報を取得します。
         * @summary 自分のユーザー詳細を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            return exports.MeApiFp(configuration).getMe(options)(axios, basePath);
        },
        /**
         * 自身のチャンネル購読状態を取得します。
         * @summary 自分のチャンネル購読状態を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyChannelSubscriptions(options) {
            return exports.MeApiFp(configuration).getMyChannelSubscriptions(options)(axios, basePath);
        },
        /**
         * 自分のアイコン画像を取得します。
         * @summary 自分のアイコン画像を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options) {
            return exports.MeApiFp(configuration).getMyIcon(options)(axios, basePath);
        },
        /**
         * 自身のQRコードを取得します。 返されたQRコードまたはトークンは、発行後の5分間のみ有効です
         * @summary QRコードを取得
         * @param {boolean} [token] 画像でなくトークン文字列で返すかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyQRCode(token, options) {
            return exports.MeApiFp(configuration).getMyQRCode(token, options)(axios, basePath);
        },
        /**
         *
         * @summary 自分のログインセッションリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySessions(options) {
            return exports.MeApiFp(configuration).getMySessions(options)(axios, basePath);
        },
        /**
         * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
         * @summary スタンプ履歴を取得
         * @param {number} [limit] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStampHistory(limit, options) {
            return exports.MeApiFp(configuration).getMyStampHistory(limit, options)(axios, basePath);
        },
        /**
         *
         * @summary スターチャンネルリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStars(options) {
            return exports.MeApiFp(configuration).getMyStars(options)(axios, basePath);
        },
        /**
         *
         * @summary 有効なOAuth2トークンのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyTokens(options) {
            return exports.MeApiFp(configuration).getMyTokens(options)(axios, basePath);
        },
        /**
         *
         * @summary 未読チャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUnreadChannels(options) {
            return exports.MeApiFp(configuration).getMyUnreadChannels(options)(axios, basePath);
        },
        /**
         *
         * @summary 自分のタグリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserTags(options) {
            return exports.MeApiFp(configuration).getMyUserTags(options)(axios, basePath);
        },
        /**
         * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
         * @summary 未読チャンネルを既読にします
         * @param {string} [channelId] 既読にするチャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readChannels(channelId, options) {
            return exports.MeApiFp(configuration).readChannels(channelId, options)(axios, basePath);
        },
        /**
         * 自身のFCMデバイスを登録します。
         * @summary FCMデバイスを登録
         * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerFCMDevice(postMyFCMDeviceRequest, options) {
            return exports.MeApiFp(configuration).registerFCMDevice(postMyFCMDeviceRequest, options)(axios, basePath);
        },
        /**
         * 既にスターから削除されているチャンネルを指定した場合は204を返します。
         * @summary チャンネルをスターから削除します
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyStar(channelId, options) {
            return exports.MeApiFp(configuration).removeMyStar(channelId, options)(axios, basePath);
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary 自分からタグを削除します
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyUserTag(tagId, options) {
            return exports.MeApiFp(configuration).removeMyUserTag(tagId, options)(axios, basePath);
        },
        /**
         *
         * @summary セッションを無効化します
         * @param {string} sessionId セッションUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMySession(sessionId, options) {
            return exports.MeApiFp(configuration).revokeMySession(sessionId, options)(axios, basePath);
        },
        /**
         *
         * @summary トークンの認可を取り消します
         * @param {string} tokenId OAuth2トークンUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMyToken(tokenId, options) {
            return exports.MeApiFp(configuration).revokeMyToken(tokenId, options)(axios, basePath);
        },
        /**
         * 自身の指定したチャンネルの購読レベルを設定します。
         * @summary チャンネル購読レベルを設定
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options) {
            return exports.MeApiFp(configuration).setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options)(axios, basePath);
        },
    };
};
/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
class MeApi extends base_1.BaseAPI {
    /**
     *
     * @summary チャンネルをスターします
     * @param {PostStarRequest} [postStarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    addMyStar(postStarRequest, options) {
        return exports.MeApiFp(this.configuration).addMyStar(postStarRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分にタグを追加します
     * @param {PostUserTagRequest} [postUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    addMyUserTag(postUserTagRequest, options) {
        return exports.MeApiFp(this.configuration).addMyUserTag(postUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を変更します。
     * @summary 自分のアイコン画像を変更
     * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    changeMyIcon(file, options) {
        return exports.MeApiFp(this.configuration).changeMyIcon(file, options)(this.axios, this.basePath);
    }
    /**
     * 自身のパスワードを変更します。
     * @summary 自分のパスワードを変更
     * @param {PutMyPasswordRequest} [putMyPasswordRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    changeMyPassword(putMyPasswordRequest, options) {
        return exports.MeApiFp(this.configuration).changeMyPassword(putMyPasswordRequest, options)(this.axios, this.basePath);
    }
    /**
     * 自身のユーザー情報を変更します。
     * @summary 自分のユーザー情報を変更
     * @param {PatchMeRequest} [patchMeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    editMe(patchMeRequest, options) {
        return exports.MeApiFp(this.configuration).editMe(patchMeRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分のタグを編集します
     * @param {string} tagId タグUUID
     * @param {PatchUserTagRequest} [patchUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    editMyUserTag(tagId, patchUserTagRequest, options) {
        return exports.MeApiFp(this.configuration).editMyUserTag(tagId, patchUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 自身のユーザー詳細情報を取得します。
     * @summary 自分のユーザー詳細を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMe(options) {
        return exports.MeApiFp(this.configuration).getMe(options)(this.axios, this.basePath);
    }
    /**
     * 自身のチャンネル購読状態を取得します。
     * @summary 自分のチャンネル購読状態を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyChannelSubscriptions(options) {
        return exports.MeApiFp(this.configuration).getMyChannelSubscriptions(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を取得します。
     * @summary 自分のアイコン画像を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyIcon(options) {
        return exports.MeApiFp(this.configuration).getMyIcon(options)(this.axios, this.basePath);
    }
    /**
     * 自身のQRコードを取得します。 返されたQRコードまたはトークンは、発行後の5分間のみ有効です
     * @summary QRコードを取得
     * @param {boolean} [token] 画像でなくトークン文字列で返すかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyQRCode(token, options) {
        return exports.MeApiFp(this.configuration).getMyQRCode(token, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分のログインセッションリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMySessions(options) {
        return exports.MeApiFp(this.configuration).getMySessions(options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
     * @summary スタンプ履歴を取得
     * @param {number} [limit] 件数
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyStampHistory(limit, options) {
        return exports.MeApiFp(this.configuration).getMyStampHistory(limit, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary スターチャンネルリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyStars(options) {
        return exports.MeApiFp(this.configuration).getMyStars(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 有効なOAuth2トークンのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyTokens(options) {
        return exports.MeApiFp(this.configuration).getMyTokens(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 未読チャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyUnreadChannels(options) {
        return exports.MeApiFp(this.configuration).getMyUnreadChannels(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分のタグリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyUserTags(options) {
        return exports.MeApiFp(this.configuration).getMyUserTags(options)(this.axios, this.basePath);
    }
    /**
     * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
     * @summary 未読チャンネルを既読にします
     * @param {string} [channelId] 既読にするチャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    readChannels(channelId, options) {
        return exports.MeApiFp(this.configuration).readChannels(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 自身のFCMデバイスを登録します。
     * @summary FCMデバイスを登録
     * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    registerFCMDevice(postMyFCMDeviceRequest, options) {
        return exports.MeApiFp(this.configuration).registerFCMDevice(postMyFCMDeviceRequest, options)(this.axios, this.basePath);
    }
    /**
     * 既にスターから削除されているチャンネルを指定した場合は204を返します。
     * @summary チャンネルをスターから削除します
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    removeMyStar(channelId, options) {
        return exports.MeApiFp(this.configuration).removeMyStar(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 既に存在しないタグを削除しようとした場合は204を返します。
     * @summary 自分からタグを削除します
     * @param {string} tagId タグUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    removeMyUserTag(tagId, options) {
        return exports.MeApiFp(this.configuration).removeMyUserTag(tagId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary セッションを無効化します
     * @param {string} sessionId セッションUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    revokeMySession(sessionId, options) {
        return exports.MeApiFp(this.configuration).revokeMySession(sessionId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary トークンの認可を取り消します
     * @param {string} tokenId OAuth2トークンUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    revokeMyToken(tokenId, options) {
        return exports.MeApiFp(this.configuration).revokeMyToken(tokenId, options)(this.axios, this.basePath);
    }
    /**
     * 自身の指定したチャンネルの購読レベルを設定します。
     * @summary チャンネル購読レベルを設定
     * @param {string} channelId チャンネルUUID
     * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options) {
        return exports.MeApiFp(this.configuration).setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options)(this.axios, this.basePath);
    }
}
exports.MeApi = MeApi;
/**
 * MessageApi - axios parameter creator
 * @export
 */
exports.MessageApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @summary スタンプを押す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {PostMessageStampRequest} [postMessageStampRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageStamp(messageId, stampId, postMessageStampRequest, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling addMessageStamp.');
            }
            // verify required parameter 'stampId' is not null or undefined
            if (stampId === null || stampId === undefined) {
                throw new base_1.RequiredError('stampId', 'Required parameter stampId was null or undefined when calling addMessageStamp.');
            }
            const localVarPath = `/messages/{messageId}/stamps/{stampId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"stampId"}}`, encodeURIComponent(String(stampId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMessageStampRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMessageStampRequest !== undefined ? postMessageStampRequest : {}) : (postMessageStampRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージをピン留めします。
         * @summary ピン留めする
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPin(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling createPin.');
            }
            const localVarPath = `/messages/{messageId}/pin`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
         * @summary メッセージを削除
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling deleteMessage.');
            }
            const localVarPath = `/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを編集します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ編集することができます。
         * @summary メッセージを編集
         * @param {string} messageId メッセージUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageId, postMessageRequest, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling editMessage.');
            }
            const localVarPath = `/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMessageRequest !== undefined ? postMessageRequest : {}) : (postMessageRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーとのダイレクトメッセージのリストを取得します。
         * @summary ダイレクトメッセージのリストを取得
         * @param {string} userId ユーザーUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userId, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getDirectMessages.');
            }
            const localVarPath = `/users/{userId}/messages`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを取得します。
         * @summary メッセージを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling getMessage.');
            }
            const localVarPath = `/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージに押されているスタンプのリストを取得します。
         * @summary メッセージのスタンプリストを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling getMessageStamps.');
            }
            const localVarPath = `/messages/{messageId}/stamps`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルのメッセージのリストを取得します。
         * @summary チャンネルメッセージのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelId, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getMessages.');
            }
            const localVarPath = `/channels/{channelId}/messages`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージのピン留め情報を取得します。
         * @summary ピン留めを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPin(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling getPin.');
            }
            const localVarPath = `/messages/{messageId}/pin`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーにダイレクトメッセージを送信します。
         * @summary ダイレクトメッセージを送信
         * @param {string} userId ユーザーUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userId, postMessageRequest, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling postDirectMessage.');
            }
            const localVarPath = `/users/{userId}/messages`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMessageRequest !== undefined ? postMessageRequest : {}) : (postMessageRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
         * @summary チャンネルにメッセージを投稿
         * @param {string} channelId チャンネルUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelId, postMessageRequest, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling postMessage.');
            }
            const localVarPath = `/channels/{channelId}/messages`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMessageRequest !== undefined ? postMessageRequest : {}) : (postMessageRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージから指定した自身が押したスタンプを削除します。
         * @summary スタンプを消す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageStamp(messageId, stampId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling removeMessageStamp.');
            }
            // verify required parameter 'stampId' is not null or undefined
            if (stampId === null || stampId === undefined) {
                throw new base_1.RequiredError('stampId', 'Required parameter stampId was null or undefined when calling removeMessageStamp.');
            }
            const localVarPath = `/messages/{messageId}/stamps/{stampId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"stampId"}}`, encodeURIComponent(String(stampId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージのピン留めを外します。
         * @summary ピン留めを外す
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePin(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling removePin.');
            }
            const localVarPath = `/messages/{messageId}/pin`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessageApi - functional programming interface
 * @export
 */
exports.MessageApiFp = function (configuration) {
    return {
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @summary スタンプを押す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {PostMessageStampRequest} [postMessageStampRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageStamp(messageId, stampId, postMessageStampRequest, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).addMessageStamp(messageId, stampId, postMessageStampRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージをピン留めします。
         * @summary ピン留めする
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPin(messageId, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).createPin(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
         * @summary メッセージを削除
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageId, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).deleteMessage(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを編集します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ編集することができます。
         * @summary メッセージを編集
         * @param {string} messageId メッセージUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageId, postMessageRequest, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).editMessage(messageId, postMessageRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーとのダイレクトメッセージのリストを取得します。
         * @summary ダイレクトメッセージのリストを取得
         * @param {string} userId ユーザーUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userId, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getDirectMessages(userId, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを取得します。
         * @summary メッセージを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageId, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getMessage(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージに押されているスタンプのリストを取得します。
         * @summary メッセージのスタンプリストを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageId, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getMessageStamps(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルのメッセージのリストを取得します。
         * @summary チャンネルメッセージのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelId, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getMessages(channelId, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージのピン留め情報を取得します。
         * @summary ピン留めを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPin(messageId, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getPin(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーにダイレクトメッセージを送信します。
         * @summary ダイレクトメッセージを送信
         * @param {string} userId ユーザーUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userId, postMessageRequest, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).postDirectMessage(userId, postMessageRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
         * @summary チャンネルにメッセージを投稿
         * @param {string} channelId チャンネルUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelId, postMessageRequest, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).postMessage(channelId, postMessageRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージから指定した自身が押したスタンプを削除します。
         * @summary スタンプを消す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageStamp(messageId, stampId, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).removeMessageStamp(messageId, stampId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージのピン留めを外します。
         * @summary ピン留めを外す
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePin(messageId, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).removePin(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * MessageApi - factory interface
 * @export
 */
exports.MessageApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @summary スタンプを押す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {PostMessageStampRequest} [postMessageStampRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageStamp(messageId, stampId, postMessageStampRequest, options) {
            return exports.MessageApiFp(configuration).addMessageStamp(messageId, stampId, postMessageStampRequest, options)(axios, basePath);
        },
        /**
         * 指定したメッセージをピン留めします。
         * @summary ピン留めする
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPin(messageId, options) {
            return exports.MessageApiFp(configuration).createPin(messageId, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
         * @summary メッセージを削除
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageId, options) {
            return exports.MessageApiFp(configuration).deleteMessage(messageId, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを編集します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ編集することができます。
         * @summary メッセージを編集
         * @param {string} messageId メッセージUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageId, postMessageRequest, options) {
            return exports.MessageApiFp(configuration).editMessage(messageId, postMessageRequest, options)(axios, basePath);
        },
        /**
         * 指定したユーザーとのダイレクトメッセージのリストを取得します。
         * @summary ダイレクトメッセージのリストを取得
         * @param {string} userId ユーザーUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userId, limit, offset, since, until, inclusive, order, options) {
            return exports.MessageApiFp(configuration).getDirectMessages(userId, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを取得します。
         * @summary メッセージを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageId, options) {
            return exports.MessageApiFp(configuration).getMessage(messageId, options)(axios, basePath);
        },
        /**
         * 指定したメッセージに押されているスタンプのリストを取得します。
         * @summary メッセージのスタンプリストを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageId, options) {
            return exports.MessageApiFp(configuration).getMessageStamps(messageId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルのメッセージのリストを取得します。
         * @summary チャンネルメッセージのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelId, limit, offset, since, until, inclusive, order, options) {
            return exports.MessageApiFp(configuration).getMessages(channelId, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * 指定したメッセージのピン留め情報を取得します。
         * @summary ピン留めを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPin(messageId, options) {
            return exports.MessageApiFp(configuration).getPin(messageId, options)(axios, basePath);
        },
        /**
         * 指定したユーザーにダイレクトメッセージを送信します。
         * @summary ダイレクトメッセージを送信
         * @param {string} userId ユーザーUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userId, postMessageRequest, options) {
            return exports.MessageApiFp(configuration).postDirectMessage(userId, postMessageRequest, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
         * @summary チャンネルにメッセージを投稿
         * @param {string} channelId チャンネルUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelId, postMessageRequest, options) {
            return exports.MessageApiFp(configuration).postMessage(channelId, postMessageRequest, options)(axios, basePath);
        },
        /**
         * 指定したメッセージから指定した自身が押したスタンプを削除します。
         * @summary スタンプを消す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageStamp(messageId, stampId, options) {
            return exports.MessageApiFp(configuration).removeMessageStamp(messageId, stampId, options)(axios, basePath);
        },
        /**
         * 指定したメッセージのピン留めを外します。
         * @summary ピン留めを外す
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePin(messageId, options) {
            return exports.MessageApiFp(configuration).removePin(messageId, options)(axios, basePath);
        },
    };
};
/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
class MessageApi extends base_1.BaseAPI {
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @summary スタンプを押す
     * @param {string} messageId メッセージUUID
     * @param {string} stampId スタンプUUID
     * @param {PostMessageStampRequest} [postMessageStampRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    addMessageStamp(messageId, stampId, postMessageStampRequest, options) {
        return exports.MessageApiFp(this.configuration).addMessageStamp(messageId, stampId, postMessageStampRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージをピン留めします。
     * @summary ピン留めする
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    createPin(messageId, options) {
        return exports.MessageApiFp(this.configuration).createPin(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
     * @summary メッセージを削除
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    deleteMessage(messageId, options) {
        return exports.MessageApiFp(this.configuration).deleteMessage(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを編集します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ編集することができます。
     * @summary メッセージを編集
     * @param {string} messageId メッセージUUID
     * @param {PostMessageRequest} [postMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    editMessage(messageId, postMessageRequest, options) {
        return exports.MessageApiFp(this.configuration).editMessage(messageId, postMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーとのダイレクトメッセージのリストを取得します。
     * @summary ダイレクトメッセージのリストを取得
     * @param {string} userId ユーザーUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getDirectMessages(userId, limit, offset, since, until, inclusive, order, options) {
        return exports.MessageApiFp(this.configuration).getDirectMessages(userId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを取得します。
     * @summary メッセージを取得
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessage(messageId, options) {
        return exports.MessageApiFp(this.configuration).getMessage(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに押されているスタンプのリストを取得します。
     * @summary メッセージのスタンプリストを取得
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessageStamps(messageId, options) {
        return exports.MessageApiFp(this.configuration).getMessageStamps(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのメッセージのリストを取得します。
     * @summary チャンネルメッセージのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessages(channelId, limit, offset, since, until, inclusive, order, options) {
        return exports.MessageApiFp(this.configuration).getMessages(channelId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージのピン留め情報を取得します。
     * @summary ピン留めを取得
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getPin(messageId, options) {
        return exports.MessageApiFp(this.configuration).getPin(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーにダイレクトメッセージを送信します。
     * @summary ダイレクトメッセージを送信
     * @param {string} userId ユーザーUUID
     * @param {PostMessageRequest} [postMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postDirectMessage(userId, postMessageRequest, options) {
        return exports.MessageApiFp(this.configuration).postDirectMessage(userId, postMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
     * @summary チャンネルにメッセージを投稿
     * @param {string} channelId チャンネルUUID
     * @param {PostMessageRequest} [postMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postMessage(channelId, postMessageRequest, options) {
        return exports.MessageApiFp(this.configuration).postMessage(channelId, postMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定した自身が押したスタンプを削除します。
     * @summary スタンプを消す
     * @param {string} messageId メッセージUUID
     * @param {string} stampId スタンプUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    removeMessageStamp(messageId, stampId, options) {
        return exports.MessageApiFp(this.configuration).removeMessageStamp(messageId, stampId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージのピン留めを外します。
     * @summary ピン留めを外す
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    removePin(messageId, options) {
        return exports.MessageApiFp(this.configuration).removePin(messageId, options)(this.axios, this.basePath);
    }
}
exports.MessageApi = MessageApi;
/**
 * NotificationApi - axios parameter creator
 * @export
 */
exports.NotificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
         * @summary チャンネルの通知購読者を編集
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelSubscribers(channelId, patchChannelSubscribersRequest, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling editChannelSubscribers.');
            }
            const localVarPath = `/channels/{channelId}/subscribers`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchChannelSubscribersRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchChannelSubscribersRequest !== undefined ? patchChannelSubscribersRequest : {}) : (patchChannelSubscribersRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
         * @summary チャンネルの通知購読者のリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelSubscribers(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelSubscribers.');
            }
            const localVarPath = `/channels/{channelId}/subscribers`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のチャンネル購読状態を取得します。
         * @summary 自分のチャンネル購読状態を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyChannelSubscriptions(options = {}) {
            const localVarPath = `/users/me/subscriptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 未読チャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUnreadChannels(options = {}) {
            const localVarPath = `/users/me/unread`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
         * @summary 未読チャンネルを既読にします
         * @param {string} [channelId] 既読にするチャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readChannels(channelId, options = {}) {
            const localVarPath = `/users/me/unread`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のFCMデバイスを登録します。
         * @summary FCMデバイスを登録
         * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerFCMDevice(postMyFCMDeviceRequest, options = {}) {
            const localVarPath = `/users/me/fcm-device`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMyFCMDeviceRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMyFCMDeviceRequest !== undefined ? postMyFCMDeviceRequest : {}) : (postMyFCMDeviceRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身の指定したチャンネルの購読レベルを設定します。
         * @summary チャンネル購読レベルを設定
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling setChannelSubscribeLevel.');
            }
            const localVarPath = `/users/me/subscriptions/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putChannelSubscribeLevelRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putChannelSubscribeLevelRequest !== undefined ? putChannelSubscribeLevelRequest : {}) : (putChannelSubscribeLevelRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
         * @summary チャンネルの通知購読者を設定
         * @param {string} channelId チャンネルUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribers(channelId, requestBody, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling setChannelSubscribers.');
            }
            const localVarPath = `/channels/{channelId}/subscribers`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # WebSocketプロトコル ## 送信 `コマンド:引数1:引数2:...`のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### `viewstate`コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  `viewstate:(チャンネルID):(閲覧状態)` + チャンネルID: 対象のチャンネルID + 閲覧状態: `none`, `monitoring`, `editing`  最初の`viewstate`コマンドを送る前、または`viewstate:null`を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ## 受信 SSEのイベントと同じものがTextMessageとして非同期に送られてくる。 `type`と`body`を持つJSONを受信。`type`はSSEのイベントタイプと同じ、`body`はSSEのデータと同じ。 例:  ```json {\"type\":\"USER_ONLINE\",\"body\":{\"id\":\"7dd8e07f-7f5d-4331-9176-b56a4299768b\"}} ```
         * @summary WebSocket通知ストリームに接続します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ws(options = {}) {
            const localVarPath = `/ws`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NotificationApi - functional programming interface
 * @export
 */
exports.NotificationApiFp = function (configuration) {
    return {
        /**
         * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
         * @summary チャンネルの通知購読者を編集
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelSubscribers(channelId, patchChannelSubscribersRequest, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).editChannelSubscribers(channelId, patchChannelSubscribersRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
         * @summary チャンネルの通知購読者のリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelSubscribers(channelId, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).getChannelSubscribers(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のチャンネル購読状態を取得します。
         * @summary 自分のチャンネル購読状態を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyChannelSubscriptions(options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).getMyChannelSubscriptions(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 未読チャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUnreadChannels(options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).getMyUnreadChannels(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
         * @summary 未読チャンネルを既読にします
         * @param {string} [channelId] 既読にするチャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readChannels(channelId, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).readChannels(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のFCMデバイスを登録します。
         * @summary FCMデバイスを登録
         * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerFCMDevice(postMyFCMDeviceRequest, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).registerFCMDevice(postMyFCMDeviceRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身の指定したチャンネルの購読レベルを設定します。
         * @summary チャンネル購読レベルを設定
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
         * @summary チャンネルの通知購読者を設定
         * @param {string} channelId チャンネルUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribers(channelId, requestBody, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).setChannelSubscribers(channelId, requestBody, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * # WebSocketプロトコル ## 送信 `コマンド:引数1:引数2:...`のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### `viewstate`コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  `viewstate:(チャンネルID):(閲覧状態)` + チャンネルID: 対象のチャンネルID + 閲覧状態: `none`, `monitoring`, `editing`  最初の`viewstate`コマンドを送る前、または`viewstate:null`を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ## 受信 SSEのイベントと同じものがTextMessageとして非同期に送られてくる。 `type`と`body`を持つJSONを受信。`type`はSSEのイベントタイプと同じ、`body`はSSEのデータと同じ。 例:  ```json {\"type\":\"USER_ONLINE\",\"body\":{\"id\":\"7dd8e07f-7f5d-4331-9176-b56a4299768b\"}} ```
         * @summary WebSocket通知ストリームに接続します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ws(options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).ws(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * NotificationApi - factory interface
 * @export
 */
exports.NotificationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
         * @summary チャンネルの通知購読者を編集
         * @param {string} channelId チャンネルUUID
         * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannelSubscribers(channelId, patchChannelSubscribersRequest, options) {
            return exports.NotificationApiFp(configuration).editChannelSubscribers(channelId, patchChannelSubscribersRequest, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
         * @summary チャンネルの通知購読者のリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelSubscribers(channelId, options) {
            return exports.NotificationApiFp(configuration).getChannelSubscribers(channelId, options)(axios, basePath);
        },
        /**
         * 自身のチャンネル購読状態を取得します。
         * @summary 自分のチャンネル購読状態を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyChannelSubscriptions(options) {
            return exports.NotificationApiFp(configuration).getMyChannelSubscriptions(options)(axios, basePath);
        },
        /**
         *
         * @summary 未読チャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUnreadChannels(options) {
            return exports.NotificationApiFp(configuration).getMyUnreadChannels(options)(axios, basePath);
        },
        /**
         * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
         * @summary 未読チャンネルを既読にします
         * @param {string} [channelId] 既読にするチャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readChannels(channelId, options) {
            return exports.NotificationApiFp(configuration).readChannels(channelId, options)(axios, basePath);
        },
        /**
         * 自身のFCMデバイスを登録します。
         * @summary FCMデバイスを登録
         * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerFCMDevice(postMyFCMDeviceRequest, options) {
            return exports.NotificationApiFp(configuration).registerFCMDevice(postMyFCMDeviceRequest, options)(axios, basePath);
        },
        /**
         * 自身の指定したチャンネルの購読レベルを設定します。
         * @summary チャンネル購読レベルを設定
         * @param {string} channelId チャンネルUUID
         * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options) {
            return exports.NotificationApiFp(configuration).setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
         * @summary チャンネルの通知購読者を設定
         * @param {string} channelId チャンネルUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelSubscribers(channelId, requestBody, options) {
            return exports.NotificationApiFp(configuration).setChannelSubscribers(channelId, requestBody, options)(axios, basePath);
        },
        /**
         * # WebSocketプロトコル ## 送信 `コマンド:引数1:引数2:...`のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### `viewstate`コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  `viewstate:(チャンネルID):(閲覧状態)` + チャンネルID: 対象のチャンネルID + 閲覧状態: `none`, `monitoring`, `editing`  最初の`viewstate`コマンドを送る前、または`viewstate:null`を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ## 受信 SSEのイベントと同じものがTextMessageとして非同期に送られてくる。 `type`と`body`を持つJSONを受信。`type`はSSEのイベントタイプと同じ、`body`はSSEのデータと同じ。 例:  ```json {\"type\":\"USER_ONLINE\",\"body\":{\"id\":\"7dd8e07f-7f5d-4331-9176-b56a4299768b\"}} ```
         * @summary WebSocket通知ストリームに接続します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ws(options) {
            return exports.NotificationApiFp(configuration).ws(options)(axios, basePath);
        },
    };
};
/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
class NotificationApi extends base_1.BaseAPI {
    /**
     * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
     * @summary チャンネルの通知購読者を編集
     * @param {string} channelId チャンネルUUID
     * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    editChannelSubscribers(channelId, patchChannelSubscribersRequest, options) {
        return exports.NotificationApiFp(this.configuration).editChannelSubscribers(channelId, patchChannelSubscribersRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
     * @summary チャンネルの通知購読者のリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getChannelSubscribers(channelId, options) {
        return exports.NotificationApiFp(this.configuration).getChannelSubscribers(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 自身のチャンネル購読状態を取得します。
     * @summary 自分のチャンネル購読状態を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getMyChannelSubscriptions(options) {
        return exports.NotificationApiFp(this.configuration).getMyChannelSubscriptions(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 未読チャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getMyUnreadChannels(options) {
        return exports.NotificationApiFp(this.configuration).getMyUnreadChannels(options)(this.axios, this.basePath);
    }
    /**
     * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
     * @summary 未読チャンネルを既読にします
     * @param {string} [channelId] 既読にするチャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    readChannels(channelId, options) {
        return exports.NotificationApiFp(this.configuration).readChannels(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 自身のFCMデバイスを登録します。
     * @summary FCMデバイスを登録
     * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    registerFCMDevice(postMyFCMDeviceRequest, options) {
        return exports.NotificationApiFp(this.configuration).registerFCMDevice(postMyFCMDeviceRequest, options)(this.axios, this.basePath);
    }
    /**
     * 自身の指定したチャンネルの購読レベルを設定します。
     * @summary チャンネル購読レベルを設定
     * @param {string} channelId チャンネルUUID
     * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options) {
        return exports.NotificationApiFp(this.configuration).setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
     * @summary チャンネルの通知購読者を設定
     * @param {string} channelId チャンネルUUID
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    setChannelSubscribers(channelId, requestBody, options) {
        return exports.NotificationApiFp(this.configuration).setChannelSubscribers(channelId, requestBody, options)(this.axios, this.basePath);
    }
    /**
     * # WebSocketプロトコル ## 送信 `コマンド:引数1:引数2:...`のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### `viewstate`コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  `viewstate:(チャンネルID):(閲覧状態)` + チャンネルID: 対象のチャンネルID + 閲覧状態: `none`, `monitoring`, `editing`  最初の`viewstate`コマンドを送る前、または`viewstate:null`を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ## 受信 SSEのイベントと同じものがTextMessageとして非同期に送られてくる。 `type`と`body`を持つJSONを受信。`type`はSSEのイベントタイプと同じ、`body`はSSEのデータと同じ。 例:  ```json {\"type\":\"USER_ONLINE\",\"body\":{\"id\":\"7dd8e07f-7f5d-4331-9176-b56a4299768b\"}} ```
     * @summary WebSocket通知ストリームに接続します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    ws(options) {
        return exports.NotificationApiFp(this.configuration).ws(options)(this.axios, this.basePath);
    }
}
exports.NotificationApi = NotificationApi;
/**
 * Oauth2Api - axios parameter creator
 * @export
 */
exports.Oauth2ApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * OAuth2クライアントを作成します。
         * @summary OAuth2クライアントを作成
         * @param {PostClientRequest} [postClientRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClientRequest, options = {}) {
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postClientRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postClientRequest !== undefined ? postClientRequest : {}) : (postClientRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
         * @summary OAuth2クライアントを削除
         * @param {string} clientId OAuth2クライアントUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientId, options = {}) {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new base_1.RequiredError('clientId', 'Required parameter clientId was null or undefined when calling deleteClient.');
            }
            const localVarPath = `/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
         * @summary OAuth2クライアント情報を変更
         * @param {string} clientId OAuth2クライアントUUID
         * @param {PatchClientRequest} [patchClientRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClient(clientId, patchClientRequest, options = {}) {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new base_1.RequiredError('clientId', 'Required parameter clientId was null or undefined when calling editClient.');
            }
            const localVarPath = `/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchClientRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchClientRequest !== undefined ? patchClientRequest : {}) : (patchClientRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
         * @summary OAuth2クライアント情報を取得
         * @param {string} clientId OAuth2クライアントUUID
         * @param {boolean} [detail] 詳細情報を含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientId, detail, options = {}) {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new base_1.RequiredError('clientId', 'Required parameter clientId was null or undefined when calling getClient.');
            }
            const localVarPath = `/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身が開発者のOAuth2クライアントのリストを取得します。 全てのクライアントを取得する場合は、権限が必要です。
         * @summary OAuth2クライアントのリストを取得
         * @param {boolean} [all] 全てのクライアントを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(all, options = {}) {
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 有効なOAuth2トークンのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyTokens(options = {}) {
            const localVarPath = `/users/me/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary トークンの認可を取り消します
         * @param {string} tokenId OAuth2トークンUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMyToken(tokenId, options = {}) {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new base_1.RequiredError('tokenId', 'Required parameter tokenId was null or undefined when calling revokeMyToken.');
            }
            const localVarPath = `/users/me/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * Oauth2Api - functional programming interface
 * @export
 */
exports.Oauth2ApiFp = function (configuration) {
    return {
        /**
         * OAuth2クライアントを作成します。
         * @summary OAuth2クライアントを作成
         * @param {PostClientRequest} [postClientRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClientRequest, options) {
            const localVarAxiosArgs = exports.Oauth2ApiAxiosParamCreator(configuration).createClient(postClientRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
         * @summary OAuth2クライアントを削除
         * @param {string} clientId OAuth2クライアントUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientId, options) {
            const localVarAxiosArgs = exports.Oauth2ApiAxiosParamCreator(configuration).deleteClient(clientId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
         * @summary OAuth2クライアント情報を変更
         * @param {string} clientId OAuth2クライアントUUID
         * @param {PatchClientRequest} [patchClientRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClient(clientId, patchClientRequest, options) {
            const localVarAxiosArgs = exports.Oauth2ApiAxiosParamCreator(configuration).editClient(clientId, patchClientRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
         * @summary OAuth2クライアント情報を取得
         * @param {string} clientId OAuth2クライアントUUID
         * @param {boolean} [detail] 詳細情報を含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientId, detail, options) {
            const localVarAxiosArgs = exports.Oauth2ApiAxiosParamCreator(configuration).getClient(clientId, detail, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身が開発者のOAuth2クライアントのリストを取得します。 全てのクライアントを取得する場合は、権限が必要です。
         * @summary OAuth2クライアントのリストを取得
         * @param {boolean} [all] 全てのクライアントを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(all, options) {
            const localVarAxiosArgs = exports.Oauth2ApiAxiosParamCreator(configuration).getClients(all, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 有効なOAuth2トークンのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyTokens(options) {
            const localVarAxiosArgs = exports.Oauth2ApiAxiosParamCreator(configuration).getMyTokens(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary トークンの認可を取り消します
         * @param {string} tokenId OAuth2トークンUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMyToken(tokenId, options) {
            const localVarAxiosArgs = exports.Oauth2ApiAxiosParamCreator(configuration).revokeMyToken(tokenId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * Oauth2Api - factory interface
 * @export
 */
exports.Oauth2ApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * OAuth2クライアントを作成します。
         * @summary OAuth2クライアントを作成
         * @param {PostClientRequest} [postClientRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClientRequest, options) {
            return exports.Oauth2ApiFp(configuration).createClient(postClientRequest, options)(axios, basePath);
        },
        /**
         * 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
         * @summary OAuth2クライアントを削除
         * @param {string} clientId OAuth2クライアントUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientId, options) {
            return exports.Oauth2ApiFp(configuration).deleteClient(clientId, options)(axios, basePath);
        },
        /**
         * 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
         * @summary OAuth2クライアント情報を変更
         * @param {string} clientId OAuth2クライアントUUID
         * @param {PatchClientRequest} [patchClientRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editClient(clientId, patchClientRequest, options) {
            return exports.Oauth2ApiFp(configuration).editClient(clientId, patchClientRequest, options)(axios, basePath);
        },
        /**
         * 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
         * @summary OAuth2クライアント情報を取得
         * @param {string} clientId OAuth2クライアントUUID
         * @param {boolean} [detail] 詳細情報を含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientId, detail, options) {
            return exports.Oauth2ApiFp(configuration).getClient(clientId, detail, options)(axios, basePath);
        },
        /**
         * 自身が開発者のOAuth2クライアントのリストを取得します。 全てのクライアントを取得する場合は、権限が必要です。
         * @summary OAuth2クライアントのリストを取得
         * @param {boolean} [all] 全てのクライアントを取得するかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(all, options) {
            return exports.Oauth2ApiFp(configuration).getClients(all, options)(axios, basePath);
        },
        /**
         *
         * @summary 有効なOAuth2トークンのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyTokens(options) {
            return exports.Oauth2ApiFp(configuration).getMyTokens(options)(axios, basePath);
        },
        /**
         *
         * @summary トークンの認可を取り消します
         * @param {string} tokenId OAuth2トークンUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeMyToken(tokenId, options) {
            return exports.Oauth2ApiFp(configuration).revokeMyToken(tokenId, options)(axios, basePath);
        },
    };
};
/**
 * Oauth2Api - object-oriented interface
 * @export
 * @class Oauth2Api
 * @extends {BaseAPI}
 */
class Oauth2Api extends base_1.BaseAPI {
    /**
     * OAuth2クライアントを作成します。
     * @summary OAuth2クライアントを作成
     * @param {PostClientRequest} [postClientRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    createClient(postClientRequest, options) {
        return exports.Oauth2ApiFp(this.configuration).createClient(postClientRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
     * @summary OAuth2クライアントを削除
     * @param {string} clientId OAuth2クライアントUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    deleteClient(clientId, options) {
        return exports.Oauth2ApiFp(this.configuration).deleteClient(clientId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
     * @summary OAuth2クライアント情報を変更
     * @param {string} clientId OAuth2クライアントUUID
     * @param {PatchClientRequest} [patchClientRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    editClient(clientId, patchClientRequest, options) {
        return exports.Oauth2ApiFp(this.configuration).editClient(clientId, patchClientRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
     * @summary OAuth2クライアント情報を取得
     * @param {string} clientId OAuth2クライアントUUID
     * @param {boolean} [detail] 詳細情報を含めるかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    getClient(clientId, detail, options) {
        return exports.Oauth2ApiFp(this.configuration).getClient(clientId, detail, options)(this.axios, this.basePath);
    }
    /**
     * 自身が開発者のOAuth2クライアントのリストを取得します。 全てのクライアントを取得する場合は、権限が必要です。
     * @summary OAuth2クライアントのリストを取得
     * @param {boolean} [all] 全てのクライアントを取得するかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    getClients(all, options) {
        return exports.Oauth2ApiFp(this.configuration).getClients(all, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 有効なOAuth2トークンのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    getMyTokens(options) {
        return exports.Oauth2ApiFp(this.configuration).getMyTokens(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary トークンの認可を取り消します
     * @param {string} tokenId OAuth2トークンUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    revokeMyToken(tokenId, options) {
        return exports.Oauth2ApiFp(this.configuration).revokeMyToken(tokenId, options)(this.axios, this.basePath);
    }
}
exports.Oauth2Api = Oauth2Api;
/**
 * PinApi - axios parameter creator
 * @export
 */
exports.PinApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したメッセージをピン留めします。
         * @summary ピン留めする
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPin(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling createPin.');
            }
            const localVarPath = `/messages/{messageId}/pin`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
         * @summary チャンネルピンのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelPins(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelPins.');
            }
            const localVarPath = `/channels/{channelId}/pins`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージのピン留め情報を取得します。
         * @summary ピン留めを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPin(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling getPin.');
            }
            const localVarPath = `/messages/{messageId}/pin`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージのピン留めを外します。
         * @summary ピン留めを外す
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePin(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling removePin.');
            }
            const localVarPath = `/messages/{messageId}/pin`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PinApi - functional programming interface
 * @export
 */
exports.PinApiFp = function (configuration) {
    return {
        /**
         * 指定したメッセージをピン留めします。
         * @summary ピン留めする
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPin(messageId, options) {
            const localVarAxiosArgs = exports.PinApiAxiosParamCreator(configuration).createPin(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
         * @summary チャンネルピンのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelPins(channelId, options) {
            const localVarAxiosArgs = exports.PinApiAxiosParamCreator(configuration).getChannelPins(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージのピン留め情報を取得します。
         * @summary ピン留めを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPin(messageId, options) {
            const localVarAxiosArgs = exports.PinApiAxiosParamCreator(configuration).getPin(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージのピン留めを外します。
         * @summary ピン留めを外す
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePin(messageId, options) {
            const localVarAxiosArgs = exports.PinApiAxiosParamCreator(configuration).removePin(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PinApi - factory interface
 * @export
 */
exports.PinApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したメッセージをピン留めします。
         * @summary ピン留めする
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPin(messageId, options) {
            return exports.PinApiFp(configuration).createPin(messageId, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
         * @summary チャンネルピンのリストを取得
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelPins(channelId, options) {
            return exports.PinApiFp(configuration).getChannelPins(channelId, options)(axios, basePath);
        },
        /**
         * 指定したメッセージのピン留め情報を取得します。
         * @summary ピン留めを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPin(messageId, options) {
            return exports.PinApiFp(configuration).getPin(messageId, options)(axios, basePath);
        },
        /**
         * 指定したメッセージのピン留めを外します。
         * @summary ピン留めを外す
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePin(messageId, options) {
            return exports.PinApiFp(configuration).removePin(messageId, options)(axios, basePath);
        },
    };
};
/**
 * PinApi - object-oriented interface
 * @export
 * @class PinApi
 * @extends {BaseAPI}
 */
class PinApi extends base_1.BaseAPI {
    /**
     * 指定したメッセージをピン留めします。
     * @summary ピン留めする
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    createPin(messageId, options) {
        return exports.PinApiFp(this.configuration).createPin(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
     * @summary チャンネルピンのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getChannelPins(channelId, options) {
        return exports.PinApiFp(this.configuration).getChannelPins(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージのピン留め情報を取得します。
     * @summary ピン留めを取得
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPin(messageId, options) {
        return exports.PinApiFp(this.configuration).getPin(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージのピン留めを外します。
     * @summary ピン留めを外す
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    removePin(messageId, options) {
        return exports.PinApiFp(this.configuration).removePin(messageId, options)(this.axios, this.basePath);
    }
}
exports.PinApi = PinApi;
/**
 * PublicApi - axios parameter creator
 * @export
 */
exports.PublicApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ユーザーのアイコン画像を取得します。
         * @summary ユーザーのアイコン画像を取得
         * @param {string} username ユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options = {}) {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new base_1.RequiredError('username', 'Required parameter username was null or undefined when calling getPublicUserIcon.');
            }
            const localVarPath = `/public/icon/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary バージョンを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options = {}) {
            const localVarPath = `/version`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PublicApi - functional programming interface
 * @export
 */
exports.PublicApiFp = function (configuration) {
    return {
        /**
         * ユーザーのアイコン画像を取得します。
         * @summary ユーザーのアイコン画像を取得
         * @param {string} username ユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).getPublicUserIcon(username, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary バージョンを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).getServerVersion(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PublicApi - factory interface
 * @export
 */
exports.PublicApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ユーザーのアイコン画像を取得します。
         * @summary ユーザーのアイコン画像を取得
         * @param {string} username ユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options) {
            return exports.PublicApiFp(configuration).getPublicUserIcon(username, options)(axios, basePath);
        },
        /**
         *
         * @summary バージョンを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options) {
            return exports.PublicApiFp(configuration).getServerVersion(options)(axios, basePath);
        },
    };
};
/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
class PublicApi extends base_1.BaseAPI {
    /**
     * ユーザーのアイコン画像を取得します。
     * @summary ユーザーのアイコン画像を取得
     * @param {string} username ユーザー名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getPublicUserIcon(username, options) {
        return exports.PublicApiFp(this.configuration).getPublicUserIcon(username, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary バージョンを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getServerVersion(options) {
        return exports.PublicApiFp(this.configuration).getServerVersion(options)(this.axios, this.basePath);
    }
}
exports.PublicApi = PublicApi;
/**
 * StampApi - axios parameter creator
 * @export
 */
exports.StampApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @summary スタンプを押す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {PostMessageStampRequest} [postMessageStampRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageStamp(messageId, stampId, postMessageStampRequest, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling addMessageStamp.');
            }
            // verify required parameter 'stampId' is not null or undefined
            if (stampId === null || stampId === undefined) {
                throw new base_1.RequiredError('stampId', 'Required parameter stampId was null or undefined when calling addMessageStamp.');
            }
            const localVarPath = `/messages/{messageId}/stamps/{stampId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"stampId"}}`, encodeURIComponent(String(stampId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMessageStampRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMessageStampRequest !== undefined ? postMessageStampRequest : {}) : (postMessageStampRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプを新規作成します。
         * @summary スタンプを作成
         * @param {string} name スタンプ名
         * @param {any} file スタンプ画像(1MBまでのpng, jpeg, gif, svg)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling createStamp.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling createStamp.');
            }
            const localVarPath = `/stamps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプパレットを作成します。
         * @summary スタンプパレットを作成
         * @param {PostStampPaletteRequest} [postStampPaletteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStampPalette(postStampPaletteRequest, options = {}) {
            const localVarPath = `/stamp-palettes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postStampPaletteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postStampPaletteRequest !== undefined ? postStampPaletteRequest : {}) : (postStampPaletteRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
         * @summary スタンプを削除
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampId, options = {}) {
            // verify required parameter 'stampId' is not null or undefined
            if (stampId === null || stampId === undefined) {
                throw new base_1.RequiredError('stampId', 'Required parameter stampId was null or undefined when calling deleteStamp.');
            }
            const localVarPath = `/stamps/{stampId}`
                .replace(`{${"stampId"}}`, encodeURIComponent(String(stampId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
         * @summary スタンプパレットを削除
         * @param {string} paletteId スタンプパレットUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStampPalette(paletteId, options = {}) {
            // verify required parameter 'paletteId' is not null or undefined
            if (paletteId === null || paletteId === undefined) {
                throw new base_1.RequiredError('paletteId', 'Required parameter paletteId was null or undefined when calling deleteStampPalette.');
            }
            const localVarPath = `/stamp-palettes/{paletteId}`
                .replace(`{${"paletteId"}}`, encodeURIComponent(String(paletteId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したスタンプパレットの情報を変更します。 対象のスタンプパレットの管理権限が必要です。
         * @summary スタンプパレット情報を変更
         * @param {string} paletteId スタンプパレットUUID
         * @param {PatchStampPaletteRequest} [patchStampPaletteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStampPalette(paletteId, patchStampPaletteRequest, options = {}) {
            // verify required parameter 'paletteId' is not null or undefined
            if (paletteId === null || paletteId === undefined) {
                throw new base_1.RequiredError('paletteId', 'Required parameter paletteId was null or undefined when calling editStampPalette.');
            }
            const localVarPath = `/stamp-palettes/{paletteId}`
                .replace(`{${"paletteId"}}`, encodeURIComponent(String(paletteId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchStampPaletteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchStampPaletteRequest !== undefined ? patchStampPaletteRequest : {}) : (patchStampPaletteRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したスタンプパレットのスタンプを編集します。 対象のスタンプパレットの管理権限が必要です。
         * @summary パレット内のスタンプを編集
         * @param {string} paletteId スタンプパレットUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStampPaletteStamps(paletteId, requestBody, options = {}) {
            // verify required parameter 'paletteId' is not null or undefined
            if (paletteId === null || paletteId === undefined) {
                throw new base_1.RequiredError('paletteId', 'Required parameter paletteId was null or undefined when calling editStampPaletteStamps.');
            }
            const localVarPath = `/stamp-palettes/{paletteId}/stamps`
                .replace(`{${"paletteId"}}`, encodeURIComponent(String(paletteId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージに押されているスタンプのリストを取得します。
         * @summary メッセージのスタンプリストを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling getMessageStamps.');
            }
            const localVarPath = `/messages/{messageId}/stamps`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
         * @summary スタンプ履歴を取得
         * @param {number} [limit] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStampHistory(limit, options = {}) {
            const localVarPath = `/users/me/stamp-history`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したスタンプの情報を取得します。
         * @summary スタンプ情報を取得
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampId, options = {}) {
            // verify required parameter 'stampId' is not null or undefined
            if (stampId === null || stampId === undefined) {
                throw new base_1.RequiredError('stampId', 'Required parameter stampId was null or undefined when calling getStamp.');
            }
            const localVarPath = `/stamps/{stampId}`
                .replace(`{${"stampId"}}`, encodeURIComponent(String(stampId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したスタンプパレットの情報を取得します。
         * @summary スタンプパレットを取得
         * @param {string} paletteId スタンプパレットUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampPalette(paletteId, options = {}) {
            // verify required parameter 'paletteId' is not null or undefined
            if (paletteId === null || paletteId === undefined) {
                throw new base_1.RequiredError('paletteId', 'Required parameter paletteId was null or undefined when calling getStampPalette.');
            }
            const localVarPath = `/stamp-palettes/{paletteId}`
                .replace(`{${"paletteId"}}`, encodeURIComponent(String(paletteId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身が所有しているスタンプパレットのリストを取得します。
         * @summary スタンプパレットのリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampPalettes(options = {}) {
            const localVarPath = `/stamp-palettes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプのリストを取得します。
         * @summary スタンプリストを取得
         * @param {boolean} [includeUnicode] Unicode絵文字を含ませるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(includeUnicode, options = {}) {
            const localVarPath = `/stamps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includeUnicode !== undefined) {
                localVarQueryParameter['include-unicode'] = includeUnicode;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージから指定した自身が押したスタンプを削除します。
         * @summary スタンプを消す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageStamp(messageId, stampId, options = {}) {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new base_1.RequiredError('messageId', 'Required parameter messageId was null or undefined when calling removeMessageStamp.');
            }
            // verify required parameter 'stampId' is not null or undefined
            if (stampId === null || stampId === undefined) {
                throw new base_1.RequiredError('stampId', 'Required parameter stampId was null or undefined when calling removeMessageStamp.');
            }
            const localVarPath = `/messages/{messageId}/stamps/{stampId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"stampId"}}`, encodeURIComponent(String(stampId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StampApi - functional programming interface
 * @export
 */
exports.StampApiFp = function (configuration) {
    return {
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @summary スタンプを押す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {PostMessageStampRequest} [postMessageStampRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageStamp(messageId, stampId, postMessageStampRequest, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).addMessageStamp(messageId, stampId, postMessageStampRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプを新規作成します。
         * @summary スタンプを作成
         * @param {string} name スタンプ名
         * @param {any} file スタンプ画像(1MBまでのpng, jpeg, gif, svg)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).createStamp(name, file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプパレットを作成します。
         * @summary スタンプパレットを作成
         * @param {PostStampPaletteRequest} [postStampPaletteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStampPalette(postStampPaletteRequest, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).createStampPalette(postStampPaletteRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
         * @summary スタンプを削除
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampId, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).deleteStamp(stampId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
         * @summary スタンプパレットを削除
         * @param {string} paletteId スタンプパレットUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStampPalette(paletteId, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).deleteStampPalette(paletteId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したスタンプパレットの情報を変更します。 対象のスタンプパレットの管理権限が必要です。
         * @summary スタンプパレット情報を変更
         * @param {string} paletteId スタンプパレットUUID
         * @param {PatchStampPaletteRequest} [patchStampPaletteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStampPalette(paletteId, patchStampPaletteRequest, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).editStampPalette(paletteId, patchStampPaletteRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したスタンプパレットのスタンプを編集します。 対象のスタンプパレットの管理権限が必要です。
         * @summary パレット内のスタンプを編集
         * @param {string} paletteId スタンプパレットUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStampPaletteStamps(paletteId, requestBody, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).editStampPaletteStamps(paletteId, requestBody, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージに押されているスタンプのリストを取得します。
         * @summary メッセージのスタンプリストを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageId, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getMessageStamps(messageId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
         * @summary スタンプ履歴を取得
         * @param {number} [limit] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStampHistory(limit, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getMyStampHistory(limit, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したスタンプの情報を取得します。
         * @summary スタンプ情報を取得
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampId, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getStamp(stampId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したスタンプパレットの情報を取得します。
         * @summary スタンプパレットを取得
         * @param {string} paletteId スタンプパレットUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampPalette(paletteId, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getStampPalette(paletteId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身が所有しているスタンプパレットのリストを取得します。
         * @summary スタンプパレットのリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampPalettes(options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getStampPalettes(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプのリストを取得します。
         * @summary スタンプリストを取得
         * @param {boolean} [includeUnicode] Unicode絵文字を含ませるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(includeUnicode, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getStamps(includeUnicode, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージから指定した自身が押したスタンプを削除します。
         * @summary スタンプを消す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageStamp(messageId, stampId, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).removeMessageStamp(messageId, stampId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StampApi - factory interface
 * @export
 */
exports.StampApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @summary スタンプを押す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {PostMessageStampRequest} [postMessageStampRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageStamp(messageId, stampId, postMessageStampRequest, options) {
            return exports.StampApiFp(configuration).addMessageStamp(messageId, stampId, postMessageStampRequest, options)(axios, basePath);
        },
        /**
         * スタンプを新規作成します。
         * @summary スタンプを作成
         * @param {string} name スタンプ名
         * @param {any} file スタンプ画像(1MBまでのpng, jpeg, gif, svg)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options) {
            return exports.StampApiFp(configuration).createStamp(name, file, options)(axios, basePath);
        },
        /**
         * スタンプパレットを作成します。
         * @summary スタンプパレットを作成
         * @param {PostStampPaletteRequest} [postStampPaletteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStampPalette(postStampPaletteRequest, options) {
            return exports.StampApiFp(configuration).createStampPalette(postStampPaletteRequest, options)(axios, basePath);
        },
        /**
         * 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
         * @summary スタンプを削除
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampId, options) {
            return exports.StampApiFp(configuration).deleteStamp(stampId, options)(axios, basePath);
        },
        /**
         * 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
         * @summary スタンプパレットを削除
         * @param {string} paletteId スタンプパレットUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStampPalette(paletteId, options) {
            return exports.StampApiFp(configuration).deleteStampPalette(paletteId, options)(axios, basePath);
        },
        /**
         * 指定したスタンプパレットの情報を変更します。 対象のスタンプパレットの管理権限が必要です。
         * @summary スタンプパレット情報を変更
         * @param {string} paletteId スタンプパレットUUID
         * @param {PatchStampPaletteRequest} [patchStampPaletteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStampPalette(paletteId, patchStampPaletteRequest, options) {
            return exports.StampApiFp(configuration).editStampPalette(paletteId, patchStampPaletteRequest, options)(axios, basePath);
        },
        /**
         * 指定したスタンプパレットのスタンプを編集します。 対象のスタンプパレットの管理権限が必要です。
         * @summary パレット内のスタンプを編集
         * @param {string} paletteId スタンプパレットUUID
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStampPaletteStamps(paletteId, requestBody, options) {
            return exports.StampApiFp(configuration).editStampPaletteStamps(paletteId, requestBody, options)(axios, basePath);
        },
        /**
         * 指定したメッセージに押されているスタンプのリストを取得します。
         * @summary メッセージのスタンプリストを取得
         * @param {string} messageId メッセージUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageId, options) {
            return exports.StampApiFp(configuration).getMessageStamps(messageId, options)(axios, basePath);
        },
        /**
         * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
         * @summary スタンプ履歴を取得
         * @param {number} [limit] 件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStampHistory(limit, options) {
            return exports.StampApiFp(configuration).getMyStampHistory(limit, options)(axios, basePath);
        },
        /**
         * 指定したスタンプの情報を取得します。
         * @summary スタンプ情報を取得
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampId, options) {
            return exports.StampApiFp(configuration).getStamp(stampId, options)(axios, basePath);
        },
        /**
         * 指定したスタンプパレットの情報を取得します。
         * @summary スタンプパレットを取得
         * @param {string} paletteId スタンプパレットUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampPalette(paletteId, options) {
            return exports.StampApiFp(configuration).getStampPalette(paletteId, options)(axios, basePath);
        },
        /**
         * 自身が所有しているスタンプパレットのリストを取得します。
         * @summary スタンプパレットのリストを取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampPalettes(options) {
            return exports.StampApiFp(configuration).getStampPalettes(options)(axios, basePath);
        },
        /**
         * スタンプのリストを取得します。
         * @summary スタンプリストを取得
         * @param {boolean} [includeUnicode] Unicode絵文字を含ませるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(includeUnicode, options) {
            return exports.StampApiFp(configuration).getStamps(includeUnicode, options)(axios, basePath);
        },
        /**
         * 指定したメッセージから指定した自身が押したスタンプを削除します。
         * @summary スタンプを消す
         * @param {string} messageId メッセージUUID
         * @param {string} stampId スタンプUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageStamp(messageId, stampId, options) {
            return exports.StampApiFp(configuration).removeMessageStamp(messageId, stampId, options)(axios, basePath);
        },
    };
};
/**
 * StampApi - object-oriented interface
 * @export
 * @class StampApi
 * @extends {BaseAPI}
 */
class StampApi extends base_1.BaseAPI {
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @summary スタンプを押す
     * @param {string} messageId メッセージUUID
     * @param {string} stampId スタンプUUID
     * @param {PostMessageStampRequest} [postMessageStampRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    addMessageStamp(messageId, stampId, postMessageStampRequest, options) {
        return exports.StampApiFp(this.configuration).addMessageStamp(messageId, stampId, postMessageStampRequest, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを新規作成します。
     * @summary スタンプを作成
     * @param {string} name スタンプ名
     * @param {any} file スタンプ画像(1MBまでのpng, jpeg, gif, svg)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    createStamp(name, file, options) {
        return exports.StampApiFp(this.configuration).createStamp(name, file, options)(this.axios, this.basePath);
    }
    /**
     * スタンプパレットを作成します。
     * @summary スタンプパレットを作成
     * @param {PostStampPaletteRequest} [postStampPaletteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    createStampPalette(postStampPaletteRequest, options) {
        return exports.StampApiFp(this.configuration).createStampPalette(postStampPaletteRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
     * @summary スタンプを削除
     * @param {string} stampId スタンプUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    deleteStamp(stampId, options) {
        return exports.StampApiFp(this.configuration).deleteStamp(stampId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
     * @summary スタンプパレットを削除
     * @param {string} paletteId スタンプパレットUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    deleteStampPalette(paletteId, options) {
        return exports.StampApiFp(this.configuration).deleteStampPalette(paletteId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプパレットの情報を変更します。 対象のスタンプパレットの管理権限が必要です。
     * @summary スタンプパレット情報を変更
     * @param {string} paletteId スタンプパレットUUID
     * @param {PatchStampPaletteRequest} [patchStampPaletteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    editStampPalette(paletteId, patchStampPaletteRequest, options) {
        return exports.StampApiFp(this.configuration).editStampPalette(paletteId, patchStampPaletteRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプパレットのスタンプを編集します。 対象のスタンプパレットの管理権限が必要です。
     * @summary パレット内のスタンプを編集
     * @param {string} paletteId スタンプパレットUUID
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    editStampPaletteStamps(paletteId, requestBody, options) {
        return exports.StampApiFp(this.configuration).editStampPaletteStamps(paletteId, requestBody, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに押されているスタンプのリストを取得します。
     * @summary メッセージのスタンプリストを取得
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getMessageStamps(messageId, options) {
        return exports.StampApiFp(this.configuration).getMessageStamps(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
     * @summary スタンプ履歴を取得
     * @param {number} [limit] 件数
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getMyStampHistory(limit, options) {
        return exports.StampApiFp(this.configuration).getMyStampHistory(limit, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプの情報を取得します。
     * @summary スタンプ情報を取得
     * @param {string} stampId スタンプUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamp(stampId, options) {
        return exports.StampApiFp(this.configuration).getStamp(stampId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプパレットの情報を取得します。
     * @summary スタンプパレットを取得
     * @param {string} paletteId スタンプパレットUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStampPalette(paletteId, options) {
        return exports.StampApiFp(this.configuration).getStampPalette(paletteId, options)(this.axios, this.basePath);
    }
    /**
     * 自身が所有しているスタンプパレットのリストを取得します。
     * @summary スタンプパレットのリストを取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStampPalettes(options) {
        return exports.StampApiFp(this.configuration).getStampPalettes(options)(this.axios, this.basePath);
    }
    /**
     * スタンプのリストを取得します。
     * @summary スタンプリストを取得
     * @param {boolean} [includeUnicode] Unicode絵文字を含ませるかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamps(includeUnicode, options) {
        return exports.StampApiFp(this.configuration).getStamps(includeUnicode, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定した自身が押したスタンプを削除します。
     * @summary スタンプを消す
     * @param {string} messageId メッセージUUID
     * @param {string} stampId スタンプUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    removeMessageStamp(messageId, stampId, options) {
        return exports.StampApiFp(this.configuration).removeMessageStamp(messageId, stampId, options)(this.axios, this.basePath);
    }
}
exports.StampApi = StampApi;
/**
 * StarApi - axios parameter creator
 * @export
 */
exports.StarApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary チャンネルをスターします
         * @param {PostStarRequest} [postStarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyStar(postStarRequest, options = {}) {
            const localVarPath = `/users/me/stars`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postStarRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postStarRequest !== undefined ? postStarRequest : {}) : (postStarRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary スターチャンネルリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStars(options = {}) {
            const localVarPath = `/users/me/stars`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 既にスターから削除されているチャンネルを指定した場合は204を返します。
         * @summary チャンネルをスターから削除します
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyStar(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling removeMyStar.');
            }
            const localVarPath = `/users/me/stars/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StarApi - functional programming interface
 * @export
 */
exports.StarApiFp = function (configuration) {
    return {
        /**
         *
         * @summary チャンネルをスターします
         * @param {PostStarRequest} [postStarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyStar(postStarRequest, options) {
            const localVarAxiosArgs = exports.StarApiAxiosParamCreator(configuration).addMyStar(postStarRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary スターチャンネルリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStars(options) {
            const localVarAxiosArgs = exports.StarApiAxiosParamCreator(configuration).getMyStars(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 既にスターから削除されているチャンネルを指定した場合は204を返します。
         * @summary チャンネルをスターから削除します
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyStar(channelId, options) {
            const localVarAxiosArgs = exports.StarApiAxiosParamCreator(configuration).removeMyStar(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StarApi - factory interface
 * @export
 */
exports.StarApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary チャンネルをスターします
         * @param {PostStarRequest} [postStarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyStar(postStarRequest, options) {
            return exports.StarApiFp(configuration).addMyStar(postStarRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary スターチャンネルリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStars(options) {
            return exports.StarApiFp(configuration).getMyStars(options)(axios, basePath);
        },
        /**
         * 既にスターから削除されているチャンネルを指定した場合は204を返します。
         * @summary チャンネルをスターから削除します
         * @param {string} channelId チャンネルUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyStar(channelId, options) {
            return exports.StarApiFp(configuration).removeMyStar(channelId, options)(axios, basePath);
        },
    };
};
/**
 * StarApi - object-oriented interface
 * @export
 * @class StarApi
 * @extends {BaseAPI}
 */
class StarApi extends base_1.BaseAPI {
    /**
     *
     * @summary チャンネルをスターします
     * @param {PostStarRequest} [postStarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    addMyStar(postStarRequest, options) {
        return exports.StarApiFp(this.configuration).addMyStar(postStarRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary スターチャンネルリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    getMyStars(options) {
        return exports.StarApiFp(this.configuration).getMyStars(options)(this.axios, this.basePath);
    }
    /**
     * 既にスターから削除されているチャンネルを指定した場合は204を返します。
     * @summary チャンネルをスターから削除します
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    removeMyStar(channelId, options) {
        return exports.StarApiFp(this.configuration).removeMyStar(channelId, options)(this.axios, this.basePath);
    }
}
exports.StarApi = StarApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
exports.UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したユーザーに指定したタグを追加します。
         * @summary ユーザーにタグを追加
         * @param {string} userId ユーザーUUID
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userId, postUserTagRequest, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling addUserTag.');
            }
            const localVarPath = `/users/{userId}/tags`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postUserTagRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserTagRequest !== undefined ? postUserTagRequest : {}) : (postUserTagRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
         * @summary ユーザーのアイコン画像を変更します
         * @param {string} userId ユーザーUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserIcon(userId, file, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling changeUserIcon.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling changeUserIcon.');
            }
            const localVarPath = `/users/{userId}/icon`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
         * @summary ユーザーのパスワードを変更
         * @param {string} userId ユーザーUUID
         * @param {PutUserPasswordRequest} [putUserPasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword(userId, putUserPasswordRequest, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling changeUserPassword.');
            }
            const localVarPath = `/users/{userId}/password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putUserPasswordRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putUserPasswordRequest !== undefined ? putUserPasswordRequest : {}) : (putUserPasswordRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーを登録します。 管理者権限が必要です。
         * @summary ユーザーを登録
         * @param {PostUserRequest} [postUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(postUserRequest, options = {}) {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postUserRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserRequest !== undefined ? postUserRequest : {}) : (postUserRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーの情報を変更します。 管理者権限が必要です。
         * @summary ユーザー情報を変更
         * @param {string} userId ユーザーUUID
         * @param {PatchUserRequest} [patchUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(userId, patchUserRequest, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling editUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchUserRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserRequest !== undefined ? patchUserRequest : {}) : (patchUserRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary ユーザーのタグを編集します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserTag(userId, tagId, patchUserTagRequest, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling editUserTag.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling editUserTag.');
            }
            const localVarPath = `/users/{userId}/tags/{tagId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchUserTagRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserTagRequest !== undefined ? patchUserTagRequest : {}) : (patchUserTagRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーとのダイレクトメッセージのリストを取得します。
         * @summary ダイレクトメッセージのリストを取得
         * @param {string} userId ユーザーUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userId, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getDirectMessages.');
            }
            const localVarPath = `/users/{userId}/messages`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーの詳細情報を取得します。
         * @summary ユーザー詳細情報を取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @summary ユーザーのアイコン画像を取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getUserIcon.');
            }
            const localVarPath = `/users/{userId}/icon`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーのタグリストを取得します。
         * @summary ユーザーのタグリストを取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getUserTags.');
            }
            const localVarPath = `/users/{userId}/tags`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーのリストを取得します。
         * @summary ユーザーのリストを取得
         * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(includeSuspended, options = {}) {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includeSuspended !== undefined) {
                localVarQueryParameter['include-suspended'] = includeSuspended;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーにダイレクトメッセージを送信します。
         * @summary ダイレクトメッセージを送信
         * @param {string} userId ユーザーUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userId, postMessageRequest, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling postDirectMessage.');
            }
            const localVarPath = `/users/{userId}/messages`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postMessageRequest !== undefined ? postMessageRequest : {}) : (postMessageRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary ユーザーからタグを削除します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserTag(userId, tagId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling removeUserTag.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling removeUserTag.');
            }
            const localVarPath = `/users/{userId}/tags/{tagId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
exports.UserApiFp = function (configuration) {
    return {
        /**
         * 指定したユーザーに指定したタグを追加します。
         * @summary ユーザーにタグを追加
         * @param {string} userId ユーザーUUID
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userId, postUserTagRequest, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).addUserTag(userId, postUserTagRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
         * @summary ユーザーのアイコン画像を変更します
         * @param {string} userId ユーザーUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserIcon(userId, file, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).changeUserIcon(userId, file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
         * @summary ユーザーのパスワードを変更
         * @param {string} userId ユーザーUUID
         * @param {PutUserPasswordRequest} [putUserPasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword(userId, putUserPasswordRequest, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).changeUserPassword(userId, putUserPasswordRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーを登録します。 管理者権限が必要です。
         * @summary ユーザーを登録
         * @param {PostUserRequest} [postUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(postUserRequest, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).createUser(postUserRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーの情報を変更します。 管理者権限が必要です。
         * @summary ユーザー情報を変更
         * @param {string} userId ユーザーUUID
         * @param {PatchUserRequest} [patchUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(userId, patchUserRequest, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).editUser(userId, patchUserRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary ユーザーのタグを編集します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserTag(userId, tagId, patchUserTagRequest, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).editUserTag(userId, tagId, patchUserTagRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーとのダイレクトメッセージのリストを取得します。
         * @summary ダイレクトメッセージのリストを取得
         * @param {string} userId ユーザーUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userId, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getDirectMessages(userId, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーの詳細情報を取得します。
         * @summary ユーザー詳細情報を取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getUser(userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @summary ユーザーのアイコン画像を取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userId, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getUserIcon(userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーのタグリストを取得します。
         * @summary ユーザーのタグリストを取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userId, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getUserTags(userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーのリストを取得します。
         * @summary ユーザーのリストを取得
         * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(includeSuspended, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getUsers(includeSuspended, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーにダイレクトメッセージを送信します。
         * @summary ダイレクトメッセージを送信
         * @param {string} userId ユーザーUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userId, postMessageRequest, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).postDirectMessage(userId, postMessageRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary ユーザーからタグを削除します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserTag(userId, tagId, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).removeUserTag(userId, tagId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
exports.UserApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したユーザーに指定したタグを追加します。
         * @summary ユーザーにタグを追加
         * @param {string} userId ユーザーUUID
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userId, postUserTagRequest, options) {
            return exports.UserApiFp(configuration).addUserTag(userId, postUserTagRequest, options)(axios, basePath);
        },
        /**
         * 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
         * @summary ユーザーのアイコン画像を変更します
         * @param {string} userId ユーザーUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserIcon(userId, file, options) {
            return exports.UserApiFp(configuration).changeUserIcon(userId, file, options)(axios, basePath);
        },
        /**
         * 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
         * @summary ユーザーのパスワードを変更
         * @param {string} userId ユーザーUUID
         * @param {PutUserPasswordRequest} [putUserPasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword(userId, putUserPasswordRequest, options) {
            return exports.UserApiFp(configuration).changeUserPassword(userId, putUserPasswordRequest, options)(axios, basePath);
        },
        /**
         * ユーザーを登録します。 管理者権限が必要です。
         * @summary ユーザーを登録
         * @param {PostUserRequest} [postUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(postUserRequest, options) {
            return exports.UserApiFp(configuration).createUser(postUserRequest, options)(axios, basePath);
        },
        /**
         * 指定したユーザーの情報を変更します。 管理者権限が必要です。
         * @summary ユーザー情報を変更
         * @param {string} userId ユーザーUUID
         * @param {PatchUserRequest} [patchUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(userId, patchUserRequest, options) {
            return exports.UserApiFp(configuration).editUser(userId, patchUserRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary ユーザーのタグを編集します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserTag(userId, tagId, patchUserTagRequest, options) {
            return exports.UserApiFp(configuration).editUserTag(userId, tagId, patchUserTagRequest, options)(axios, basePath);
        },
        /**
         * 指定したユーザーとのダイレクトメッセージのリストを取得します。
         * @summary ダイレクトメッセージのリストを取得
         * @param {string} userId ユーザーUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userId, limit, offset, since, until, inclusive, order, options) {
            return exports.UserApiFp(configuration).getDirectMessages(userId, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * 指定したユーザーの詳細情報を取得します。
         * @summary ユーザー詳細情報を取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId, options) {
            return exports.UserApiFp(configuration).getUser(userId, options)(axios, basePath);
        },
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @summary ユーザーのアイコン画像を取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userId, options) {
            return exports.UserApiFp(configuration).getUserIcon(userId, options)(axios, basePath);
        },
        /**
         * 指定したユーザーのタグリストを取得します。
         * @summary ユーザーのタグリストを取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userId, options) {
            return exports.UserApiFp(configuration).getUserTags(userId, options)(axios, basePath);
        },
        /**
         * ユーザーのリストを取得します。
         * @summary ユーザーのリストを取得
         * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(includeSuspended, options) {
            return exports.UserApiFp(configuration).getUsers(includeSuspended, options)(axios, basePath);
        },
        /**
         * 指定したユーザーにダイレクトメッセージを送信します。
         * @summary ダイレクトメッセージを送信
         * @param {string} userId ユーザーUUID
         * @param {PostMessageRequest} [postMessageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userId, postMessageRequest, options) {
            return exports.UserApiFp(configuration).postDirectMessage(userId, postMessageRequest, options)(axios, basePath);
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary ユーザーからタグを削除します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserTag(userId, tagId, options) {
            return exports.UserApiFp(configuration).removeUserTag(userId, tagId, options)(axios, basePath);
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * 指定したユーザーに指定したタグを追加します。
     * @summary ユーザーにタグを追加
     * @param {string} userId ユーザーUUID
     * @param {PostUserTagRequest} [postUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addUserTag(userId, postUserTagRequest, options) {
        return exports.UserApiFp(this.configuration).addUserTag(userId, postUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
     * @summary ユーザーのアイコン画像を変更します
     * @param {string} userId ユーザーUUID
     * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeUserIcon(userId, file, options) {
        return exports.UserApiFp(this.configuration).changeUserIcon(userId, file, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
     * @summary ユーザーのパスワードを変更
     * @param {string} userId ユーザーUUID
     * @param {PutUserPasswordRequest} [putUserPasswordRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeUserPassword(userId, putUserPasswordRequest, options) {
        return exports.UserApiFp(this.configuration).changeUserPassword(userId, putUserPasswordRequest, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーを登録します。 管理者権限が必要です。
     * @summary ユーザーを登録
     * @param {PostUserRequest} [postUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(postUserRequest, options) {
        return exports.UserApiFp(this.configuration).createUser(postUserRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーの情報を変更します。 管理者権限が必要です。
     * @summary ユーザー情報を変更
     * @param {string} userId ユーザーUUID
     * @param {PatchUserRequest} [patchUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    editUser(userId, patchUserRequest, options) {
        return exports.UserApiFp(this.configuration).editUser(userId, patchUserRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary ユーザーのタグを編集します
     * @param {string} userId ユーザーUUID
     * @param {string} tagId タグUUID
     * @param {PatchUserTagRequest} [patchUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    editUserTag(userId, tagId, patchUserTagRequest, options) {
        return exports.UserApiFp(this.configuration).editUserTag(userId, tagId, patchUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーとのダイレクトメッセージのリストを取得します。
     * @summary ダイレクトメッセージのリストを取得
     * @param {string} userId ユーザーUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getDirectMessages(userId, limit, offset, since, until, inclusive, order, options) {
        return exports.UserApiFp(this.configuration).getDirectMessages(userId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーの詳細情報を取得します。
     * @summary ユーザー詳細情報を取得
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(userId, options) {
        return exports.UserApiFp(this.configuration).getUser(userId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのアイコン画像を取得します。
     * @summary ユーザーのアイコン画像を取得
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserIcon(userId, options) {
        return exports.UserApiFp(this.configuration).getUserIcon(userId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのタグリストを取得します。
     * @summary ユーザーのタグリストを取得
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserTags(userId, options) {
        return exports.UserApiFp(this.configuration).getUserTags(userId, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのリストを取得します。
     * @summary ユーザーのリストを取得
     * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsers(includeSuspended, options) {
        return exports.UserApiFp(this.configuration).getUsers(includeSuspended, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーにダイレクトメッセージを送信します。
     * @summary ダイレクトメッセージを送信
     * @param {string} userId ユーザーUUID
     * @param {PostMessageRequest} [postMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    postDirectMessage(userId, postMessageRequest, options) {
        return exports.UserApiFp(this.configuration).postDirectMessage(userId, postMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * 既に存在しないタグを削除しようとした場合は204を返します。
     * @summary ユーザーからタグを削除します
     * @param {string} userId ユーザーUUID
     * @param {string} tagId タグUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    removeUserTag(userId, tagId, options) {
        return exports.UserApiFp(this.configuration).removeUserTag(userId, tagId, options)(this.axios, this.basePath);
    }
}
exports.UserApi = UserApi;
/**
 * UserTagApi - axios parameter creator
 * @export
 */
exports.UserTagApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary 自分にタグを追加します
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyUserTag(postUserTagRequest, options = {}) {
            const localVarPath = `/users/me/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postUserTagRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserTagRequest !== undefined ? postUserTagRequest : {}) : (postUserTagRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーに指定したタグを追加します。
         * @summary ユーザーにタグを追加
         * @param {string} userId ユーザーUUID
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userId, postUserTagRequest, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling addUserTag.');
            }
            const localVarPath = `/users/{userId}/tags`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postUserTagRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserTagRequest !== undefined ? postUserTagRequest : {}) : (postUserTagRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 自分のタグを編集します
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMyUserTag(tagId, patchUserTagRequest, options = {}) {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling editMyUserTag.');
            }
            const localVarPath = `/users/me/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchUserTagRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserTagRequest !== undefined ? patchUserTagRequest : {}) : (patchUserTagRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary ユーザーのタグを編集します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserTag(userId, tagId, patchUserTagRequest, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling editUserTag.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling editUserTag.');
            }
            const localVarPath = `/users/{userId}/tags/{tagId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchUserTagRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserTagRequest !== undefined ? patchUserTagRequest : {}) : (patchUserTagRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary 自分のタグリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserTags(options = {}) {
            const localVarPath = `/users/me/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したタグの情報を取得します。
         * @summary タグ情報を取得
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagId, options = {}) {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling getTag.');
            }
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーのタグリストを取得します。
         * @summary ユーザーのタグリストを取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getUserTags.');
            }
            const localVarPath = `/users/{userId}/tags`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary 自分からタグを削除します
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyUserTag(tagId, options = {}) {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling removeMyUserTag.');
            }
            const localVarPath = `/users/me/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary ユーザーからタグを削除します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserTag(userId, tagId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling removeUserTag.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling removeUserTag.');
            }
            const localVarPath = `/users/{userId}/tags/{tagId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserTagApi - functional programming interface
 * @export
 */
exports.UserTagApiFp = function (configuration) {
    return {
        /**
         *
         * @summary 自分にタグを追加します
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyUserTag(postUserTagRequest, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).addMyUserTag(postUserTagRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーに指定したタグを追加します。
         * @summary ユーザーにタグを追加
         * @param {string} userId ユーザーUUID
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userId, postUserTagRequest, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).addUserTag(userId, postUserTagRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 自分のタグを編集します
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMyUserTag(tagId, patchUserTagRequest, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).editMyUserTag(tagId, patchUserTagRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary ユーザーのタグを編集します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserTag(userId, tagId, patchUserTagRequest, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).editUserTag(userId, tagId, patchUserTagRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary 自分のタグリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserTags(options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).getMyUserTags(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したタグの情報を取得します。
         * @summary タグ情報を取得
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagId, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).getTag(tagId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したユーザーのタグリストを取得します。
         * @summary ユーザーのタグリストを取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userId, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).getUserTags(userId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary 自分からタグを削除します
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyUserTag(tagId, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).removeMyUserTag(tagId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary ユーザーからタグを削除します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserTag(userId, tagId, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).removeUserTag(userId, tagId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserTagApi - factory interface
 * @export
 */
exports.UserTagApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary 自分にタグを追加します
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMyUserTag(postUserTagRequest, options) {
            return exports.UserTagApiFp(configuration).addMyUserTag(postUserTagRequest, options)(axios, basePath);
        },
        /**
         * 指定したユーザーに指定したタグを追加します。
         * @summary ユーザーにタグを追加
         * @param {string} userId ユーザーUUID
         * @param {PostUserTagRequest} [postUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userId, postUserTagRequest, options) {
            return exports.UserTagApiFp(configuration).addUserTag(userId, postUserTagRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary 自分のタグを編集します
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMyUserTag(tagId, patchUserTagRequest, options) {
            return exports.UserTagApiFp(configuration).editMyUserTag(tagId, patchUserTagRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary ユーザーのタグを編集します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {PatchUserTagRequest} [patchUserTagRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserTag(userId, tagId, patchUserTagRequest, options) {
            return exports.UserTagApiFp(configuration).editUserTag(userId, tagId, patchUserTagRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary 自分のタグリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserTags(options) {
            return exports.UserTagApiFp(configuration).getMyUserTags(options)(axios, basePath);
        },
        /**
         * 指定したタグの情報を取得します。
         * @summary タグ情報を取得
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagId, options) {
            return exports.UserTagApiFp(configuration).getTag(tagId, options)(axios, basePath);
        },
        /**
         * 指定したユーザーのタグリストを取得します。
         * @summary ユーザーのタグリストを取得
         * @param {string} userId ユーザーUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userId, options) {
            return exports.UserTagApiFp(configuration).getUserTags(userId, options)(axios, basePath);
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary 自分からタグを削除します
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMyUserTag(tagId, options) {
            return exports.UserTagApiFp(configuration).removeMyUserTag(tagId, options)(axios, basePath);
        },
        /**
         * 既に存在しないタグを削除しようとした場合は204を返します。
         * @summary ユーザーからタグを削除します
         * @param {string} userId ユーザーUUID
         * @param {string} tagId タグUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserTag(userId, tagId, options) {
            return exports.UserTagApiFp(configuration).removeUserTag(userId, tagId, options)(axios, basePath);
        },
    };
};
/**
 * UserTagApi - object-oriented interface
 * @export
 * @class UserTagApi
 * @extends {BaseAPI}
 */
class UserTagApi extends base_1.BaseAPI {
    /**
     *
     * @summary 自分にタグを追加します
     * @param {PostUserTagRequest} [postUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    addMyUserTag(postUserTagRequest, options) {
        return exports.UserTagApiFp(this.configuration).addMyUserTag(postUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーに指定したタグを追加します。
     * @summary ユーザーにタグを追加
     * @param {string} userId ユーザーUUID
     * @param {PostUserTagRequest} [postUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    addUserTag(userId, postUserTagRequest, options) {
        return exports.UserTagApiFp(this.configuration).addUserTag(userId, postUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分のタグを編集します
     * @param {string} tagId タグUUID
     * @param {PatchUserTagRequest} [patchUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    editMyUserTag(tagId, patchUserTagRequest, options) {
        return exports.UserTagApiFp(this.configuration).editMyUserTag(tagId, patchUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary ユーザーのタグを編集します
     * @param {string} userId ユーザーUUID
     * @param {string} tagId タグUUID
     * @param {PatchUserTagRequest} [patchUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    editUserTag(userId, tagId, patchUserTagRequest, options) {
        return exports.UserTagApiFp(this.configuration).editUserTag(userId, tagId, patchUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分のタグリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getMyUserTags(options) {
        return exports.UserTagApiFp(this.configuration).getMyUserTags(options)(this.axios, this.basePath);
    }
    /**
     * 指定したタグの情報を取得します。
     * @summary タグ情報を取得
     * @param {string} tagId タグUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getTag(tagId, options) {
        return exports.UserTagApiFp(this.configuration).getTag(tagId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのタグリストを取得します。
     * @summary ユーザーのタグリストを取得
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getUserTags(userId, options) {
        return exports.UserTagApiFp(this.configuration).getUserTags(userId, options)(this.axios, this.basePath);
    }
    /**
     * 既に存在しないタグを削除しようとした場合は204を返します。
     * @summary 自分からタグを削除します
     * @param {string} tagId タグUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    removeMyUserTag(tagId, options) {
        return exports.UserTagApiFp(this.configuration).removeMyUserTag(tagId, options)(this.axios, this.basePath);
    }
    /**
     * 既に存在しないタグを削除しようとした場合は204を返します。
     * @summary ユーザーからタグを削除します
     * @param {string} userId ユーザーUUID
     * @param {string} tagId タグUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    removeUserTag(userId, tagId, options) {
        return exports.UserTagApiFp(this.configuration).removeUserTag(userId, tagId, options)(this.axios, this.basePath);
    }
}
exports.UserTagApi = UserTagApi;
/**
 * WebhookApi - axios parameter creator
 * @export
 */
exports.WebhookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Webhookのアイコンを変更します
         * @param {string} webhookId WebhookUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookId, file, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new base_1.RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling changeWebhookIcon.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling changeWebhookIcon.');
            }
            const localVarPath = `/webhooks/{webhookId}/icon`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Webhookを作成します
         * @param {PostWebhookRequest} [postWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(postWebhookRequest, options = {}) {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postWebhookRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postWebhookRequest !== undefined ? postWebhookRequest : {}) : (postWebhookRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Webhookを削除します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new base_1.RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Webhook情報を変更します
         * @param {string} webhookId WebhookUUID
         * @param {PatchWebhookRequest} [patchWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookId, patchWebhookRequest, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new base_1.RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling editWebhook.');
            }
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchWebhookRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchWebhookRequest !== undefined ? patchWebhookRequest : {}) : (patchWebhookRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Webhook情報を取得します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new base_1.RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling getWebhook.');
            }
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Webhookのアイコンを取得します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookId, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new base_1.RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling getWebhookIcon.');
            }
            const localVarPath = `/webhooks/{webhookId}/icon`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Webhookが投稿したメッセージのリストを取得します
         * @param {string} webhookId WebhookUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new base_1.RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling getWebhookMessages.');
            }
            const localVarPath = `/webhooks/{webhookId}/messages`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
         * @summary Webhook情報のリストを取得します
         * @param {boolean} [all] 全てのWebhookを取得します。権限が必要です。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(all, options = {}) {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Webhookを送信します
         * @param {string} webhookId WebhookUUID
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ(Secretが設定されている場合は必須)
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new base_1.RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling postWebhook.');
            }
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xTRAQSignature !== undefined && xTRAQSignature !== null) {
                localVarHeaderParameter['X-TRAQ-Signature'] = String(xTRAQSignature);
            }
            if (xTRAQChannelId !== undefined && xTRAQChannelId !== null) {
                localVarHeaderParameter['X-TRAQ-Channel-Id'] = String(xTRAQChannelId);
            }
            if (embed !== undefined && embed !== null) {
                localVarHeaderParameter['embed'] = String(JSON.stringify(embed));
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WebhookApi - functional programming interface
 * @export
 */
exports.WebhookApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Webhookのアイコンを変更します
         * @param {string} webhookId WebhookUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookId, file, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).changeWebhookIcon(webhookId, file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Webhookを作成します
         * @param {PostWebhookRequest} [postWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(postWebhookRequest, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).createWebhook(postWebhookRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Webhookを削除します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).deleteWebhook(webhookId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Webhook情報を変更します
         * @param {string} webhookId WebhookUUID
         * @param {PatchWebhookRequest} [patchWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookId, patchWebhookRequest, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).editWebhook(webhookId, patchWebhookRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Webhook情報を取得します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).getWebhook(webhookId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Webhookのアイコンを取得します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookId, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).getWebhookIcon(webhookId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Webhookが投稿したメッセージのリストを取得します
         * @param {string} webhookId WebhookUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
         * @summary Webhook情報のリストを取得します
         * @param {boolean} [all] 全てのWebhookを取得します。権限が必要です。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(all, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).getWebhooks(all, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Webhookを送信します
         * @param {string} webhookId WebhookUUID
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ(Secretが設定されている場合は必須)
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * WebhookApi - factory interface
 * @export
 */
exports.WebhookApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Webhookのアイコンを変更します
         * @param {string} webhookId WebhookUUID
         * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookId, file, options) {
            return exports.WebhookApiFp(configuration).changeWebhookIcon(webhookId, file, options)(axios, basePath);
        },
        /**
         *
         * @summary Webhookを作成します
         * @param {PostWebhookRequest} [postWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(postWebhookRequest, options) {
            return exports.WebhookApiFp(configuration).createWebhook(postWebhookRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary Webhookを削除します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return exports.WebhookApiFp(configuration).deleteWebhook(webhookId, options)(axios, basePath);
        },
        /**
         *
         * @summary Webhook情報を変更します
         * @param {string} webhookId WebhookUUID
         * @param {PatchWebhookRequest} [patchWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookId, patchWebhookRequest, options) {
            return exports.WebhookApiFp(configuration).editWebhook(webhookId, patchWebhookRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary Webhook情報を取得します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId, options) {
            return exports.WebhookApiFp(configuration).getWebhook(webhookId, options)(axios, basePath);
        },
        /**
         *
         * @summary Webhookのアイコンを取得します
         * @param {string} webhookId WebhookUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookId, options) {
            return exports.WebhookApiFp(configuration).getWebhookIcon(webhookId, options)(axios, basePath);
        },
        /**
         *
         * @summary Webhookが投稿したメッセージのリストを取得します
         * @param {string} webhookId WebhookUUID
         * @param {number} [limit] 取得する件数
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options) {
            return exports.WebhookApiFp(configuration).getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
         * @summary Webhook情報のリストを取得します
         * @param {boolean} [all] 全てのWebhookを取得します。権限が必要です。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(all, options) {
            return exports.WebhookApiFp(configuration).getWebhooks(all, options)(axios, basePath);
        },
        /**
         *
         * @summary Webhookを送信します
         * @param {string} webhookId WebhookUUID
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ(Secretが設定されている場合は必須)
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options) {
            return exports.WebhookApiFp(configuration).postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options)(axios, basePath);
        },
    };
};
/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
class WebhookApi extends base_1.BaseAPI {
    /**
     *
     * @summary Webhookのアイコンを変更します
     * @param {string} webhookId WebhookUUID
     * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    changeWebhookIcon(webhookId, file, options) {
        return exports.WebhookApiFp(this.configuration).changeWebhookIcon(webhookId, file, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookを作成します
     * @param {PostWebhookRequest} [postWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    createWebhook(postWebhookRequest, options) {
        return exports.WebhookApiFp(this.configuration).createWebhook(postWebhookRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookを削除します
     * @param {string} webhookId WebhookUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    deleteWebhook(webhookId, options) {
        return exports.WebhookApiFp(this.configuration).deleteWebhook(webhookId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhook情報を変更します
     * @param {string} webhookId WebhookUUID
     * @param {PatchWebhookRequest} [patchWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    editWebhook(webhookId, patchWebhookRequest, options) {
        return exports.WebhookApiFp(this.configuration).editWebhook(webhookId, patchWebhookRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhook情報を取得します
     * @param {string} webhookId WebhookUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhook(webhookId, options) {
        return exports.WebhookApiFp(this.configuration).getWebhook(webhookId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookのアイコンを取得します
     * @param {string} webhookId WebhookUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhookIcon(webhookId, options) {
        return exports.WebhookApiFp(this.configuration).getWebhookIcon(webhookId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookが投稿したメッセージのリストを取得します
     * @param {string} webhookId WebhookUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options) {
        return exports.WebhookApiFp(this.configuration).getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
     * @summary Webhook情報のリストを取得します
     * @param {boolean} [all] 全てのWebhookを取得します。権限が必要です。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhooks(all, options) {
        return exports.WebhookApiFp(this.configuration).getWebhooks(all, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookを送信します
     * @param {string} webhookId WebhookUUID
     * @param {string} [xTRAQSignature] リクエストボディシグネチャ(Secretが設定されている場合は必須)
     * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options) {
        return exports.WebhookApiFp(this.configuration).postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options)(this.axios, this.basePath);
    }
}
exports.WebhookApi = WebhookApi;
/**
 * WebrtcApi - axios parameter creator
 * @export
 */
exports.WebrtcApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary WebRTC状態を取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options = {}) {
            const localVarPath = `/webrtc/state`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Skyway用認証API
         * @param {PostWebRTCAuthenticateRequest} [postWebRTCAuthenticateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options = {}) {
            const localVarPath = `/webrtc/authenticate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postWebRTCAuthenticateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postWebRTCAuthenticateRequest !== undefined ? postWebRTCAuthenticateRequest : {}) : (postWebRTCAuthenticateRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WebrtcApi - functional programming interface
 * @export
 */
exports.WebrtcApiFp = function (configuration) {
    return {
        /**
         *
         * @summary WebRTC状態を取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options) {
            const localVarAxiosArgs = exports.WebrtcApiAxiosParamCreator(configuration).getWebRTCState(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Skyway用認証API
         * @param {PostWebRTCAuthenticateRequest} [postWebRTCAuthenticateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options) {
            const localVarAxiosArgs = exports.WebrtcApiAxiosParamCreator(configuration).postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * WebrtcApi - factory interface
 * @export
 */
exports.WebrtcApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary WebRTC状態を取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options) {
            return exports.WebrtcApiFp(configuration).getWebRTCState(options)(axios, basePath);
        },
        /**
         *
         * @summary Skyway用認証API
         * @param {PostWebRTCAuthenticateRequest} [postWebRTCAuthenticateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options) {
            return exports.WebrtcApiFp(configuration).postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options)(axios, basePath);
        },
    };
};
/**
 * WebrtcApi - object-oriented interface
 * @export
 * @class WebrtcApi
 * @extends {BaseAPI}
 */
class WebrtcApi extends base_1.BaseAPI {
    /**
     *
     * @summary WebRTC状態を取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getWebRTCState(options) {
        return exports.WebrtcApiFp(this.configuration).getWebRTCState(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Skyway用認証API
     * @param {PostWebRTCAuthenticateRequest} [postWebRTCAuthenticateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options) {
        return exports.WebrtcApiFp(this.configuration).postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options)(this.axios, this.basePath);
    }
}
exports.WebrtcApi = WebrtcApi;
class Apis extends base_1.BaseAPI {
    /**
     * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
     * @summary アクテビティタイムラインを取得
     * @param {number} [limit] 取得する件数
     * @param {boolean} [subscribeOnly] 購読チャンネルのみを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    getActivityTimeline(limit, subscribeOnly, options) {
        return exports.ActivityApiFp(this.configuration).getActivityTimeline(limit, subscribeOnly, options)(this.axios, this.basePath);
    }
    /**
     * 現在オンラインな(SSEまたはWSが接続中)ユーザーのUUIDのリストを返します。
     * @summary オンラインユーザーリストを取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    getOnlineUsers(options) {
        return exports.ActivityApiFp(this.configuration).getOnlineUsers(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分のログインセッションリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMySessions(options) {
        return exports.MeApiFp(this.configuration).getMySessions(options)(this.axios, this.basePath);
    }
    /**
     * ログインします。
     * @summary ログイン
     * @param {string} [redirect] リダイレクト先
     * @param {PostLoginRequest} [postLoginRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    login(redirect, postLoginRequest, options) {
        return exports.AuthenticationApiFp(this.configuration).login(redirect, postLoginRequest, options)(this.axios, this.basePath);
    }
    /**
     * ログアウトします。
     * @summary ログアウト
     * @param {string} [redirect] リダイレクト先
     * @param {boolean} [all] 全てのセッションでログアウトするかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logout(redirect, all, options) {
        return exports.AuthenticationApiFp(this.configuration).logout(redirect, all, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary セッションを無効化します
     * @param {string} sessionId セッションUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    revokeMySession(sessionId, options) {
        return exports.MeApiFp(this.configuration).revokeMySession(sessionId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを有効化します。 対象のBOTの管理権限が必要です。
     * @summary BOTをアクティベート
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    activateBot(botId, options) {
        return exports.BotApiFp(this.configuration).activateBot(botId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTのアイコン画像を変更を変更します。 対象のBOTの管理権限が必要です。
     * @summary BOTのアイコン画像を変更
     * @param {string} botId BOTUUID
     * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotIcon(botId, file, options) {
        return exports.BotApiFp(this.configuration).changeBotIcon(botId, file, options)(this.axios, this.basePath);
    }
    /**
     * BOTを作成します。 作成後にアクティベーション・購読イベントの設定を行う必要があります。
     * @summary BOTを作成
     * @param {PostBotRequest} [postBotRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    createBot(postBotRequest, options) {
        return exports.BotApiFp(this.configuration).createBot(postBotRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを削除します。 対象のBOTの管理権限が必要です。
     * @summary BOTを削除
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    deleteBot(botId, options) {
        return exports.BotApiFp(this.configuration).deleteBot(botId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTの情報を変更します。 対象のBOTの管理権限が必要です。 BOT開発者UUIDを変更した場合は、変更先ユーザーにBOT管理権限が移譲され、自分自身は権限を失います。
     * @summary BOT情報を変更
     * @param {string} botId BOTUUID
     * @param {PatchBotRequest} [patchBotRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    editBot(botId, patchBotRequest, options) {
        return exports.BotApiFp(this.configuration).editBot(botId, patchBotRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTのBOT情報を取得します。 BOT詳細情報を取得する場合は、対象のBOTの管理権限が必要です。
     * @summary BOT情報を取得
     * @param {string} botId BOTUUID
     * @param {boolean} [detail] 詳細情報を含めるかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBot(botId, detail, options) {
        return exports.BotApiFp(this.configuration).getBot(botId, detail, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTのアイコン画像を取得を取得します。
     * @summary BOTのアイコン画像を取得
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotIcon(botId, options) {
        return exports.BotApiFp(this.configuration).getBotIcon(botId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTのイベントログを取得します。 対象のBOTの管理権限が必要です。
     * @summary BOTのイベントログを取得
     * @param {string} botId BOTUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotLogs(botId, limit, offset, options) {
        return exports.BotApiFp(this.configuration).getBotLogs(botId, limit, offset, options)(this.axios, this.basePath);
    }
    /**
     * BOT情報のリストを取得します。
     * @summary BOTリストを取得
     * @param {boolean} [all] 全てのBOTを取得するかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBots(all, options) {
        return exports.BotApiFp(this.configuration).getBots(all, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルに参加しているBOTのリストを取得します。
     * @summary チャンネル参加中のBOTのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelBots(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelBots(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを無効化します。対象のBOTの管理権限が必要です。
     * @summary BOTをインアクティベート
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    inactivateBot(botId, options) {
        return exports.BotApiFp(this.configuration).inactivateBot(botId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを指定したチャンネルに参加させます。 チャンネルに参加したBOTは、そのチャンネルの各種イベントを受け取るようになります。 対象のBOTの管理権限が必要です。
     * @summary BOTをチャンネルに参加させる
     * @param {string} botId BOTUUID
     * @param {PostBotActionJoinRequest} [postBotActionJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    letBotJoinChannel(botId, postBotActionJoinRequest, options) {
        return exports.BotApiFp(this.configuration).letBotJoinChannel(botId, postBotActionJoinRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTを指定したチャンネルから退出させます。 対象のBOTの管理権限が必要です。
     * @summary BOTをチャンネルから退出させる
     * @param {string} botId BOTUUID
     * @param {PostBotActionLeaveRequest} [postBotActionLeaveRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    letBotLeaveChannel(botId, postBotActionLeaveRequest, options) {
        return exports.BotApiFp(this.configuration).letBotLeaveChannel(botId, postBotActionLeaveRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBOTの現在の各種トークンを無効化し、再発行を行います。 対象のBOTの管理権限が必要です。
     * @summary BOTのトークンを再発行
     * @param {string} botId BOTUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    reissueBot(botId, options) {
        return exports.BotApiFp(this.configuration).reissueBot(botId, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを作成します。 階層が6以上になるチャンネルは作成できません。
     * @summary チャンネルを作成
     * @param {PostChannelRequest} [postChannelRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannel(postChannelRequest, options) {
        return exports.ChannelApiFp(this.configuration).createChannel(postChannelRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの情報を変更します。 変更には権限が必要です。
     * @summary チャンネル情報を変更
     * @param {string} channelId チャンネルUUID
     * @param {PatchChannelRequest} [patchChannelRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannel(channelId, patchChannelRequest, options) {
        return exports.ChannelApiFp(this.configuration).editChannel(channelId, patchChannelRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
     * @summary チャンネルの通知購読者を編集
     * @param {string} channelId チャンネルUUID
     * @param {PatchChannelSubscribersRequest} [patchChannelSubscribersRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    editChannelSubscribers(channelId, patchChannelSubscribersRequest, options) {
        return exports.NotificationApiFp(this.configuration).editChannelSubscribers(channelId, patchChannelSubscribersRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのトピックを編集します。
     * @summary チャンネルトピックを編集
     * @param {string} channelId チャンネルUUID
     * @param {PutChannelTopicRequest} [putChannelTopicRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannelTopic(channelId, putChannelTopicRequest, options) {
        return exports.ChannelApiFp(this.configuration).editChannelTopic(channelId, putChannelTopicRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの情報を取得します。
     * @summary チャンネル情報を取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannel(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannel(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのイベントリストを取得します。
     * @summary チャンネルイベントのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options) {
        return exports.ChannelApiFp(this.configuration).getChannelEvents(channelId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。
     * @summary チャンネルピンのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getChannelPins(channelId, options) {
        return exports.PinApiFp(this.configuration).getChannelPins(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの統計情報を取得します。
     * @summary チャンネル統計情報を取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelStats(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelStats(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
     * @summary チャンネルの通知購読者のリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getChannelSubscribers(channelId, options) {
        return exports.NotificationApiFp(this.configuration).getChannelSubscribers(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのトピックを取得します。
     * @summary チャンネルトピックを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelTopic(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelTopic(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの閲覧者のリストを取得します。
     * @summary チャンネル閲覧者リストを取得
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelViewers(channelId, options) {
        return exports.ChannelApiFp(this.configuration).getChannelViewers(channelId, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのリストを取得します。
     * @summary チャンネルリストを取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannels(options) {
        return exports.ChannelApiFp(this.configuration).getChannels(options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのメッセージのリストを取得します。
     * @summary チャンネルメッセージのリストを取得
     * @param {string} channelId チャンネルUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessages(channelId, limit, offset, since, until, inclusive, order, options) {
        return exports.MessageApiFp(this.configuration).getMessages(channelId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
     * @summary チャンネルにメッセージを投稿
     * @param {string} channelId チャンネルUUID
     * @param {PostMessageRequest} [postMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postMessage(channelId, postMessageRequest, options) {
        return exports.MessageApiFp(this.configuration).postMessage(channelId, postMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの購読状態はオフになります。
     * @summary チャンネルの通知購読者を設定
     * @param {string} channelId チャンネルUUID
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    setChannelSubscribers(channelId, requestBody, options) {
        return exports.NotificationApiFp(this.configuration).setChannelSubscribers(channelId, requestBody, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを指定したクリップフォルダに追加します。
     * @summary メッセージをクリップフォルダに追加
     * @param {string} folderId クリップフォルダUUID
     * @param {PostClipFolderMessageRequest} [postClipFolderMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    clipMessage(folderId, postClipFolderMessageRequest, options) {
        return exports.ClipApiFp(this.configuration).clipMessage(folderId, postClipFolderMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
     * @summary クリップフォルダを作成
     * @param {PostClipFolderRequest} [postClipFolderRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    createClipFolder(postClipFolderRequest, options) {
        return exports.ClipApiFp(this.configuration).createClipFolder(postClipFolderRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップフォルダを削除します。
     * @summary クリップフォルダを削除
     * @param {string} folderId クリップフォルダUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    deleteClipFolder(folderId, options) {
        return exports.ClipApiFp(this.configuration).deleteClipFolder(folderId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップフォルダの情報を編集します。
     * @summary クリップフォルダ情報を編集
     * @param {string} folderId クリップフォルダUUID
     * @param {PatchClipFolderRequest} [patchClipFolderRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    editClipFolder(folderId, patchClipFolderRequest, options) {
        return exports.ClipApiFp(this.configuration).editClipFolder(folderId, patchClipFolderRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップフォルダの情報を取得します。
     * @summary クリップフォルダ情報を取得
     * @param {string} folderId クリップフォルダUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    getClipFolder(folderId, options) {
        return exports.ClipApiFp(this.configuration).getClipFolder(folderId, options)(this.axios, this.basePath);
    }
    /**
     * 自身が所有するクリップフォルダのリストを取得します。
     * @summary クリップフォルダのリストを取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    getClipFolders(options) {
        return exports.ClipApiFp(this.configuration).getClipFolders(options)(this.axios, this.basePath);
    }
    /**
     * 指定したフォルダ内のクリップのリストを取得します。
     * @summary フォルダ内のクリップのリストを取得
     * @param {string} folderId クリップフォルダUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    getClips(folderId, limit, offset, options) {
        return exports.ClipApiFp(this.configuration).getClips(folderId, limit, offset, options)(this.axios, this.basePath);
    }
    /**
     * 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
     * @summary メッセージをクリップフォルダから除外
     * @param {string} folderId クリップフォルダUUID
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    unclipMessage(folderId, messageId, options) {
        return exports.ClipApiFp(this.configuration).unclipMessage(folderId, messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルを削除します。 指定したファイルの削除権限が必要です。
     * @summary ファイルを削除
     * @param {string} fileId ファイルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    deleteFile(fileId, options) {
        return exports.FileApiFp(this.configuration).deleteFile(fileId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイル本体を取得します。 指定したファイルへのアクセス権限が必要です。
     * @summary ファイルをダウンロード
     * @param {string} fileId ファイルUUID
     * @param {number} [dl] 1を指定するとレスポンスにContent-Dispositionヘッダーが付与されます
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFile(fileId, dl, options) {
        return exports.FileApiFp(this.configuration).getFile(fileId, dl, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのメタ情報を取得します。 指定したファイルへのアクセス権限が必要です。
     * @summary ファイルメタを取得
     * @param {string} fileId ファイルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileMeta(fileId, options) {
        return exports.FileApiFp(this.configuration).getFileMeta(fileId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクエリでファイルメタのリストを取得します。
     * @summary ファイルメタのリストを取得
     * @param {string} channelId アップロード先チャンネルUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {string} [mime] MIMEタイプ
     * @param {string} [uploaderId] アップロード者UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options) {
        return exports.FileApiFp(this.configuration).getFiles(channelId, limit, offset, since, until, inclusive, order, mime, uploaderId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのサムネイル画像を取得します。 指定したファイルへのアクセス権限が必要です。
     * @summary サムネイル画像を取得
     * @param {string} fileId ファイルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getThumbnailImage(fileId, options) {
        return exports.FileApiFp(this.configuration).getThumbnailImage(fileId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルにファイルをアップロードします。
     * @summary ファイルをアップロード
     * @param {any} file ファイル本体
     * @param {string} channelId アップロード先チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    postFile(file, channelId, options) {
        return exports.FileApiFp(this.configuration).postFile(file, channelId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したグループにメンバーを追加します。 対象のユーザーグループの管理者権限が必要です。
     * @summary グループメンバーを追加
     * @param {string} groupId ユーザーグループUUID
     * @param {UserGroupMember} [userGroupMember]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    addUserGroupMember(groupId, userGroupMember, options) {
        return exports.GroupApiFp(this.configuration).addUserGroupMember(groupId, userGroupMember, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを作成します。 作成者は自動的にメンバーに追加され、グループ管理者になります。
     * @summary ユーザーグループを作成
     * @param {PostUserGroupRequest} [postUserGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    createUserGroup(postUserGroupRequest, options) {
        return exports.GroupApiFp(this.configuration).createUserGroup(postUserGroupRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループを削除します。 対象のユーザーグループの管理者権限が必要です。
     * @summary ユーザーグループを削除
     * @param {string} groupId ユーザーグループUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    deleteUserGroup(groupId, options) {
        return exports.GroupApiFp(this.configuration).deleteUserGroup(groupId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループの情報を編集します。 対象のユーザーグループの管理者権限が必要です。
     * @summary ユーザーグループを編集
     * @param {string} groupId ユーザーグループUUID
     * @param {PatchUserGroupRequest} [patchUserGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    editUserGroup(groupId, patchUserGroupRequest, options) {
        return exports.GroupApiFp(this.configuration).editUserGroup(groupId, patchUserGroupRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループ内の指定したユーザーの属性を編集します。 対象のユーザーグループの管理者権限が必要です。
     * @summary ユーザーグループメンバーを編集
     * @param {string} groupId ユーザーグループUUID
     * @param {string} userId ユーザーUUID
     * @param {PatchGroupMemberRequest} [patchGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    editUserGroupMember(groupId, userId, patchGroupMemberRequest, options) {
        return exports.GroupApiFp(this.configuration).editUserGroupMember(groupId, userId, patchGroupMemberRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループの情報を取得します。
     * @summary ユーザーグループを取得
     * @param {string} groupId ユーザーグループUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    getUserGroup(groupId, options) {
        return exports.GroupApiFp(this.configuration).getUserGroup(groupId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したグループのメンバーのリストを取得します。
     * @summary グループメンバーを取得
     * @param {string} groupId ユーザーグループUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    getUserGroupMembers(groupId, options) {
        return exports.GroupApiFp(this.configuration).getUserGroupMembers(groupId, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループのリストを取得します。
     * @summary ユーザーグループのリストを取得
     * @param {string} [type] グループタイプ
     * @param {boolean} [admin] 自分が管理者のグループのみを取得するかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    getUserGroups(type, admin, options) {
        return exports.GroupApiFp(this.configuration).getUserGroups(type, admin, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーグループから指定したユーザーを削除します。 対象のユーザーグループの管理者権限が必要です。
     * @summary ユーザーグループから削除
     * @param {string} groupId ユーザーグループUUID
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    removeUserGroupMember(groupId, userId, options) {
        return exports.GroupApiFp(this.configuration).removeUserGroupMember(groupId, userId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したグループのメンバーをリクエストのメンバーに置き換えます。 リクエスト内に含まれないメンバーはグループから削除されます。 対象のユーザーグループの管理者権限が必要です。
     * @summary グループメンバーを設定
     * @param {string} groupId ユーザーグループUUID
     * @param {Array<UserGroupMember>} [userGroupMember]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    setUserGroupMembers(groupId, userGroupMember, options) {
        return exports.GroupApiFp(this.configuration).setUserGroupMembers(groupId, userGroupMember, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary チャンネルをスターします
     * @param {PostStarRequest} [postStarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    addMyStar(postStarRequest, options) {
        return exports.StarApiFp(this.configuration).addMyStar(postStarRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分にタグを追加します
     * @param {PostUserTagRequest} [postUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    addMyUserTag(postUserTagRequest, options) {
        return exports.UserTagApiFp(this.configuration).addMyUserTag(postUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を変更します。
     * @summary 自分のアイコン画像を変更
     * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    changeMyIcon(file, options) {
        return exports.MeApiFp(this.configuration).changeMyIcon(file, options)(this.axios, this.basePath);
    }
    /**
     * 自身のパスワードを変更します。
     * @summary 自分のパスワードを変更
     * @param {PutMyPasswordRequest} [putMyPasswordRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    changeMyPassword(putMyPasswordRequest, options) {
        return exports.MeApiFp(this.configuration).changeMyPassword(putMyPasswordRequest, options)(this.axios, this.basePath);
    }
    /**
     * 自身のユーザー情報を変更します。
     * @summary 自分のユーザー情報を変更
     * @param {PatchMeRequest} [patchMeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    editMe(patchMeRequest, options) {
        return exports.MeApiFp(this.configuration).editMe(patchMeRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分のタグを編集します
     * @param {string} tagId タグUUID
     * @param {PatchUserTagRequest} [patchUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    editMyUserTag(tagId, patchUserTagRequest, options) {
        return exports.UserTagApiFp(this.configuration).editMyUserTag(tagId, patchUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 自身のユーザー詳細情報を取得します。
     * @summary 自分のユーザー詳細を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMe(options) {
        return exports.MeApiFp(this.configuration).getMe(options)(this.axios, this.basePath);
    }
    /**
     * 自身のチャンネル購読状態を取得します。
     * @summary 自分のチャンネル購読状態を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getMyChannelSubscriptions(options) {
        return exports.NotificationApiFp(this.configuration).getMyChannelSubscriptions(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を取得します。
     * @summary 自分のアイコン画像を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyIcon(options) {
        return exports.MeApiFp(this.configuration).getMyIcon(options)(this.axios, this.basePath);
    }
    /**
     * 自身のQRコードを取得します。 返されたQRコードまたはトークンは、発行後の5分間のみ有効です
     * @summary QRコードを取得
     * @param {boolean} [token] 画像でなくトークン文字列で返すかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    getMyQRCode(token, options) {
        return exports.MeApiFp(this.configuration).getMyQRCode(token, options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
     * @summary スタンプ履歴を取得
     * @param {number} [limit] 件数
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getMyStampHistory(limit, options) {
        return exports.StampApiFp(this.configuration).getMyStampHistory(limit, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary スターチャンネルリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    getMyStars(options) {
        return exports.StarApiFp(this.configuration).getMyStars(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 有効なOAuth2トークンのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    getMyTokens(options) {
        return exports.Oauth2ApiFp(this.configuration).getMyTokens(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 未読チャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getMyUnreadChannels(options) {
        return exports.NotificationApiFp(this.configuration).getMyUnreadChannels(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary 自分のタグリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getMyUserTags(options) {
        return exports.UserTagApiFp(this.configuration).getMyUserTags(options)(this.axios, this.basePath);
    }
    /**
     * 既読にするチャンネルUUIDが指定されてない場合は、全てのチャンネルを既読にします。
     * @summary 未読チャンネルを既読にします
     * @param {string} [channelId] 既読にするチャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    readChannels(channelId, options) {
        return exports.NotificationApiFp(this.configuration).readChannels(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 自身のFCMデバイスを登録します。
     * @summary FCMデバイスを登録
     * @param {PostMyFCMDeviceRequest} [postMyFCMDeviceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    registerFCMDevice(postMyFCMDeviceRequest, options) {
        return exports.NotificationApiFp(this.configuration).registerFCMDevice(postMyFCMDeviceRequest, options)(this.axios, this.basePath);
    }
    /**
     * 既にスターから削除されているチャンネルを指定した場合は204を返します。
     * @summary チャンネルをスターから削除します
     * @param {string} channelId チャンネルUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    removeMyStar(channelId, options) {
        return exports.StarApiFp(this.configuration).removeMyStar(channelId, options)(this.axios, this.basePath);
    }
    /**
     * 既に存在しないタグを削除しようとした場合は204を返します。
     * @summary 自分からタグを削除します
     * @param {string} tagId タグUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    removeMyUserTag(tagId, options) {
        return exports.UserTagApiFp(this.configuration).removeMyUserTag(tagId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary トークンの認可を取り消します
     * @param {string} tokenId OAuth2トークンUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    revokeMyToken(tokenId, options) {
        return exports.Oauth2ApiFp(this.configuration).revokeMyToken(tokenId, options)(this.axios, this.basePath);
    }
    /**
     * 自身の指定したチャンネルの購読レベルを設定します。
     * @summary チャンネル購読レベルを設定
     * @param {string} channelId チャンネルUUID
     * @param {PutChannelSubscribeLevelRequest} [putChannelSubscribeLevelRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options) {
        return exports.NotificationApiFp(this.configuration).setChannelSubscribeLevel(channelId, putChannelSubscribeLevelRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @summary スタンプを押す
     * @param {string} messageId メッセージUUID
     * @param {string} stampId スタンプUUID
     * @param {PostMessageStampRequest} [postMessageStampRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    addMessageStamp(messageId, stampId, postMessageStampRequest, options) {
        return exports.StampApiFp(this.configuration).addMessageStamp(messageId, stampId, postMessageStampRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージをピン留めします。
     * @summary ピン留めする
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    createPin(messageId, options) {
        return exports.PinApiFp(this.configuration).createPin(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
     * @summary メッセージを削除
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    deleteMessage(messageId, options) {
        return exports.MessageApiFp(this.configuration).deleteMessage(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを編集します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ編集することができます。
     * @summary メッセージを編集
     * @param {string} messageId メッセージUUID
     * @param {PostMessageRequest} [postMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    editMessage(messageId, postMessageRequest, options) {
        return exports.MessageApiFp(this.configuration).editMessage(messageId, postMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーとのダイレクトメッセージのリストを取得します。
     * @summary ダイレクトメッセージのリストを取得
     * @param {string} userId ユーザーUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getDirectMessages(userId, limit, offset, since, until, inclusive, order, options) {
        return exports.UserApiFp(this.configuration).getDirectMessages(userId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを取得します。
     * @summary メッセージを取得
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessage(messageId, options) {
        return exports.MessageApiFp(this.configuration).getMessage(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに押されているスタンプのリストを取得します。
     * @summary メッセージのスタンプリストを取得
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getMessageStamps(messageId, options) {
        return exports.StampApiFp(this.configuration).getMessageStamps(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージのピン留め情報を取得します。
     * @summary ピン留めを取得
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPin(messageId, options) {
        return exports.PinApiFp(this.configuration).getPin(messageId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーにダイレクトメッセージを送信します。
     * @summary ダイレクトメッセージを送信
     * @param {string} userId ユーザーUUID
     * @param {PostMessageRequest} [postMessageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    postDirectMessage(userId, postMessageRequest, options) {
        return exports.UserApiFp(this.configuration).postDirectMessage(userId, postMessageRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定した自身が押したスタンプを削除します。
     * @summary スタンプを消す
     * @param {string} messageId メッセージUUID
     * @param {string} stampId スタンプUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    removeMessageStamp(messageId, stampId, options) {
        return exports.StampApiFp(this.configuration).removeMessageStamp(messageId, stampId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージのピン留めを外します。
     * @summary ピン留めを外す
     * @param {string} messageId メッセージUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    removePin(messageId, options) {
        return exports.PinApiFp(this.configuration).removePin(messageId, options)(this.axios, this.basePath);
    }
    /**
     * # WebSocketプロトコル ## 送信 `コマンド:引数1:引数2:...`のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### `viewstate`コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  `viewstate:(チャンネルID):(閲覧状態)` + チャンネルID: 対象のチャンネルID + 閲覧状態: `none`, `monitoring`, `editing`  最初の`viewstate`コマンドを送る前、または`viewstate:null`を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ## 受信 SSEのイベントと同じものがTextMessageとして非同期に送られてくる。 `type`と`body`を持つJSONを受信。`type`はSSEのイベントタイプと同じ、`body`はSSEのデータと同じ。 例:  ```json {\"type\":\"USER_ONLINE\",\"body\":{\"id\":\"7dd8e07f-7f5d-4331-9176-b56a4299768b\"}} ```
     * @summary WebSocket通知ストリームに接続します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    ws(options) {
        return exports.NotificationApiFp(this.configuration).ws(options)(this.axios, this.basePath);
    }
    /**
     * OAuth2クライアントを作成します。
     * @summary OAuth2クライアントを作成
     * @param {PostClientRequest} [postClientRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    createClient(postClientRequest, options) {
        return exports.Oauth2ApiFp(this.configuration).createClient(postClientRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
     * @summary OAuth2クライアントを削除
     * @param {string} clientId OAuth2クライアントUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    deleteClient(clientId, options) {
        return exports.Oauth2ApiFp(this.configuration).deleteClient(clientId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
     * @summary OAuth2クライアント情報を変更
     * @param {string} clientId OAuth2クライアントUUID
     * @param {PatchClientRequest} [patchClientRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    editClient(clientId, patchClientRequest, options) {
        return exports.Oauth2ApiFp(this.configuration).editClient(clientId, patchClientRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
     * @summary OAuth2クライアント情報を取得
     * @param {string} clientId OAuth2クライアントUUID
     * @param {boolean} [detail] 詳細情報を含めるかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    getClient(clientId, detail, options) {
        return exports.Oauth2ApiFp(this.configuration).getClient(clientId, detail, options)(this.axios, this.basePath);
    }
    /**
     * 自身が開発者のOAuth2クライアントのリストを取得します。 全てのクライアントを取得する場合は、権限が必要です。
     * @summary OAuth2クライアントのリストを取得
     * @param {boolean} [all] 全てのクライアントを取得するかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    getClients(all, options) {
        return exports.Oauth2ApiFp(this.configuration).getClients(all, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのアイコン画像を取得します。
     * @summary ユーザーのアイコン画像を取得
     * @param {string} username ユーザー名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getPublicUserIcon(username, options) {
        return exports.PublicApiFp(this.configuration).getPublicUserIcon(username, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary バージョンを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getServerVersion(options) {
        return exports.PublicApiFp(this.configuration).getServerVersion(options)(this.axios, this.basePath);
    }
    /**
     * スタンプを新規作成します。
     * @summary スタンプを作成
     * @param {string} name スタンプ名
     * @param {any} file スタンプ画像(1MBまでのpng, jpeg, gif, svg)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    createStamp(name, file, options) {
        return exports.StampApiFp(this.configuration).createStamp(name, file, options)(this.axios, this.basePath);
    }
    /**
     * スタンプパレットを作成します。
     * @summary スタンプパレットを作成
     * @param {PostStampPaletteRequest} [postStampPaletteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    createStampPalette(postStampPaletteRequest, options) {
        return exports.StampApiFp(this.configuration).createStampPalette(postStampPaletteRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
     * @summary スタンプを削除
     * @param {string} stampId スタンプUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    deleteStamp(stampId, options) {
        return exports.StampApiFp(this.configuration).deleteStamp(stampId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
     * @summary スタンプパレットを削除
     * @param {string} paletteId スタンプパレットUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    deleteStampPalette(paletteId, options) {
        return exports.StampApiFp(this.configuration).deleteStampPalette(paletteId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプパレットの情報を変更します。 対象のスタンプパレットの管理権限が必要です。
     * @summary スタンプパレット情報を変更
     * @param {string} paletteId スタンプパレットUUID
     * @param {PatchStampPaletteRequest} [patchStampPaletteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    editStampPalette(paletteId, patchStampPaletteRequest, options) {
        return exports.StampApiFp(this.configuration).editStampPalette(paletteId, patchStampPaletteRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプパレットのスタンプを編集します。 対象のスタンプパレットの管理権限が必要です。
     * @summary パレット内のスタンプを編集
     * @param {string} paletteId スタンプパレットUUID
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    editStampPaletteStamps(paletteId, requestBody, options) {
        return exports.StampApiFp(this.configuration).editStampPaletteStamps(paletteId, requestBody, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプの情報を取得します。
     * @summary スタンプ情報を取得
     * @param {string} stampId スタンプUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamp(stampId, options) {
        return exports.StampApiFp(this.configuration).getStamp(stampId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したスタンプパレットの情報を取得します。
     * @summary スタンプパレットを取得
     * @param {string} paletteId スタンプパレットUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStampPalette(paletteId, options) {
        return exports.StampApiFp(this.configuration).getStampPalette(paletteId, options)(this.axios, this.basePath);
    }
    /**
     * 自身が所有しているスタンプパレットのリストを取得します。
     * @summary スタンプパレットのリストを取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStampPalettes(options) {
        return exports.StampApiFp(this.configuration).getStampPalettes(options)(this.axios, this.basePath);
    }
    /**
     * スタンプのリストを取得します。
     * @summary スタンプリストを取得
     * @param {boolean} [includeUnicode] Unicode絵文字を含ませるかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamps(includeUnicode, options) {
        return exports.StampApiFp(this.configuration).getStamps(includeUnicode, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーに指定したタグを追加します。
     * @summary ユーザーにタグを追加
     * @param {string} userId ユーザーUUID
     * @param {PostUserTagRequest} [postUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    addUserTag(userId, postUserTagRequest, options) {
        return exports.UserTagApiFp(this.configuration).addUserTag(userId, postUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
     * @summary ユーザーのアイコン画像を変更します
     * @param {string} userId ユーザーUUID
     * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeUserIcon(userId, file, options) {
        return exports.UserApiFp(this.configuration).changeUserIcon(userId, file, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
     * @summary ユーザーのパスワードを変更
     * @param {string} userId ユーザーUUID
     * @param {PutUserPasswordRequest} [putUserPasswordRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeUserPassword(userId, putUserPasswordRequest, options) {
        return exports.UserApiFp(this.configuration).changeUserPassword(userId, putUserPasswordRequest, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーを登録します。 管理者権限が必要です。
     * @summary ユーザーを登録
     * @param {PostUserRequest} [postUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(postUserRequest, options) {
        return exports.UserApiFp(this.configuration).createUser(postUserRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーの情報を変更します。 管理者権限が必要です。
     * @summary ユーザー情報を変更
     * @param {string} userId ユーザーUUID
     * @param {PatchUserRequest} [patchUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    editUser(userId, patchUserRequest, options) {
        return exports.UserApiFp(this.configuration).editUser(userId, patchUserRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary ユーザーのタグを編集します
     * @param {string} userId ユーザーUUID
     * @param {string} tagId タグUUID
     * @param {PatchUserTagRequest} [patchUserTagRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    editUserTag(userId, tagId, patchUserTagRequest, options) {
        return exports.UserTagApiFp(this.configuration).editUserTag(userId, tagId, patchUserTagRequest, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーの詳細情報を取得します。
     * @summary ユーザー詳細情報を取得
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(userId, options) {
        return exports.UserApiFp(this.configuration).getUser(userId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのアイコン画像を取得します。
     * @summary ユーザーのアイコン画像を取得
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserIcon(userId, options) {
        return exports.UserApiFp(this.configuration).getUserIcon(userId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのタグリストを取得します。
     * @summary ユーザーのタグリストを取得
     * @param {string} userId ユーザーUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getUserTags(userId, options) {
        return exports.UserTagApiFp(this.configuration).getUserTags(userId, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのリストを取得します。
     * @summary ユーザーのリストを取得
     * @param {boolean} [includeSuspended] アカウントがアクティブでないユーザーを含めるかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsers(includeSuspended, options) {
        return exports.UserApiFp(this.configuration).getUsers(includeSuspended, options)(this.axios, this.basePath);
    }
    /**
     * 既に存在しないタグを削除しようとした場合は204を返します。
     * @summary ユーザーからタグを削除します
     * @param {string} userId ユーザーUUID
     * @param {string} tagId タグUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    removeUserTag(userId, tagId, options) {
        return exports.UserTagApiFp(this.configuration).removeUserTag(userId, tagId, options)(this.axios, this.basePath);
    }
    /**
     * 指定したタグの情報を取得します。
     * @summary タグ情報を取得
     * @param {string} tagId タグUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getTag(tagId, options) {
        return exports.UserTagApiFp(this.configuration).getTag(tagId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookのアイコンを変更します
     * @param {string} webhookId WebhookUUID
     * @param {any} file アイコン画像(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    changeWebhookIcon(webhookId, file, options) {
        return exports.WebhookApiFp(this.configuration).changeWebhookIcon(webhookId, file, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookを作成します
     * @param {PostWebhookRequest} [postWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    createWebhook(postWebhookRequest, options) {
        return exports.WebhookApiFp(this.configuration).createWebhook(postWebhookRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookを削除します
     * @param {string} webhookId WebhookUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    deleteWebhook(webhookId, options) {
        return exports.WebhookApiFp(this.configuration).deleteWebhook(webhookId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhook情報を変更します
     * @param {string} webhookId WebhookUUID
     * @param {PatchWebhookRequest} [patchWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    editWebhook(webhookId, patchWebhookRequest, options) {
        return exports.WebhookApiFp(this.configuration).editWebhook(webhookId, patchWebhookRequest, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhook情報を取得します
     * @param {string} webhookId WebhookUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhook(webhookId, options) {
        return exports.WebhookApiFp(this.configuration).getWebhook(webhookId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookのアイコンを取得します
     * @param {string} webhookId WebhookUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhookIcon(webhookId, options) {
        return exports.WebhookApiFp(this.configuration).getWebhookIcon(webhookId, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookが投稿したメッセージのリストを取得します
     * @param {string} webhookId WebhookUUID
     * @param {number} [limit] 取得する件数
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options) {
        return exports.WebhookApiFp(this.configuration).getWebhookMessages(webhookId, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
     * @summary Webhook情報のリストを取得します
     * @param {boolean} [all] 全てのWebhookを取得します。権限が必要です。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhooks(all, options) {
        return exports.WebhookApiFp(this.configuration).getWebhooks(all, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Webhookを送信します
     * @param {string} webhookId WebhookUUID
     * @param {string} [xTRAQSignature] リクエストボディシグネチャ(Secretが設定されている場合は必須)
     * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options) {
        return exports.WebhookApiFp(this.configuration).postWebhook(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary WebRTC状態を取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getWebRTCState(options) {
        return exports.WebrtcApiFp(this.configuration).getWebRTCState(options)(this.axios, this.basePath);
    }
    /**
     *
     * @summary Skyway用認証API
     * @param {PostWebRTCAuthenticateRequest} [postWebRTCAuthenticateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options) {
        return exports.WebrtcApiFp(this.configuration).postWebRTCAuthenticate(postWebRTCAuthenticateRequest, options)(this.axios, this.basePath);
    }
}
exports.Apis = Apis;
