"use strict";
// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * traQ API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.6.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const globalImportUrl = require("url");
const axios_1 = require("axios");
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var ChannelEventTypeEnum;
(function (ChannelEventTypeEnum) {
    ChannelEventTypeEnum["TopicChanged"] = "TopicChanged";
    ChannelEventTypeEnum["SubscribersChanged"] = "SubscribersChanged";
    ChannelEventTypeEnum["PinAdded"] = "PinAdded";
    ChannelEventTypeEnum["PinRemoved"] = "PinRemoved";
    ChannelEventTypeEnum["NameChanged"] = "NameChanged";
    ChannelEventTypeEnum["ParentChanged"] = "ParentChanged";
    ChannelEventTypeEnum["VisibilityChanged"] = "VisibilityChanged";
    ChannelEventTypeEnum["ForcedNotificationChanged"] = "ForcedNotificationChanged";
    ChannelEventTypeEnum["ChildCreated"] = "ChildCreated";
})(ChannelEventTypeEnum = exports.ChannelEventTypeEnum || (exports.ChannelEventTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ChannelViewerStateEnum;
(function (ChannelViewerStateEnum) {
    ChannelViewerStateEnum["None"] = "none";
    ChannelViewerStateEnum["Monitoring"] = "monitoring";
    ChannelViewerStateEnum["Editing"] = "editing";
})(ChannelViewerStateEnum = exports.ChannelViewerStateEnum || (exports.ChannelViewerStateEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var ClientScope;
(function (ClientScope) {
    ClientScope["Read"] = "read";
    ClientScope["Write"] = "write";
    ClientScope["ManageBot"] = "manage_bot";
})(ClientScope = exports.ClientScope || (exports.ClientScope = {}));
/**
 * editing,monitoring,noneのユーザーの状態
 * @export
 * @enum {string}
 */
var HeartbeatStatus;
(function (HeartbeatStatus) {
    HeartbeatStatus["None"] = "none";
    HeartbeatStatus["Monitoring"] = "monitoring";
    HeartbeatStatus["Editing"] = "editing";
})(HeartbeatStatus = exports.HeartbeatStatus || (exports.HeartbeatStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
var OAuth2Prompt;
(function (OAuth2Prompt) {
    OAuth2Prompt["None"] = "none";
})(OAuth2Prompt = exports.OAuth2Prompt || (exports.OAuth2Prompt = {}));
/**
 *
 * @export
 * @enum {string}
 */
var OAuth2ResponseType;
(function (OAuth2ResponseType) {
    OAuth2ResponseType["Code"] = "code";
    OAuth2ResponseType["Token"] = "token";
    OAuth2ResponseType["None"] = "none";
})(OAuth2ResponseType = exports.OAuth2ResponseType || (exports.OAuth2ResponseType = {}));
/**
 * アカウントの状態 (0:停止,1:有効,2:一時停止)
 * @export
 * @enum {string}
 */
var UserStatus;
(function (UserStatus) {
    UserStatus[UserStatus["NUMBER_0"] = 0] = "NUMBER_0";
    UserStatus[UserStatus["NUMBER_1"] = 1] = "NUMBER_1";
    UserStatus[UserStatus["NUMBER_2"] = 2] = "NUMBER_2";
})(UserStatus = exports.UserStatus || (exports.UserStatus = {}));
/**
 * ActivityApi - axios parameter creator
 * @export
 */
exports.ActivityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(limit, subscribe, options = {}) {
            const localVarPath = `/activity/latest-messages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (subscribe !== undefined) {
                localVarQueryParameter['subscribe'] = subscribe;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivityApi - functional programming interface
 * @export
 */
exports.ActivityApiFp = function (configuration) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(limit, subscribe, options) {
            const localVarAxiosArgs = exports.ActivityApiAxiosParamCreator(configuration).getActivities(limit, subscribe, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ActivityApi - factory interface
 * @export
 */
exports.ActivityApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(limit, subscribe, options) {
            return exports.ActivityApiFp(configuration).getActivities(limit, subscribe, options)(axios, basePath);
        },
    };
};
/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
class ActivityApi extends base_1.BaseAPI {
    /**
     * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
     * @param {number} [limit] 取得する件数 1-50
     * @param {boolean} [subscribe] 購読チャンネルのみを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    getActivities(limit, subscribe, options) {
        return exports.ActivityApiFp(this.configuration).getActivities(limit, subscribe, options)(this.axios, this.basePath);
    }
}
exports.ActivityApi = ActivityApi;
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
exports.AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {UserLogin} userLogin
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(userLogin, redirect, options = {}) {
            // verify required parameter 'userLogin' is not null or undefined
            if (userLogin === null || userLogin === undefined) {
                throw new base_1.RequiredError('userLogin', 'Required parameter userLogin was null or undefined when calling login.');
            }
            const localVarPath = `/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("UserLogin" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userLogin !== undefined ? userLogin : {}) : (userLogin || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, options = {}) {
            const localVarPath = `/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
exports.AuthenticationApiFp = function (configuration) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {UserLogin} userLogin
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(userLogin, redirect, options) {
            const localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).login(userLogin, redirect, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, options) {
            const localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).logout(redirect, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
exports.AuthenticationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {UserLogin} userLogin
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(userLogin, redirect, options) {
            return exports.AuthenticationApiFp(configuration).login(userLogin, redirect, options)(axios, basePath);
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, options) {
            return exports.AuthenticationApiFp(configuration).logout(redirect, options)(axios, basePath);
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
class AuthenticationApi extends base_1.BaseAPI {
    /**
     * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
     * @param {UserLogin} userLogin
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    login(userLogin, redirect, options) {
        return exports.AuthenticationApiFp(this.configuration).login(userLogin, redirect, options)(this.axios, this.basePath);
    }
    /**
     * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logout(redirect, options) {
        return exports.AuthenticationApiFp(this.configuration).logout(redirect, options)(this.axios, this.basePath);
    }
}
exports.AuthenticationApi = AuthenticationApi;
/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
exports.AuthorizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options = {}) {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new base_1.RequiredError('clientId', 'Required parameter clientId was null or undefined when calling getOauth2Authorize.');
            }
            const localVarPath = `/oauth2/authorize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }
            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            if (codeChallenge !== undefined) {
                localVarQueryParameter['code_challenge'] = codeChallenge;
            }
            if (codeChallengeMethod !== undefined) {
                localVarQueryParameter['code_challenge_method'] = codeChallengeMethod;
            }
            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }
            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options = {}) {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new base_1.RequiredError('clientId', 'Required parameter clientId was null or undefined when calling postOauth2Authorize.');
            }
            const localVarPath = `/oauth2/authorize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (responseType !== undefined) {
                localVarFormParams.set('response_type', responseType);
            }
            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId);
            }
            if (redirectUri !== undefined) {
                localVarFormParams.set('redirect_uri', redirectUri);
            }
            if (scope !== undefined) {
                localVarFormParams.set('scope', scope);
            }
            if (state !== undefined) {
                localVarFormParams.set('state', state);
            }
            if (codeChallenge !== undefined) {
                localVarFormParams.set('code_challenge', codeChallenge);
            }
            if (codeChallengeMethod !== undefined) {
                localVarFormParams.set('code_challenge_method', codeChallengeMethod);
            }
            if (nonce !== undefined) {
                localVarFormParams.set('nonce', nonce);
            }
            if (prompt !== undefined) {
                localVarFormParams.set('prompt', prompt);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2AuthorizeDecide(submit, options = {}) {
            // verify required parameter 'submit' is not null or undefined
            if (submit === null || submit === undefined) {
                throw new base_1.RequiredError('submit', 'Required parameter submit was null or undefined when calling postOauth2AuthorizeDecide.');
            }
            const localVarPath = `/oauth2/authorize/decide`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication cookieAuth required
            if (submit !== undefined) {
                localVarFormParams.set('submit', submit);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options = {}) {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new base_1.RequiredError('grantType', 'Required parameter grantType was null or undefined when calling postOauth2Token.');
            }
            const localVarPath = `/oauth2/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType);
            }
            if (code !== undefined) {
                localVarFormParams.set('code', code);
            }
            if (redirectUri !== undefined) {
                localVarFormParams.set('redirect_uri', redirectUri);
            }
            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId);
            }
            if (codeVerifier !== undefined) {
                localVarFormParams.set('code_verifier', codeVerifier);
            }
            if (username !== undefined) {
                localVarFormParams.set('username', username);
            }
            if (password !== undefined) {
                localVarFormParams.set('password', password);
            }
            if (scope !== undefined) {
                localVarFormParams.set('scope', scope);
            }
            if (refreshToken !== undefined) {
                localVarFormParams.set('refresh_token', refreshToken);
            }
            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthorizationApi - functional programming interface
 * @export
 */
exports.AuthorizationApiFp = function (configuration) {
    return {
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            const localVarAxiosArgs = exports.AuthorizationApiAxiosParamCreator(configuration).getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            const localVarAxiosArgs = exports.AuthorizationApiAxiosParamCreator(configuration).postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2AuthorizeDecide(submit, options) {
            const localVarAxiosArgs = exports.AuthorizationApiAxiosParamCreator(configuration).postOauth2AuthorizeDecide(submit, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
            const localVarAxiosArgs = exports.AuthorizationApiAxiosParamCreator(configuration).postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthorizationApi - factory interface
 * @export
 */
exports.AuthorizationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            return exports.AuthorizationApiFp(configuration).getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(axios, basePath);
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            return exports.AuthorizationApiFp(configuration).postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(axios, basePath);
        },
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2AuthorizeDecide(submit, options) {
            return exports.AuthorizationApiFp(configuration).postOauth2AuthorizeDecide(submit, options)(axios, basePath);
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
            return exports.AuthorizationApiFp(configuration).postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(axios, basePath);
        },
    };
};
/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
class AuthorizationApi extends base_1.BaseAPI {
    /**
     * OAuth2 認可エンドポイント
     * @param {string} clientId
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return exports.AuthorizationApiFp(this.configuration).getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {string} clientId
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return exports.AuthorizationApiFp(this.configuration).postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可承諾
     * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2AuthorizeDecide(submit, options) {
        return exports.AuthorizationApiFp(this.configuration).postOauth2AuthorizeDecide(submit, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 トークンエンドポイント
     * @param {string} grantType
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [clientId]
     * @param {string} [codeVerifier]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [scope]
     * @param {string} [refreshToken]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
        return exports.AuthorizationApiFp(this.configuration).postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(this.axios, this.basePath);
    }
}
exports.AuthorizationApi = AuthorizationApi;
/**
 * BotApi - axios parameter creator
 * @export
 */
exports.BotApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} postBotChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannelBot(channelID, postBotChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling addChannelBot.');
            }
            // verify required parameter 'postBotChannel' is not null or undefined
            if (postBotChannel === null || postBotChannel === undefined) {
                throw new base_1.RequiredError('postBotChannel', 'Required parameter postBotChannel was null or undefined when calling addChannelBot.');
            }
            const localVarPath = `/channels/{channelID}/bots`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostBotChannel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBotChannel !== undefined ? postBotChannel : {}) : (postBotChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} putBotEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotEvents(botID, putBotEvents, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling changeBotEvents.');
            }
            // verify required parameter 'putBotEvents' is not null or undefined
            if (putBotEvents === null || putBotEvents === undefined) {
                throw new base_1.RequiredError('putBotEvents', 'Required parameter putBotEvents was null or undefined when calling changeBotEvents.');
            }
            const localVarPath = `/bots/{botID}/events`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PutBotEvents" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putBotEvents !== undefined ? putBotEvents : {}) : (putBotEvents || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botID, file, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling changeBotIcon.');
            }
            const localVarPath = `/bots/{botID}/icon`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} putBotState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotState(botID, putBotState, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling changeBotState.');
            }
            // verify required parameter 'putBotState' is not null or undefined
            if (putBotState === null || putBotState === undefined) {
                throw new base_1.RequiredError('putBotState', 'Required parameter putBotState was null or undefined when calling changeBotState.');
            }
            const localVarPath = `/bots/{botID}/state`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PutBotState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putBotState !== undefined ? putBotState : {}) : (putBotState || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを作成します。
         * @param {PostBot} postBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBots(postBot, options = {}) {
            // verify required parameter 'postBot' is not null or undefined
            if (postBot === null || postBot === undefined) {
                throw new base_1.RequiredError('postBot', 'Required parameter postBot was null or undefined when calling createBots.');
            }
            const localVarPath = `/bots`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostBot" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBot !== undefined ? postBot : {}) : (postBot || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling deleteBot.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} patchBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botID, patchBot, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling editBot.');
            }
            // verify required parameter 'patchBot' is not null or undefined
            if (patchBot === null || patchBot === undefined) {
                throw new base_1.RequiredError('patchBot', 'Required parameter patchBot was null or undefined when calling editBot.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchBot" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchBot !== undefined ? patchBot : {}) : (patchBot || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling getBot.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotChannels(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling getBotChannels.');
            }
            const localVarPath = `/bots/{botID}/channels`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotDetail(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling getBotDetail.');
            }
            const localVarPath = `/bots/{botID}/detail`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling getBotIcon.');
            }
            const localVarPath = `/bots/{botID}/icon`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(options = {}) {
            const localVarPath = `/bots`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelBots.');
            }
            const localVarPath = `/channels/{channelID}/bots`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBotTokens(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling reissueBotTokens.');
            }
            const localVarPath = `/bots/{botID}/reissue`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChannelBot(channelID, botID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling removeChannelBot.');
            }
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new base_1.RequiredError('botID', 'Required parameter botID was null or undefined when calling removeChannelBot.');
            }
            const localVarPath = `/channels/{channelID}/bots/{botID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)))
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BotApi - functional programming interface
 * @export
 */
exports.BotApiFp = function (configuration) {
    return {
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} postBotChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannelBot(channelID, postBotChannel, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).addChannelBot(channelID, postBotChannel, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} putBotEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotEvents(botID, putBotEvents, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).changeBotEvents(botID, putBotEvents, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botID, file, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).changeBotIcon(botID, file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} putBotState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotState(botID, putBotState, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).changeBotState(botID, putBotState, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを作成します。
         * @param {PostBot} postBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBots(postBot, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).createBots(postBot, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botID, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).deleteBot(botID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} patchBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botID, patchBot, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).editBot(botID, patchBot, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botID, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBot(botID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotChannels(botID, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBotChannels(botID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotDetail(botID, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBotDetail(botID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botID, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBotIcon(botID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getBots(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelID, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).getChannelBots(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBotTokens(botID, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).reissueBotTokens(botID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChannelBot(channelID, botID, options) {
            const localVarAxiosArgs = exports.BotApiAxiosParamCreator(configuration).removeChannelBot(channelID, botID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * BotApi - factory interface
 * @export
 */
exports.BotApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} postBotChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannelBot(channelID, postBotChannel, options) {
            return exports.BotApiFp(configuration).addChannelBot(channelID, postBotChannel, options)(axios, basePath);
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} putBotEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotEvents(botID, putBotEvents, options) {
            return exports.BotApiFp(configuration).changeBotEvents(botID, putBotEvents, options)(axios, basePath);
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botID, file, options) {
            return exports.BotApiFp(configuration).changeBotIcon(botID, file, options)(axios, basePath);
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} putBotState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotState(botID, putBotState, options) {
            return exports.BotApiFp(configuration).changeBotState(botID, putBotState, options)(axios, basePath);
        },
        /**
         * Botを作成します。
         * @param {PostBot} postBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBots(postBot, options) {
            return exports.BotApiFp(configuration).createBots(postBot, options)(axios, basePath);
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botID, options) {
            return exports.BotApiFp(configuration).deleteBot(botID, options)(axios, basePath);
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} patchBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botID, patchBot, options) {
            return exports.BotApiFp(configuration).editBot(botID, patchBot, options)(axios, basePath);
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botID, options) {
            return exports.BotApiFp(configuration).getBot(botID, options)(axios, basePath);
        },
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotChannels(botID, options) {
            return exports.BotApiFp(configuration).getBotChannels(botID, options)(axios, basePath);
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotDetail(botID, options) {
            return exports.BotApiFp(configuration).getBotDetail(botID, options)(axios, basePath);
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botID, options) {
            return exports.BotApiFp(configuration).getBotIcon(botID, options)(axios, basePath);
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(options) {
            return exports.BotApiFp(configuration).getBots(options)(axios, basePath);
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelID, options) {
            return exports.BotApiFp(configuration).getChannelBots(channelID, options)(axios, basePath);
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBotTokens(botID, options) {
            return exports.BotApiFp(configuration).reissueBotTokens(botID, options)(axios, basePath);
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChannelBot(channelID, botID, options) {
            return exports.BotApiFp(configuration).removeChannelBot(channelID, botID, options)(axios, basePath);
        },
    };
};
/**
 * BotApi - object-oriented interface
 * @export
 * @class BotApi
 * @extends {BaseAPI}
 */
class BotApi extends base_1.BaseAPI {
    /**
     * チャンネルにBotを参加させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PostBotChannel} postBotChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    addChannelBot(channelID, postBotChannel, options) {
        return exports.BotApiFp(this.configuration).addChannelBot(channelID, postBotChannel, options)(this.axios, this.basePath);
    }
    /**
     * Botの購読イベントを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotEvents} putBotEvents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotEvents(botID, putBotEvents, options) {
        return exports.BotApiFp(this.configuration).changeBotEvents(botID, putBotEvents, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotIcon(botID, file, options) {
        return exports.BotApiFp(this.configuration).changeBotIcon(botID, file, options)(this.axios, this.basePath);
    }
    /**
     * Botの状態を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotState} putBotState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotState(botID, putBotState, options) {
        return exports.BotApiFp(this.configuration).changeBotState(botID, putBotState, options)(this.axios, this.basePath);
    }
    /**
     * Botを作成します。
     * @param {PostBot} postBot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    createBots(postBot, options) {
        return exports.BotApiFp(this.configuration).createBots(postBot, options)(this.axios, this.basePath);
    }
    /**
     * Botを削除します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    deleteBot(botID, options) {
        return exports.BotApiFp(this.configuration).deleteBot(botID, options)(this.axios, this.basePath);
    }
    /**
     * Bot情報を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PatchBot} patchBot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    editBot(botID, patchBot, options) {
        return exports.BotApiFp(this.configuration).editBot(botID, patchBot, options)(this.axios, this.basePath);
    }
    /**
     * Botを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBot(botID, options) {
        return exports.BotApiFp(this.configuration).getBot(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botが参加しているチャンネルのUUIDの配列を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotChannels(botID, options) {
        return exports.BotApiFp(this.configuration).getBotChannels(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの詳細を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotDetail(botID, options) {
        return exports.BotApiFp(this.configuration).getBotDetail(botID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotIcon(botID, options) {
        return exports.BotApiFp(this.configuration).getBotIcon(botID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したBotの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBots(options) {
        return exports.BotApiFp(this.configuration).getBots(options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに参加しているBot一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getChannelBots(channelID, options) {
        return exports.BotApiFp(this.configuration).getChannelBots(channelID, options)(this.axios, this.basePath);
    }
    /**
     * Botの各種トークンを再発行します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    reissueBotTokens(botID, options) {
        return exports.BotApiFp(this.configuration).reissueBotTokens(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botをチャンネルから退出させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    removeChannelBot(channelID, botID, options) {
        return exports.BotApiFp(this.configuration).removeChannelBot(channelID, botID, options)(this.axios, this.basePath);
    }
}
exports.BotApi = BotApi;
/**
 * ChannelApi - axios parameter creator
 * @export
 */
exports.ChannelApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} putParentChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelParent(channelID, putParentChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling changeChannelParent.');
            }
            // verify required parameter 'putParentChannel' is not null or undefined
            if (putParentChannel === null || putParentChannel === undefined) {
                throw new base_1.RequiredError('putParentChannel', 'Required parameter putParentChannel was null or undefined when calling changeChannelParent.');
            }
            const localVarPath = `/channels/{channelID}/parent`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PutParentChannel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putParentChannel !== undefined ? putParentChannel : {}) : (putParentChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} setChannelTopic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelTopic(channelID, setChannelTopic, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling changeChannelTopic.');
            }
            // verify required parameter 'setChannelTopic' is not null or undefined
            if (setChannelTopic === null || setChannelTopic === undefined) {
                throw new base_1.RequiredError('setChannelTopic', 'Required parameter setChannelTopic was null or undefined when calling changeChannelTopic.');
            }
            const localVarPath = `/channels/{channelID}/topic`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SetChannelTopic" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setChannelTopic !== undefined ? setChannelTopic : {}) : (setChannelTopic || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} createChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(createChannel, options = {}) {
            // verify required parameter 'createChannel' is not null or undefined
            if (createChannel === null || createChannel === undefined) {
                throw new base_1.RequiredError('createChannel', 'Required parameter createChannel was null or undefined when calling createChannel.');
            }
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("CreateChannel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createChannel !== undefined ? createChannel : {}) : (createChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} createChannelChild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelChild(channelID, createChannelChild, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling createChannelChild.');
            }
            // verify required parameter 'createChannelChild' is not null or undefined
            if (createChannelChild === null || createChannelChild === undefined) {
                throw new base_1.RequiredError('createChannelChild', 'Required parameter createChannelChild was null or undefined when calling createChannelChild.');
            }
            const localVarPath = `/channels/{channelID}/children`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("CreateChannelChild" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createChannelChild !== undefined ? createChannelChild : {}) : (createChannelChild || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling deleteChannel.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} patchChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelID, patchChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling editChannel.');
            }
            // verify required parameter 'patchChannel' is not null or undefined
            if (patchChannel === null || patchChannel === undefined) {
                throw new base_1.RequiredError('patchChannel', 'Required parameter patchChannel was null or undefined when calling editChannel.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchChannel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchChannel !== undefined ? patchChannel : {}) : (patchChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannel.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelEvents.');
            }
            const localVarPath = `/channels/{channelID}/events`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの統計情報を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelStats.');
            }
            const localVarPath = `/channels/{channelID}/stats`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelTopic.');
            }
            const localVarPath = `/channels/{channelID}/topic`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 現在のチャンネル閲覧者のリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelViewers.');
            }
            const localVarPath = `/channels/{channelID}/viewers`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options = {}) {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChannelApi - functional programming interface
 * @export
 */
exports.ChannelApiFp = function (configuration) {
    return {
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} putParentChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelParent(channelID, putParentChannel, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).changeChannelParent(channelID, putParentChannel, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} setChannelTopic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelTopic(channelID, setChannelTopic, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).changeChannelTopic(channelID, setChannelTopic, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} createChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(createChannel, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).createChannel(createChannel, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} createChannelChild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelChild(channelID, createChannelChild, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).createChannelChild(channelID, createChannelChild, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(channelID, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).deleteChannel(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} patchChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelID, patchChannel, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).editChannel(channelID, patchChannel, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelID, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannel(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの統計情報を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelID, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelStats(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelID, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelTopic(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 現在のチャンネル閲覧者のリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelID, options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannelViewers(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options) {
            const localVarAxiosArgs = exports.ChannelApiAxiosParamCreator(configuration).getChannels(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ChannelApi - factory interface
 * @export
 */
exports.ChannelApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} putParentChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelParent(channelID, putParentChannel, options) {
            return exports.ChannelApiFp(configuration).changeChannelParent(channelID, putParentChannel, options)(axios, basePath);
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} setChannelTopic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelTopic(channelID, setChannelTopic, options) {
            return exports.ChannelApiFp(configuration).changeChannelTopic(channelID, setChannelTopic, options)(axios, basePath);
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} createChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(createChannel, options) {
            return exports.ChannelApiFp(configuration).createChannel(createChannel, options)(axios, basePath);
        },
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} createChannelChild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelChild(channelID, createChannelChild, options) {
            return exports.ChannelApiFp(configuration).createChannelChild(channelID, createChannelChild, options)(axios, basePath);
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(channelID, options) {
            return exports.ChannelApiFp(configuration).deleteChannel(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} patchChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelID, patchChannel, options) {
            return exports.ChannelApiFp(configuration).editChannel(channelID, patchChannel, options)(axios, basePath);
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelID, options) {
            return exports.ChannelApiFp(configuration).getChannel(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options) {
            return exports.ChannelApiFp(configuration).getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * チャンネルの統計情報を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelID, options) {
            return exports.ChannelApiFp(configuration).getChannelStats(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelID, options) {
            return exports.ChannelApiFp(configuration).getChannelTopic(channelID, options)(axios, basePath);
        },
        /**
         * 現在のチャンネル閲覧者のリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelID, options) {
            return exports.ChannelApiFp(configuration).getChannelViewers(channelID, options)(axios, basePath);
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options) {
            return exports.ChannelApiFp(configuration).getChannels(options)(axios, basePath);
        },
    };
};
/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
class ChannelApi extends base_1.BaseAPI {
    /**
     * チャンネルの親チャンネルを変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PutParentChannel} putParentChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    changeChannelParent(channelID, putParentChannel, options) {
        return exports.ChannelApiFp(this.configuration).changeChannelParent(channelID, putParentChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SetChannelTopic} setChannelTopic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    changeChannelTopic(channelID, setChannelTopic, options) {
        return exports.ChannelApiFp(this.configuration).changeChannelTopic(channelID, setChannelTopic, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを作成します。
     * @param {CreateChannel} createChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannel(createChannel, options) {
        return exports.ChannelApiFp(this.configuration).createChannel(createChannel, options)(this.axios, this.basePath);
    }
    /**
     * 子チャンネルを作成します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {CreateChannelChild} createChannelChild
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannelChild(channelID, createChannelChild, options) {
        return exports.ChannelApiFp(this.configuration).createChannelChild(channelID, createChannelChild, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを削除します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    deleteChannel(channelID, options) {
        return exports.ChannelApiFp(this.configuration).deleteChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PatchChannel} patchChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannel(channelID, patchChannel, options) {
        return exports.ChannelApiFp(this.configuration).editChannel(channelID, patchChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannel(channelID, options) {
        return exports.ChannelApiFp(this.configuration).getChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルイベントのリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options) {
        return exports.ChannelApiFp(this.configuration).getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの統計情報を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelStats(channelID, options) {
        return exports.ChannelApiFp(this.configuration).getChannelStats(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelTopic(channelID, options) {
        return exports.ChannelApiFp(this.configuration).getChannelTopic(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 現在のチャンネル閲覧者のリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelViewers(channelID, options) {
        return exports.ChannelApiFp(this.configuration).getChannelViewers(channelID, options)(this.axios, this.basePath);
    }
    /**
     * (すべての)チャンネルのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannels(options) {
        return exports.ChannelApiFp(this.configuration).getChannels(options)(this.axios, this.basePath);
    }
}
exports.ChannelApi = ChannelApi;
/**
 * ClientApi - axios parameter creator
 * @export
 */
exports.ClientApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * クライアントを登録します。
         * @param {PostClient} postClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClient, options = {}) {
            // verify required parameter 'postClient' is not null or undefined
            if (postClient === null || postClient === undefined) {
                throw new base_1.RequiredError('postClient', 'Required parameter postClient was null or undefined when calling createClient.');
            }
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostClient" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postClient !== undefined ? postClient : {}) : (postClient || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new base_1.RequiredError('clientID', 'Required parameter clientID was null or undefined when calling deleteClient.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(oauth2TokenID, options = {}) {
            // verify required parameter 'oauth2TokenID' is not null or undefined
            if (oauth2TokenID === null || oauth2TokenID === undefined) {
                throw new base_1.RequiredError('oauth2TokenID', 'Required parameter oauth2TokenID was null or undefined when calling deleteToken.');
            }
            const localVarPath = `/users/me/tokens/{oauth2TokenID}`
                .replace(`{${"oauth2TokenID"}}`, encodeURIComponent(String(oauth2TokenID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new base_1.RequiredError('clientID', 'Required parameter clientID was null or undefined when calling getClient.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientDetail(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new base_1.RequiredError('clientID', 'Required parameter clientID was null or undefined when calling getClientDetail.');
            }
            const localVarPath = `/clients/{clientID}/detail`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(options = {}) {
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options = {}) {
            const localVarPath = `/users/me/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} patchClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchClient(clientID, patchClient, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new base_1.RequiredError('clientID', 'Required parameter clientID was null or undefined when calling patchClient.');
            }
            // verify required parameter 'patchClient' is not null or undefined
            if (patchClient === null || patchClient === undefined) {
                throw new base_1.RequiredError('patchClient', 'Required parameter patchClient was null or undefined when calling patchClient.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchClient" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchClient !== undefined ? patchClient : {}) : (patchClient || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ClientApi - functional programming interface
 * @export
 */
exports.ClientApiFp = function (configuration) {
    return {
        /**
         * クライアントを登録します。
         * @param {PostClient} postClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClient, options) {
            const localVarAxiosArgs = exports.ClientApiAxiosParamCreator(configuration).createClient(postClient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientID, options) {
            const localVarAxiosArgs = exports.ClientApiAxiosParamCreator(configuration).deleteClient(clientID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(oauth2TokenID, options) {
            const localVarAxiosArgs = exports.ClientApiAxiosParamCreator(configuration).deleteToken(oauth2TokenID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientID, options) {
            const localVarAxiosArgs = exports.ClientApiAxiosParamCreator(configuration).getClient(clientID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientDetail(clientID, options) {
            const localVarAxiosArgs = exports.ClientApiAxiosParamCreator(configuration).getClientDetail(clientID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(options) {
            const localVarAxiosArgs = exports.ClientApiAxiosParamCreator(configuration).getClients(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options) {
            const localVarAxiosArgs = exports.ClientApiAxiosParamCreator(configuration).getTokens(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} patchClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchClient(clientID, patchClient, options) {
            const localVarAxiosArgs = exports.ClientApiAxiosParamCreator(configuration).patchClient(clientID, patchClient, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ClientApi - factory interface
 * @export
 */
exports.ClientApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * クライアントを登録します。
         * @param {PostClient} postClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClient, options) {
            return exports.ClientApiFp(configuration).createClient(postClient, options)(axios, basePath);
        },
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientID, options) {
            return exports.ClientApiFp(configuration).deleteClient(clientID, options)(axios, basePath);
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(oauth2TokenID, options) {
            return exports.ClientApiFp(configuration).deleteToken(oauth2TokenID, options)(axios, basePath);
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientID, options) {
            return exports.ClientApiFp(configuration).getClient(clientID, options)(axios, basePath);
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientDetail(clientID, options) {
            return exports.ClientApiFp(configuration).getClientDetail(clientID, options)(axios, basePath);
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(options) {
            return exports.ClientApiFp(configuration).getClients(options)(axios, basePath);
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options) {
            return exports.ClientApiFp(configuration).getTokens(options)(axios, basePath);
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} patchClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchClient(clientID, patchClient, options) {
            return exports.ClientApiFp(configuration).patchClient(clientID, patchClient, options)(axios, basePath);
        },
    };
};
/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
class ClientApi extends base_1.BaseAPI {
    /**
     * クライアントを登録します。
     * @param {PostClient} postClient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    createClient(postClient, options) {
        return exports.ClientApiFp(this.configuration).createClient(postClient, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    deleteClient(clientID, options) {
        return exports.ClientApiFp(this.configuration).deleteClient(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したトークンの認可を取り消します。
     * @param {string} oauth2TokenID 操作の対象となるTokenのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    deleteToken(oauth2TokenID, options) {
        return exports.ClientApiFp(this.configuration).deleteToken(oauth2TokenID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClient(clientID, options) {
        return exports.ClientApiFp(this.configuration).getClient(clientID, options)(this.axios, this.basePath);
    }
    /**
     * クライアントの詳細を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClientDetail(clientID, options) {
        return exports.ClientApiFp(this.configuration).getClientDetail(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が登録しているクライアントの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClients(options) {
        return exports.ClientApiFp(this.configuration).getClients(options)(this.axios, this.basePath);
    }
    /**
     * 自分が許可しているクライアントの一覧とトークン情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getTokens(options) {
        return exports.ClientApiFp(this.configuration).getTokens(options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を変更します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {PatchClient} patchClient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    patchClient(clientID, patchClient, options) {
        return exports.ClientApiFp(this.configuration).patchClient(clientID, patchClient, options)(this.axios, this.basePath);
    }
}
exports.ClientApi = ClientApi;
/**
 * FileApi - axios parameter creator
 * @export
 */
exports.FileApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new base_1.RequiredError('fileID', 'Required parameter fileID was null or undefined when calling deleteFile.');
            }
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileID, dl, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new base_1.RequiredError('fileID', 'Required parameter fileID was null or undefined when calling getFile.');
            }
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (dl !== undefined) {
                localVarQueryParameter['dl'] = dl;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new base_1.RequiredError('fileID', 'Required parameter fileID was null or undefined when calling getFileMeta.');
            }
            const localVarPath = `/files/{fileID}/meta`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileThumbnail(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new base_1.RequiredError('fileID', 'Required parameter fileID was null or undefined when calling getFileThumbnail.');
            }
            const localVarPath = `/files/{fileID}/thumbnail`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file, aclReadable, options = {}) {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling uploadFile.');
            }
            const localVarPath = `/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (aclReadable !== undefined) {
                localVarFormParams.append('acl_readable', aclReadable);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FileApi - functional programming interface
 * @export
 */
exports.FileApiFp = function (configuration) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileID, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).deleteFile(fileID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileID, dl, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).getFile(fileID, dl, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileID, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).getFileMeta(fileID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileThumbnail(fileID, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).getFileThumbnail(fileID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file, aclReadable, options) {
            const localVarAxiosArgs = exports.FileApiAxiosParamCreator(configuration).uploadFile(file, aclReadable, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * FileApi - factory interface
 * @export
 */
exports.FileApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileID, options) {
            return exports.FileApiFp(configuration).deleteFile(fileID, options)(axios, basePath);
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileID, dl, options) {
            return exports.FileApiFp(configuration).getFile(fileID, dl, options)(axios, basePath);
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileID, options) {
            return exports.FileApiFp(configuration).getFileMeta(fileID, options)(axios, basePath);
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileThumbnail(fileID, options) {
            return exports.FileApiFp(configuration).getFileThumbnail(fileID, options)(axios, basePath);
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file, aclReadable, options) {
            return exports.FileApiFp(configuration).uploadFile(file, aclReadable, options)(axios, basePath);
        },
    };
};
/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
class FileApi extends base_1.BaseAPI {
    /**
     * 指定したファイルを削除します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    deleteFile(fileID, options) {
        return exports.FileApiFp(this.configuration).deleteFile(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルの中身を取得します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFile(fileID, dl, options) {
        return exports.FileApiFp(this.configuration).getFile(fileID, dl, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのメタデータを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileMeta(fileID, options) {
        return exports.FileApiFp(this.configuration).getFileMeta(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのサムネイルを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileThumbnail(fileID, options) {
        return exports.FileApiFp(this.configuration).getFileThumbnail(fileID, options)(this.axios, this.basePath);
    }
    /**
     * ファイルをアップロードします
     * @param {any} file ファイル本体
     * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    uploadFile(file, aclReadable, options) {
        return exports.FileApiFp(this.configuration).uploadFile(file, aclReadable, options)(this.axios, this.basePath);
    }
}
exports.FileApi = FileApi;
/**
 * HeartbeatApi - axios parameter creator
 * @export
 */
exports.HeartbeatApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeartbeat(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getHeartbeat.');
            }
            const localVarPath = `/heartbeat`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} heartbeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postHeartbeat(heartbeat, options = {}) {
            // verify required parameter 'heartbeat' is not null or undefined
            if (heartbeat === null || heartbeat === undefined) {
                throw new base_1.RequiredError('heartbeat', 'Required parameter heartbeat was null or undefined when calling postHeartbeat.');
            }
            const localVarPath = `/heartbeat`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("Heartbeat" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(heartbeat !== undefined ? heartbeat : {}) : (heartbeat || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * HeartbeatApi - functional programming interface
 * @export
 */
exports.HeartbeatApiFp = function (configuration) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeartbeat(channelId, options) {
            const localVarAxiosArgs = exports.HeartbeatApiAxiosParamCreator(configuration).getHeartbeat(channelId, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} heartbeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postHeartbeat(heartbeat, options) {
            const localVarAxiosArgs = exports.HeartbeatApiAxiosParamCreator(configuration).postHeartbeat(heartbeat, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * HeartbeatApi - factory interface
 * @export
 */
exports.HeartbeatApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeartbeat(channelId, options) {
            return exports.HeartbeatApiFp(configuration).getHeartbeat(channelId, options)(axios, basePath);
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} heartbeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postHeartbeat(heartbeat, options) {
            return exports.HeartbeatApiFp(configuration).postHeartbeat(heartbeat, options)(axios, basePath);
        },
    };
};
/**
 * HeartbeatApi - object-oriented interface
 * @export
 * @class HeartbeatApi
 * @extends {BaseAPI}
 */
class HeartbeatApi extends base_1.BaseAPI {
    /**
     * チャンネルを現在見ている人・編集している人を取得します。
     * @param {string} channelId 現在いるチャンネルId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    getHeartbeat(channelId, options) {
        return exports.HeartbeatApiFp(this.configuration).getHeartbeat(channelId, options)(this.axios, this.basePath);
    }
    /**
     * どのチャンネルを見ているか・編集しているかを送信します。
     * @param {Heartbeat} heartbeat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    postHeartbeat(heartbeat, options) {
        return exports.HeartbeatApiFp(this.configuration).postHeartbeat(heartbeat, options)(this.axios, this.basePath);
    }
}
exports.HeartbeatApi = HeartbeatApi;
/**
 * MessageApi - axios parameter creator
 * @export
 */
exports.MessageApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new base_1.RequiredError('messageID', 'Required parameter messageID was null or undefined when calling deleteMessage.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} sendMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageID, sendMessage, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new base_1.RequiredError('messageID', 'Required parameter messageID was null or undefined when calling editMessage.');
            }
            // verify required parameter 'sendMessage' is not null or undefined
            if (sendMessage === null || sendMessage === undefined) {
                throw new base_1.RequiredError('sendMessage', 'Required parameter sendMessage was null or undefined when calling editMessage.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SendMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling getDirectMessages.');
            }
            const localVarPath = `/users/{userID}/messages`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new base_1.RequiredError('messageID', 'Required parameter messageID was null or undefined when calling getMessage.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getMessages.');
            }
            const localVarPath = `/channels/{channelID}/messages`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(p, options = {}) {
            const localVarPath = `/messages/reports`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            if (p !== undefined) {
                localVarQueryParameter['p'] = p;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userID, sendMessage, embed, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling postDirectMessage.');
            }
            // verify required parameter 'sendMessage' is not null or undefined
            if (sendMessage === null || sendMessage === undefined) {
                throw new base_1.RequiredError('sendMessage', 'Required parameter sendMessage was null or undefined when calling postDirectMessage.');
            }
            const localVarPath = `/users/{userID}/messages`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SendMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelID, sendMessage, embed, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling postMessage.');
            }
            // verify required parameter 'sendMessage' is not null or undefined
            if (sendMessage === null || sendMessage === undefined) {
                throw new base_1.RequiredError('sendMessage', 'Required parameter sendMessage was null or undefined when calling postMessage.');
            }
            const localVarPath = `/channels/{channelID}/messages`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SendMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} reportMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMessage(messageID, reportMessage, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new base_1.RequiredError('messageID', 'Required parameter messageID was null or undefined when calling reportMessage.');
            }
            // verify required parameter 'reportMessage' is not null or undefined
            if (reportMessage === null || reportMessage === undefined) {
                throw new base_1.RequiredError('reportMessage', 'Required parameter reportMessage was null or undefined when calling reportMessage.');
            }
            const localVarPath = `/messages/{messageID}/report`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("ReportMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(reportMessage !== undefined ? reportMessage : {}) : (reportMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessageApi - functional programming interface
 * @export
 */
exports.MessageApiFp = function (configuration) {
    return {
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageID, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).deleteMessage(messageID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} sendMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageID, sendMessage, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).editMessage(messageID, sendMessage, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getDirectMessages(userID, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageID, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getMessage(messageID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getMessages(channelID, limit, offset, since, until, inclusive, order, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(p, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).getReports(p, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userID, sendMessage, embed, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).postDirectMessage(userID, sendMessage, embed, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelID, sendMessage, embed, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).postMessage(channelID, sendMessage, embed, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} reportMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMessage(messageID, reportMessage, options) {
            const localVarAxiosArgs = exports.MessageApiAxiosParamCreator(configuration).reportMessage(messageID, reportMessage, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * MessageApi - factory interface
 * @export
 */
exports.MessageApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageID, options) {
            return exports.MessageApiFp(configuration).deleteMessage(messageID, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} sendMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageID, sendMessage, options) {
            return exports.MessageApiFp(configuration).editMessage(messageID, sendMessage, options)(axios, basePath);
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userID, limit, offset, since, until, inclusive, order, options) {
            return exports.MessageApiFp(configuration).getDirectMessages(userID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageID, options) {
            return exports.MessageApiFp(configuration).getMessage(messageID, options)(axios, basePath);
        },
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelID, limit, offset, since, until, inclusive, order, options) {
            return exports.MessageApiFp(configuration).getMessages(channelID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(p, options) {
            return exports.MessageApiFp(configuration).getReports(p, options)(axios, basePath);
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userID, sendMessage, embed, options) {
            return exports.MessageApiFp(configuration).postDirectMessage(userID, sendMessage, embed, options)(axios, basePath);
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelID, sendMessage, embed, options) {
            return exports.MessageApiFp(configuration).postMessage(channelID, sendMessage, embed, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} reportMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMessage(messageID, reportMessage, options) {
            return exports.MessageApiFp(configuration).reportMessage(messageID, reportMessage, options)(axios, basePath);
        },
    };
};
/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
class MessageApi extends base_1.BaseAPI {
    /**
     * 指定したメッセージを削除します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    deleteMessage(messageID, options) {
        return exports.MessageApiFp(this.configuration).deleteMessage(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを編集します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {SendMessage} sendMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    editMessage(messageID, sendMessage, options) {
        return exports.MessageApiFp(this.configuration).editMessage(messageID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルに存在するメッセージを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getDirectMessages(userID, limit, offset, since, until, inclusive, order, options) {
        return exports.MessageApiFp(this.configuration).getDirectMessages(userID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessage(messageID, options) {
        return exports.MessageApiFp(this.configuration).getMessage(messageID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに存在するメッセージを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessages(channelID, limit, offset, since, until, inclusive, order, options) {
        return exports.MessageApiFp(this.configuration).getMessages(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * メッセージ通報を最大50件取得します。
     * @param {number} [p] ページ番号(ゼロオリジン)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getReports(p, options) {
        return exports.MessageApiFp(this.configuration).getReports(p, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルにメッセージを投稿します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SendMessage} sendMessage
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postDirectMessage(userID, sendMessage, embed, options) {
        return exports.MessageApiFp(this.configuration).postDirectMessage(userID, sendMessage, embed, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージを投稿します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SendMessage} sendMessage
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postMessage(channelID, sendMessage, embed, options) {
        return exports.MessageApiFp(this.configuration).postMessage(channelID, sendMessage, embed, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを通報します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {ReportMessage} reportMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    reportMessage(messageID, reportMessage, options) {
        return exports.MessageApiFp(this.configuration).reportMessage(messageID, reportMessage, options)(this.axios, this.basePath);
    }
}
exports.MessageApi = MessageApi;
/**
 * NotificationApi - axios parameter creator
 * @export
 */
exports.NotificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} notificationUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscribers(channelID, notificationUsers, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling changeSubscribers.');
            }
            // verify required parameter 'notificationUsers' is not null or undefined
            if (notificationUsers === null || notificationUsers === undefined) {
                throw new base_1.RequiredError('notificationUsers', 'Required parameter notificationUsers was null or undefined when calling changeSubscribers.');
            }
            const localVarPath = `/channels/{channelID}/notification`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("NotificationUsers" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(notificationUsers !== undefined ? notificationUsers : {}) : (notificationUsers || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectNotification(options = {}) {
            const localVarPath = `/notification`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySubscribeChannels(options = {}) {
            const localVarPath = `/users/me/notification`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribers(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getSubscribers.');
            }
            const localVarPath = `/channels/{channelID}/notification`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscribeChannels(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling getUserSubscribeChannels.');
            }
            const localVarPath = `/users/{userID}/notification`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} fCMToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNotificationDevice(fCMToken, options = {}) {
            // verify required parameter 'fCMToken' is not null or undefined
            if (fCMToken === null || fCMToken === undefined) {
                throw new base_1.RequiredError('fCMToken', 'Required parameter fCMToken was null or undefined when calling registerNotificationDevice.');
            }
            const localVarPath = `/notification/device`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("FCMToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(fCMToken !== undefined ? fCMToken : {}) : (fCMToken || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NotificationApi - functional programming interface
 * @export
 */
exports.NotificationApiFp = function (configuration) {
    return {
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} notificationUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscribers(channelID, notificationUsers, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).changeSubscribers(channelID, notificationUsers, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectNotification(options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).connectNotification(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySubscribeChannels(options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).getMySubscribeChannels(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribers(channelID, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).getSubscribers(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscribeChannels(userID, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).getUserSubscribeChannels(userID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} fCMToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNotificationDevice(fCMToken, options) {
            const localVarAxiosArgs = exports.NotificationApiAxiosParamCreator(configuration).registerNotificationDevice(fCMToken, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * NotificationApi - factory interface
 * @export
 */
exports.NotificationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} notificationUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscribers(channelID, notificationUsers, options) {
            return exports.NotificationApiFp(configuration).changeSubscribers(channelID, notificationUsers, options)(axios, basePath);
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectNotification(options) {
            return exports.NotificationApiFp(configuration).connectNotification(options)(axios, basePath);
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySubscribeChannels(options) {
            return exports.NotificationApiFp(configuration).getMySubscribeChannels(options)(axios, basePath);
        },
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribers(channelID, options) {
            return exports.NotificationApiFp(configuration).getSubscribers(channelID, options)(axios, basePath);
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscribeChannels(userID, options) {
            return exports.NotificationApiFp(configuration).getUserSubscribeChannels(userID, options)(axios, basePath);
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} fCMToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNotificationDevice(fCMToken, options) {
            return exports.NotificationApiFp(configuration).registerNotificationDevice(fCMToken, options)(axios, basePath);
        },
    };
};
/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
class NotificationApi extends base_1.BaseAPI {
    /**
     * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {NotificationUsers} notificationUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    changeSubscribers(channelID, notificationUsers, options) {
        return exports.NotificationApiFp(this.configuration).changeSubscribers(channelID, notificationUsers, options)(this.axios, this.basePath);
    }
    /**
     * 通知ストリーム(Server Sent Events)に接続します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    connectNotification(options) {
        return exports.NotificationApiFp(this.configuration).connectNotification(options)(this.axios, this.basePath);
    }
    /**
     * 自分が通知を入れているチャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getMySubscribeChannels(options) {
        return exports.NotificationApiFp(this.configuration).getMySubscribeChannels(options)(this.axios, this.basePath);
    }
    /**
     * 通知を点けているユーザーのIDの配列を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getSubscribers(channelID, options) {
        return exports.NotificationApiFp(this.configuration).getSubscribers(channelID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーが通知を入れているチャンネルのリストを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getUserSubscribeChannels(userID, options) {
        return exports.NotificationApiFp(this.configuration).getUserSubscribeChannels(userID, options)(this.axios, this.basePath);
    }
    /**
     * FCMデバイスを登録します。
     * @param {FCMToken} fCMToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    registerNotificationDevice(fCMToken, options) {
        return exports.NotificationApiFp(this.configuration).registerNotificationDevice(fCMToken, options)(this.axios, this.basePath);
    }
}
exports.NotificationApi = NotificationApi;
/**
 * PinApi - axios parameter creator
 * @export
 */
exports.PinApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessage(pinID, options = {}) {
            // verify required parameter 'pinID' is not null or undefined
            if (pinID === null || pinID === undefined) {
                throw new base_1.RequiredError('pinID', 'Required parameter pinID was null or undefined when calling getPinnedMessage.');
            }
            const localVarPath = `/pins/{pinID}`
                .replace(`{${"pinID"}}`, encodeURIComponent(String(pinID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessages(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getPinnedMessages.');
            }
            const localVarPath = `/channels/{channelID}/pins`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} messageIDObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessage(messageIDObject, options = {}) {
            // verify required parameter 'messageIDObject' is not null or undefined
            if (messageIDObject === null || messageIDObject === undefined) {
                throw new base_1.RequiredError('messageIDObject', 'Required parameter messageIDObject was null or undefined when calling pinMessage.');
            }
            const localVarPath = `/pins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("MessageIDObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(messageIDObject !== undefined ? messageIDObject : {}) : (messageIDObject || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinMessage(pinID, options = {}) {
            // verify required parameter 'pinID' is not null or undefined
            if (pinID === null || pinID === undefined) {
                throw new base_1.RequiredError('pinID', 'Required parameter pinID was null or undefined when calling unpinMessage.');
            }
            const localVarPath = `/pins/{pinID}`
                .replace(`{${"pinID"}}`, encodeURIComponent(String(pinID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PinApi - functional programming interface
 * @export
 */
exports.PinApiFp = function (configuration) {
    return {
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessage(pinID, options) {
            const localVarAxiosArgs = exports.PinApiAxiosParamCreator(configuration).getPinnedMessage(pinID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessages(channelID, options) {
            const localVarAxiosArgs = exports.PinApiAxiosParamCreator(configuration).getPinnedMessages(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} messageIDObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessage(messageIDObject, options) {
            const localVarAxiosArgs = exports.PinApiAxiosParamCreator(configuration).pinMessage(messageIDObject, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinMessage(pinID, options) {
            const localVarAxiosArgs = exports.PinApiAxiosParamCreator(configuration).unpinMessage(pinID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PinApi - factory interface
 * @export
 */
exports.PinApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessage(pinID, options) {
            return exports.PinApiFp(configuration).getPinnedMessage(pinID, options)(axios, basePath);
        },
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessages(channelID, options) {
            return exports.PinApiFp(configuration).getPinnedMessages(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} messageIDObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessage(messageIDObject, options) {
            return exports.PinApiFp(configuration).pinMessage(messageIDObject, options)(axios, basePath);
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinMessage(pinID, options) {
            return exports.PinApiFp(configuration).unpinMessage(pinID, options)(axios, basePath);
        },
    };
};
/**
 * PinApi - object-oriented interface
 * @export
 * @class PinApi
 * @extends {BaseAPI}
 */
class PinApi extends base_1.BaseAPI {
    /**
     * ピン留めを取得します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPinnedMessage(pinID, options) {
        return exports.PinApiFp(this.configuration).getPinnedMessage(pinID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのピン留め一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPinnedMessages(channelID, options) {
        return exports.PinApiFp(this.configuration).getPinnedMessages(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージをピン留めします。
     * @param {MessageIDObject} messageIDObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinMessage(messageIDObject, options) {
        return exports.PinApiFp(this.configuration).pinMessage(messageIDObject, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを外します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    unpinMessage(pinID, options) {
        return exports.PinApiFp(this.configuration).unpinMessage(pinID, options)(this.axios, this.basePath);
    }
}
exports.PinApi = PinApi;
/**
 * PublicApi - axios parameter creator
 * @export
 */
exports.PublicApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options = {}) {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new base_1.RequiredError('username', 'Required parameter username was null or undefined when calling getPublicUserIcon.');
            }
            const localVarPath = `/public/icon/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PublicApi - functional programming interface
 * @export
 */
exports.PublicApiFp = function (configuration) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options) {
            const localVarAxiosArgs = exports.PublicApiAxiosParamCreator(configuration).getPublicUserIcon(username, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PublicApi - factory interface
 * @export
 */
exports.PublicApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options) {
            return exports.PublicApiFp(configuration).getPublicUserIcon(username, options)(axios, basePath);
        },
    };
};
/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
class PublicApi extends base_1.BaseAPI {
    /**
     * 指定したユーザーのアイコン画像を取得します。
     * @param {string} username 画像を取得するユーザーのユーザー名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getPublicUserIcon(username, options) {
        return exports.PublicApiFp(this.configuration).getPublicUserIcon(username, options)(this.axios, this.basePath);
    }
}
exports.PublicApi = PublicApi;
/**
 * SessionsApi - axios parameter creator
 * @export
 */
exports.SessionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(referenceID, options = {}) {
            // verify required parameter 'referenceID' is not null or undefined
            if (referenceID === null || referenceID === undefined) {
                throw new base_1.RequiredError('referenceID', 'Required parameter referenceID was null or undefined when calling deleteSession.');
            }
            const localVarPath = `/users/me/sessions/{referenceID}`
                .replace(`{${"referenceID"}}`, encodeURIComponent(String(referenceID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessions(options = {}) {
            const localVarPath = `/users/me/sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options = {}) {
            const localVarPath = `/users/me/sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SessionsApi - functional programming interface
 * @export
 */
exports.SessionsApiFp = function (configuration) {
    return {
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(referenceID, options) {
            const localVarAxiosArgs = exports.SessionsApiAxiosParamCreator(configuration).deleteSession(referenceID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessions(options) {
            const localVarAxiosArgs = exports.SessionsApiAxiosParamCreator(configuration).deleteSessions(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options) {
            const localVarAxiosArgs = exports.SessionsApiAxiosParamCreator(configuration).getSessions(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * SessionsApi - factory interface
 * @export
 */
exports.SessionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(referenceID, options) {
            return exports.SessionsApiFp(configuration).deleteSession(referenceID, options)(axios, basePath);
        },
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessions(options) {
            return exports.SessionsApiFp(configuration).deleteSessions(options)(axios, basePath);
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options) {
            return exports.SessionsApiFp(configuration).getSessions(options)(axios, basePath);
        },
    };
};
/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
class SessionsApi extends base_1.BaseAPI {
    /**
     * 対象のセッションをログアウトします。
     * @param {string} referenceID 操作の対象となるセッションの参照ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    deleteSession(referenceID, options) {
        return exports.SessionsApiFp(this.configuration).deleteSession(referenceID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションを全てログアウトします。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    deleteSessions(options) {
        return exports.SessionsApiFp(this.configuration).deleteSessions(options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    getSessions(options) {
        return exports.SessionsApiFp(this.configuration).getSessions(options)(this.axios, this.basePath);
    }
}
exports.SessionsApi = SessionsApi;
/**
 * StampApi - axios parameter creator
 * @export
 */
exports.StampApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling createStamp.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling createStamp.');
            }
            const localVarPath = `/stamps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampID, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new base_1.RequiredError('stampID', 'Required parameter stampID was null or undefined when calling deleteStamp.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStamp(stampID, name, file, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new base_1.RequiredError('stampID', 'Required parameter stampID was null or undefined when calling editStamp.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new base_1.RequiredError('messageID', 'Required parameter messageID was null or undefined when calling getMessageStamps.');
            }
            const localVarPath = `/messages/{messageID}/stamps`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampID, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new base_1.RequiredError('stampID', 'Required parameter stampID was null or undefined when calling getStamp.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampHistory(options = {}) {
            const localVarPath = `/users/me/stamp-history`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(options = {}) {
            const localVarPath = `/stamps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {MessageStampPost} [messageStampPost]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampMessage(messageID, stampID, messageStampPost, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new base_1.RequiredError('messageID', 'Required parameter messageID was null or undefined when calling stampMessage.');
            }
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new base_1.RequiredError('stampID', 'Required parameter stampID was null or undefined when calling stampMessage.');
            }
            const localVarPath = `/messages/{messageID}/stamps/{stampID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)))
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("MessageStampPost" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(messageStampPost !== undefined ? messageStampPost : {}) : (messageStampPost || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstampMessage(messageID, stampID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new base_1.RequiredError('messageID', 'Required parameter messageID was null or undefined when calling unstampMessage.');
            }
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new base_1.RequiredError('stampID', 'Required parameter stampID was null or undefined when calling unstampMessage.');
            }
            const localVarPath = `/messages/{messageID}/stamps/{stampID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)))
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StampApi - functional programming interface
 * @export
 */
exports.StampApiFp = function (configuration) {
    return {
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).createStamp(name, file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampID, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).deleteStamp(stampID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStamp(stampID, name, file, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).editStamp(stampID, name, file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageID, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getMessageStamps(messageID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampID, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getStamp(stampID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampHistory(options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getStampHistory(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).getStamps(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {MessageStampPost} [messageStampPost]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampMessage(messageID, stampID, messageStampPost, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).stampMessage(messageID, stampID, messageStampPost, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstampMessage(messageID, stampID, options) {
            const localVarAxiosArgs = exports.StampApiAxiosParamCreator(configuration).unstampMessage(messageID, stampID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StampApi - factory interface
 * @export
 */
exports.StampApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options) {
            return exports.StampApiFp(configuration).createStamp(name, file, options)(axios, basePath);
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampID, options) {
            return exports.StampApiFp(configuration).deleteStamp(stampID, options)(axios, basePath);
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStamp(stampID, name, file, options) {
            return exports.StampApiFp(configuration).editStamp(stampID, name, file, options)(axios, basePath);
        },
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageID, options) {
            return exports.StampApiFp(configuration).getMessageStamps(messageID, options)(axios, basePath);
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampID, options) {
            return exports.StampApiFp(configuration).getStamp(stampID, options)(axios, basePath);
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampHistory(options) {
            return exports.StampApiFp(configuration).getStampHistory(options)(axios, basePath);
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(options) {
            return exports.StampApiFp(configuration).getStamps(options)(axios, basePath);
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {MessageStampPost} [messageStampPost]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampMessage(messageID, stampID, messageStampPost, options) {
            return exports.StampApiFp(configuration).stampMessage(messageID, stampID, messageStampPost, options)(axios, basePath);
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstampMessage(messageID, stampID, options) {
            return exports.StampApiFp(configuration).unstampMessage(messageID, stampID, options)(axios, basePath);
        },
    };
};
/**
 * StampApi - object-oriented interface
 * @export
 * @class StampApi
 * @extends {BaseAPI}
 */
class StampApi extends base_1.BaseAPI {
    /**
     * スタンプを新規作成します。
     * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} file 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    createStamp(name, file, options) {
        return exports.StampApiFp(this.configuration).createStamp(name, file, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを削除します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    deleteStamp(stampID, options) {
        return exports.StampApiFp(this.configuration).deleteStamp(stampID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを修正します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    editStamp(stampID, name, file, options) {
        return exports.StampApiFp(this.configuration).editStamp(stampID, name, file, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに押されているスタンプを全て取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getMessageStamps(messageID, options) {
        return exports.StampApiFp(this.configuration).getMessageStamps(messageID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプの情報を取得します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamp(stampID, options) {
        return exports.StampApiFp(this.configuration).getStamp(stampID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStampHistory(options) {
        return exports.StampApiFp(this.configuration).getStampHistory(options)(this.axios, this.basePath);
    }
    /**
     * 全スタンプのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamps(options) {
        return exports.StampApiFp(this.configuration).getStamps(options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {MessageStampPost} [messageStampPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampMessage(messageID, stampID, messageStampPost, options) {
        return exports.StampApiFp(this.configuration).stampMessage(messageID, stampID, messageStampPost, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定したスタンプを外します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    unstampMessage(messageID, stampID, options) {
        return exports.StampApiFp(this.configuration).unstampMessage(messageID, stampID, options)(this.axios, this.basePath);
    }
}
exports.StampApi = StampApi;
/**
 * StarApi - axios parameter creator
 * @export
 */
exports.StarApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaredChannels(options = {}) {
            const localVarPath = `/users/me/stars`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starChannel(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling starChannel.');
            }
            const localVarPath = `/users/me/stars/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarChannel(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling unstarChannel.');
            }
            const localVarPath = `/users/me/stars/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StarApi - functional programming interface
 * @export
 */
exports.StarApiFp = function (configuration) {
    return {
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaredChannels(options) {
            const localVarAxiosArgs = exports.StarApiAxiosParamCreator(configuration).getStaredChannels(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starChannel(channelID, options) {
            const localVarAxiosArgs = exports.StarApiAxiosParamCreator(configuration).starChannel(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarChannel(channelID, options) {
            const localVarAxiosArgs = exports.StarApiAxiosParamCreator(configuration).unstarChannel(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StarApi - factory interface
 * @export
 */
exports.StarApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaredChannels(options) {
            return exports.StarApiFp(configuration).getStaredChannels(options)(axios, basePath);
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starChannel(channelID, options) {
            return exports.StarApiFp(configuration).starChannel(channelID, options)(axios, basePath);
        },
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarChannel(channelID, options) {
            return exports.StarApiFp(configuration).unstarChannel(channelID, options)(axios, basePath);
        },
    };
};
/**
 * StarApi - object-oriented interface
 * @export
 * @class StarApi
 * @extends {BaseAPI}
 */
class StarApi extends base_1.BaseAPI {
    /**
     * お気に入りチャンネルリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    getStaredChannels(options) {
        return exports.StarApiFp(this.configuration).getStaredChannels(options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストにチャンネルを追加します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    starChannel(channelID, options) {
        return exports.StarApiFp(this.configuration).starChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    unstarChannel(channelID, options) {
        return exports.StarApiFp(this.configuration).unstarChannel(channelID, options)(this.axios, this.basePath);
    }
}
exports.StarApi = StarApi;
/**
 * UnreadApi - axios parameter creator
 * @export
 */
exports.UnreadApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadChannels(options = {}) {
            const localVarPath = `/users/me/unread/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMessages(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling readMessages.');
            }
            const localVarPath = `/users/me/unread/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UnreadApi - functional programming interface
 * @export
 */
exports.UnreadApiFp = function (configuration) {
    return {
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadChannels(options) {
            const localVarAxiosArgs = exports.UnreadApiAxiosParamCreator(configuration).getUnreadChannels(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMessages(channelID, options) {
            const localVarAxiosArgs = exports.UnreadApiAxiosParamCreator(configuration).readMessages(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UnreadApi - factory interface
 * @export
 */
exports.UnreadApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadChannels(options) {
            return exports.UnreadApiFp(configuration).getUnreadChannels(options)(axios, basePath);
        },
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMessages(channelID, options) {
            return exports.UnreadApiFp(configuration).readMessages(channelID, options)(axios, basePath);
        },
    };
};
/**
 * UnreadApi - object-oriented interface
 * @export
 * @class UnreadApi
 * @extends {BaseAPI}
 */
class UnreadApi extends base_1.BaseAPI {
    /**
     * 未読チャンネル情報のリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    getUnreadChannels(options) {
        return exports.UnreadApiFp(this.configuration).getUnreadChannels(options)(this.axios, this.basePath);
    }
    /**
     * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    readMessages(channelID, options) {
        return exports.UnreadApiFp(this.configuration).readMessages(channelID, options)(this.axios, this.basePath);
    }
}
exports.UnreadApi = UnreadApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
exports.UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} userData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMe(userData, options = {}) {
            // verify required parameter 'userData' is not null or undefined
            if (userData === null || userData === undefined) {
                throw new base_1.RequiredError('userData', 'Required parameter userData was null or undefined when calling changeMe.');
            }
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("UserData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userData !== undefined ? userData : {}) : (userData || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options = {}) {
            const localVarPath = `/users/me/icon`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} changePassword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePassword, options = {}) {
            // verify required parameter 'changePassword' is not null or undefined
            if (changePassword === null || changePassword === undefined) {
                throw new base_1.RequiredError('changePassword', 'Required parameter changePassword was null or undefined when calling changePassword.');
            }
            const localVarPath = `/users/me/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("ChangePassword" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(changePassword !== undefined ? changePassword : {}) : (changePassword || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options = {}) {
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options = {}) {
            const localVarPath = `/users/me/icon`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQrCode(options = {}) {
            const localVarPath = `/users/me/qr-code`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling getUserIcon.');
            }
            const localVarPath = `/users/{userID}/icon`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options = {}) {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} userRegister
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userRegister, options = {}) {
            // verify required parameter 'userRegister' is not null or undefined
            if (userRegister === null || userRegister === undefined) {
                throw new base_1.RequiredError('userRegister', 'Required parameter userRegister was null or undefined when calling registerUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("UserRegister" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userRegister !== undefined ? userRegister : {}) : (userRegister || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
exports.UserApiFp = function (configuration) {
    return {
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} userData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMe(userData, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).changeMe(userData, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).changeMyIcon(file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} changePassword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePassword, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).changePassword(changePassword, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getMe(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getMyIcon(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQrCode(options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getQrCode(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userID, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getUser(userID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userID, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getUserIcon(userID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).getUsers(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} userRegister
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userRegister, options) {
            const localVarAxiosArgs = exports.UserApiAxiosParamCreator(configuration).registerUser(userRegister, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
exports.UserApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} userData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMe(userData, options) {
            return exports.UserApiFp(configuration).changeMe(userData, options)(axios, basePath);
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options) {
            return exports.UserApiFp(configuration).changeMyIcon(file, options)(axios, basePath);
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} changePassword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePassword, options) {
            return exports.UserApiFp(configuration).changePassword(changePassword, options)(axios, basePath);
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            return exports.UserApiFp(configuration).getMe(options)(axios, basePath);
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options) {
            return exports.UserApiFp(configuration).getMyIcon(options)(axios, basePath);
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQrCode(options) {
            return exports.UserApiFp(configuration).getQrCode(options)(axios, basePath);
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userID, options) {
            return exports.UserApiFp(configuration).getUser(userID, options)(axios, basePath);
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userID, options) {
            return exports.UserApiFp(configuration).getUserIcon(userID, options)(axios, basePath);
        },
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options) {
            return exports.UserApiFp(configuration).getUsers(options)(axios, basePath);
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} userRegister
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userRegister, options) {
            return exports.UserApiFp(configuration).registerUser(userRegister, options)(axios, basePath);
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * 自分のユーザー情報を変更します。
     * @param {UserData} userData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeMe(userData, options) {
        return exports.UserApiFp(this.configuration).changeMe(userData, options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコンを更新します。
     * @param {any} [file] 1MBまでのpng, jpeg, gif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeMyIcon(file, options) {
        return exports.UserApiFp(this.configuration).changeMyIcon(file, options)(this.axios, this.basePath);
    }
    /**
     * 自分のパスワードを変更します。
     * @param {ChangePassword} changePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changePassword(changePassword, options) {
        return exports.UserApiFp(this.configuration).changePassword(changePassword, options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMe(options) {
        return exports.UserApiFp(this.configuration).getMe(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMyIcon(options) {
        return exports.UserApiFp(this.configuration).getMyIcon(options)(this.axios, this.basePath);
    }
    /**
     * 自分のQRコードを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getQrCode(options) {
        return exports.UserApiFp(this.configuration).getQrCode(options)(this.axios, this.basePath);
    }
    /**
     * ユーザーの詳細を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(userID, options) {
        return exports.UserApiFp(this.configuration).getUser(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのアイコン画像を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserIcon(userID, options) {
        return exports.UserApiFp(this.configuration).getUserIcon(userID, options)(this.axios, this.basePath);
    }
    /**
     * 全ユーザーのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsers(options) {
        return exports.UserApiFp(this.configuration).getUsers(options)(this.axios, this.basePath);
    }
    /**
     * ユーザー登録します
     * @param {UserRegister} userRegister
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    registerUser(userRegister, options) {
        return exports.UserApiFp(this.configuration).registerUser(userRegister, options)(this.axios, this.basePath);
    }
}
exports.UserApi = UserApi;
/**
 * UserGroupApi - axios parameter creator
 * @export
 */
exports.UserGroupApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} addUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMember(groupID, addUserGroup, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new base_1.RequiredError('groupID', 'Required parameter groupID was null or undefined when calling addGroupMember.');
            }
            // verify required parameter 'addUserGroup' is not null or undefined
            if (addUserGroup === null || addUserGroup === undefined) {
                throw new base_1.RequiredError('addUserGroup', 'Required parameter addUserGroup was null or undefined when calling addGroupMember.');
            }
            const localVarPath = `/groups/{groupID}/members`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("AddUserGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(addUserGroup !== undefined ? addUserGroup : {}) : (addUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} postUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(postUserGroup, options = {}) {
            // verify required parameter 'postUserGroup' is not null or undefined
            if (postUserGroup === null || postUserGroup === undefined) {
                throw new base_1.RequiredError('postUserGroup', 'Required parameter postUserGroup was null or undefined when calling createGroup.');
            }
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostUserGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserGroup !== undefined ? postUserGroup : {}) : (postUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new base_1.RequiredError('groupID', 'Required parameter groupID was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupMember(groupID, userID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new base_1.RequiredError('groupID', 'Required parameter groupID was null or undefined when calling deleteGroupMember.');
            }
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling deleteGroupMember.');
            }
            const localVarPath = `/groups/{groupID}/members/{userID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)))
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} patchUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGroup(groupID, patchUserGroup, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new base_1.RequiredError('groupID', 'Required parameter groupID was null or undefined when calling editGroup.');
            }
            // verify required parameter 'patchUserGroup' is not null or undefined
            if (patchUserGroup === null || patchUserGroup === undefined) {
                throw new base_1.RequiredError('patchUserGroup', 'Required parameter patchUserGroup was null or undefined when calling editGroup.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchUserGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserGroup !== undefined ? patchUserGroup : {}) : (patchUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new base_1.RequiredError('groupID', 'Required parameter groupID was null or undefined when calling getGroup.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new base_1.RequiredError('groupID', 'Required parameter groupID was null or undefined when calling getGroupMembers.');
            }
            const localVarPath = `/groups/{groupID}/members`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options = {}) {
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroups(options = {}) {
            const localVarPath = `/users/me/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling getUserGroups.');
            }
            const localVarPath = `/users/{userID}/groups`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserGroupApi - functional programming interface
 * @export
 */
exports.UserGroupApiFp = function (configuration) {
    return {
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} addUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMember(groupID, addUserGroup, options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).addGroupMember(groupID, addUserGroup, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} postUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(postUserGroup, options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).createGroup(postUserGroup, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID, options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).deleteGroup(groupID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupMember(groupID, userID, options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).deleteGroupMember(groupID, userID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} patchUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGroup(groupID, patchUserGroup, options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).editGroup(groupID, patchUserGroup, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupID, options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).getGroup(groupID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers(groupID, options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).getGroupMembers(groupID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).getGroups(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroups(options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).getMyGroups(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userID, options) {
            const localVarAxiosArgs = exports.UserGroupApiAxiosParamCreator(configuration).getUserGroups(userID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserGroupApi - factory interface
 * @export
 */
exports.UserGroupApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} addUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMember(groupID, addUserGroup, options) {
            return exports.UserGroupApiFp(configuration).addGroupMember(groupID, addUserGroup, options)(axios, basePath);
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} postUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(postUserGroup, options) {
            return exports.UserGroupApiFp(configuration).createGroup(postUserGroup, options)(axios, basePath);
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID, options) {
            return exports.UserGroupApiFp(configuration).deleteGroup(groupID, options)(axios, basePath);
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupMember(groupID, userID, options) {
            return exports.UserGroupApiFp(configuration).deleteGroupMember(groupID, userID, options)(axios, basePath);
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} patchUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGroup(groupID, patchUserGroup, options) {
            return exports.UserGroupApiFp(configuration).editGroup(groupID, patchUserGroup, options)(axios, basePath);
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupID, options) {
            return exports.UserGroupApiFp(configuration).getGroup(groupID, options)(axios, basePath);
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers(groupID, options) {
            return exports.UserGroupApiFp(configuration).getGroupMembers(groupID, options)(axios, basePath);
        },
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options) {
            return exports.UserGroupApiFp(configuration).getGroups(options)(axios, basePath);
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroups(options) {
            return exports.UserGroupApiFp(configuration).getMyGroups(options)(axios, basePath);
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userID, options) {
            return exports.UserGroupApiFp(configuration).getUserGroups(userID, options)(axios, basePath);
        },
    };
};
/**
 * UserGroupApi - object-oriented interface
 * @export
 * @class UserGroupApi
 * @extends {BaseAPI}
 */
class UserGroupApi extends base_1.BaseAPI {
    /**
     * ユーザーグループにメンバーを追加します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {AddUserGroup} addUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    addGroupMember(groupID, addUserGroup, options) {
        return exports.UserGroupApiFp(this.configuration).addGroupMember(groupID, addUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを作成します
     * @param {PostUserGroup} postUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    createGroup(postUserGroup, options) {
        return exports.UserGroupApiFp(this.configuration).createGroup(postUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    deleteGroup(groupID, options) {
        return exports.UserGroupApiFp(this.configuration).deleteGroup(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループからメンバーを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    deleteGroupMember(groupID, userID, options) {
        return exports.UserGroupApiFp(this.configuration).deleteGroupMember(groupID, userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループの情報を変更します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {PatchUserGroup} patchUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    editGroup(groupID, patchUserGroup, options) {
        return exports.UserGroupApiFp(this.configuration).editGroup(groupID, patchUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroup(groupID, options) {
        return exports.UserGroupApiFp(this.configuration).getGroup(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループのメンバーのIDを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroupMembers(groupID, options) {
        return exports.UserGroupApiFp(this.configuration).getGroupMembers(groupID, options)(this.axios, this.basePath);
    }
    /**
     * 全てのユーザーグループを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroups(options) {
        return exports.UserGroupApiFp(this.configuration).getGroups(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getMyGroups(options) {
        return exports.UserGroupApiFp(this.configuration).getMyGroups(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getUserGroups(userID, options) {
        return exports.UserGroupApiFp(this.configuration).getUserGroups(userID, options)(this.axios, this.basePath);
    }
}
exports.UserGroupApi = UserGroupApi;
/**
 * UserTagApi - axios parameter creator
 * @export
 */
exports.UserTagApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} setTag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userID, setTag, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling addUserTag.');
            }
            // verify required parameter 'setTag' is not null or undefined
            if (setTag === null || setTag === undefined) {
                throw new base_1.RequiredError('setTag', 'Required parameter setTag was null or undefined when calling addUserTag.');
            }
            const localVarPath = `/users/{userID}/tags`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SetTag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setTag !== undefined ? setTag : {}) : (setTag || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} setTagLock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLockUserTag(userID, tagID, setTagLock, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling changeLockUserTag.');
            }
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new base_1.RequiredError('tagID', 'Required parameter tagID was null or undefined when calling changeLockUserTag.');
            }
            // verify required parameter 'setTagLock' is not null or undefined
            if (setTagLock === null || setTagLock === undefined) {
                throw new base_1.RequiredError('setTagLock', 'Required parameter setTagLock was null or undefined when calling changeLockUserTag.');
            }
            const localVarPath = `/users/{userID}/tags/{tagID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SetTagLock" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setTagLock !== undefined ? setTagLock : {}) : (setTagLock || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(userID, tagID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling deleteUserTag.');
            }
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new base_1.RequiredError('tagID', 'Required parameter tagID was null or undefined when calling deleteUserTag.');
            }
            const localVarPath = `/users/{userID}/tags/{tagID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagID, options = {}) {
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new base_1.RequiredError('tagID', 'Required parameter tagID was null or undefined when calling getTag.');
            }
            const localVarPath = `/tags/{tagID}`
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new base_1.RequiredError('userID', 'Required parameter userID was null or undefined when calling getUserTags.');
            }
            const localVarPath = `/users/{userID}/tags`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserTagApi - functional programming interface
 * @export
 */
exports.UserTagApiFp = function (configuration) {
    return {
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} setTag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userID, setTag, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).addUserTag(userID, setTag, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} setTagLock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLockUserTag(userID, tagID, setTagLock, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).changeLockUserTag(userID, tagID, setTagLock, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(userID, tagID, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).deleteUserTag(userID, tagID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagID, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).getTag(tagID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userID, options) {
            const localVarAxiosArgs = exports.UserTagApiAxiosParamCreator(configuration).getUserTags(userID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserTagApi - factory interface
 * @export
 */
exports.UserTagApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} setTag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userID, setTag, options) {
            return exports.UserTagApiFp(configuration).addUserTag(userID, setTag, options)(axios, basePath);
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} setTagLock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLockUserTag(userID, tagID, setTagLock, options) {
            return exports.UserTagApiFp(configuration).changeLockUserTag(userID, tagID, setTagLock, options)(axios, basePath);
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(userID, tagID, options) {
            return exports.UserTagApiFp(configuration).deleteUserTag(userID, tagID, options)(axios, basePath);
        },
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagID, options) {
            return exports.UserTagApiFp(configuration).getTag(tagID, options)(axios, basePath);
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userID, options) {
            return exports.UserTagApiFp(configuration).getUserTags(userID, options)(axios, basePath);
        },
    };
};
/**
 * UserTagApi - object-oriented interface
 * @export
 * @class UserTagApi
 * @extends {BaseAPI}
 */
class UserTagApi extends base_1.BaseAPI {
    /**
     * ユーザーにタグを追加します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SetTag} setTag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    addUserTag(userID, setTag, options) {
        return exports.UserTagApiFp(this.configuration).addUserTag(userID, setTag, options)(this.axios, this.basePath);
    }
    /**
     * タグのロック、アンロックを変更します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {SetTagLock} setTagLock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    changeLockUserTag(userID, tagID, setTagLock, options) {
        return exports.UserTagApiFp(this.configuration).changeLockUserTag(userID, tagID, setTagLock, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    deleteUserTag(userID, tagID, options) {
        return exports.UserTagApiFp(this.configuration).deleteUserTag(userID, tagID, options)(this.axios, this.basePath);
    }
    /**
     * 指定されたタグの情報を取得します。
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getTag(tagID, options) {
        return exports.UserTagApiFp(this.configuration).getTag(tagID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのタグのリストを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getUserTags(userID, options) {
        return exports.UserTagApiFp(this.configuration).getUserTags(userID, options)(this.axios, this.basePath);
    }
}
exports.UserTagApi = UserTagApi;
/**
 * WebhookApi - axios parameter creator
 * @export
 */
exports.WebhookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookID, file, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new base_1.RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling changeWebhookIcon.');
            }
            const localVarPath = `/webhooks/{webhookID}/icon`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} postWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhooks(postWebhook, options = {}) {
            // verify required parameter 'postWebhook' is not null or undefined
            if (postWebhook === null || postWebhook === undefined) {
                throw new base_1.RequiredError('postWebhook', 'Required parameter postWebhook was null or undefined when calling createWebhooks.');
            }
            const localVarPath = `/webhooks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostWebhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postWebhook !== undefined ? postWebhook : {}) : (postWebhook || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new base_1.RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} patchWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookID, patchWebhook, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new base_1.RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling editWebhook.');
            }
            // verify required parameter 'patchWebhook' is not null or undefined
            if (patchWebhook === null || patchWebhook === undefined) {
                throw new base_1.RequiredError('patchWebhook', 'Required parameter patchWebhook was null or undefined when calling editWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchWebhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchWebhook !== undefined ? patchWebhook : {}) : (patchWebhook || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new base_1.RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling getWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new base_1.RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling getWebhookIcon.');
            }
            const localVarPath = `/webhooks/{webhookID}/icon`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options = {}) {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGitHubWebhook(webhookID, body, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new base_1.RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling postGitHubWebhook.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling postGitHubWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}/github`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("object" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} body
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new base_1.RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling postWebhook.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling postWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }
            if (xTRAQChannelId !== undefined && xTRAQChannelId !== null) {
                localVarHeaderParameter['X-TRAQ-Channel-Id'] = String(xTRAQChannelId);
            }
            if (xTRAQSignature !== undefined && xTRAQSignature !== null) {
                localVarHeaderParameter['X-TRAQ-Signature'] = String(xTRAQSignature);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WebhookApi - functional programming interface
 * @export
 */
exports.WebhookApiFp = function (configuration) {
    return {
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookID, file, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).changeWebhookIcon(webhookID, file, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} postWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhooks(postWebhook, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).createWebhooks(postWebhook, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookID, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).deleteWebhook(webhookID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} patchWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookID, patchWebhook, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).editWebhook(webhookID, patchWebhook, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookID, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).getWebhook(webhookID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookID, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).getWebhookIcon(webhookID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).getWebhooks(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGitHubWebhook(webhookID, body, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).postGitHubWebhook(webhookID, body, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} body
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options) {
            const localVarAxiosArgs = exports.WebhookApiAxiosParamCreator(configuration).postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * WebhookApi - factory interface
 * @export
 */
exports.WebhookApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookID, file, options) {
            return exports.WebhookApiFp(configuration).changeWebhookIcon(webhookID, file, options)(axios, basePath);
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} postWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhooks(postWebhook, options) {
            return exports.WebhookApiFp(configuration).createWebhooks(postWebhook, options)(axios, basePath);
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookID, options) {
            return exports.WebhookApiFp(configuration).deleteWebhook(webhookID, options)(axios, basePath);
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} patchWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookID, patchWebhook, options) {
            return exports.WebhookApiFp(configuration).editWebhook(webhookID, patchWebhook, options)(axios, basePath);
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookID, options) {
            return exports.WebhookApiFp(configuration).getWebhook(webhookID, options)(axios, basePath);
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookID, options) {
            return exports.WebhookApiFp(configuration).getWebhookIcon(webhookID, options)(axios, basePath);
        },
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options) {
            return exports.WebhookApiFp(configuration).getWebhooks(options)(axios, basePath);
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGitHubWebhook(webhookID, body, options) {
            return exports.WebhookApiFp(configuration).postGitHubWebhook(webhookID, body, options)(axios, basePath);
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} body
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options) {
            return exports.WebhookApiFp(configuration).postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options)(axios, basePath);
        },
    };
};
/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
class WebhookApi extends base_1.BaseAPI {
    /**
     * 指定したwebhookのアイコンを変更します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    changeWebhookIcon(webhookID, file, options) {
        return exports.WebhookApiFp(this.configuration).changeWebhookIcon(webhookID, file, options)(this.axios, this.basePath);
    }
    /**
     * webhookを作成します。
     * @param {PostWebhook} postWebhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    createWebhooks(postWebhook, options) {
        return exports.WebhookApiFp(this.configuration).createWebhooks(postWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookを削除します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    deleteWebhook(webhookID, options) {
        return exports.WebhookApiFp(this.configuration).deleteWebhook(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * webhookを修正します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {PatchWebhook} patchWebhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    editWebhook(webhookID, patchWebhook, options) {
        return exports.WebhookApiFp(this.configuration).editWebhook(webhookID, patchWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookの詳細を取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhook(webhookID, options) {
        return exports.WebhookApiFp(this.configuration).getWebhook(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したWebhookのアイコンを取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhookIcon(webhookID, options) {
        return exports.WebhookApiFp(this.configuration).getWebhookIcon(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したwebhookの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhooks(options) {
        return exports.WebhookApiFp(this.configuration).getWebhooks(options)(this.axios, this.basePath);
    }
    /**
     * Github-Compatibleなwebhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postGitHubWebhook(webhookID, body, options) {
        return exports.WebhookApiFp(this.configuration).postGitHubWebhook(webhookID, body, options)(this.axios, this.basePath);
    }
    /**
     * webhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {string} body
     * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
     * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options) {
        return exports.WebhookApiFp(this.configuration).postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options)(this.axios, this.basePath);
    }
}
exports.WebhookApi = WebhookApi;
/**
 * WebrtcApi - axios parameter creator
 * @export
 */
exports.WebrtcApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルのWebRTC状態を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelWebRTCState(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new base_1.RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelWebRTCState.');
            }
            const localVarPath = `/channels/{channelID}/webrtc/state`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のWebRTCの状態を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options = {}) {
            const localVarPath = `/webrtc/state`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のWebRTCの状態を変更します。
         * @param {PutWebRTCState} putWebRTCState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebRTCState(putWebRTCState, options = {}) {
            // verify required parameter 'putWebRTCState' is not null or undefined
            if (putWebRTCState === null || putWebRTCState === undefined) {
                throw new base_1.RequiredError('putWebRTCState', 'Required parameter putWebRTCState was null or undefined when calling putWebRTCState.');
            }
            const localVarPath = `/webrtc/state`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PutWebRTCState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putWebRTCState !== undefined ? putWebRTCState : {}) : (putWebRTCState || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WebrtcApi - functional programming interface
 * @export
 */
exports.WebrtcApiFp = function (configuration) {
    return {
        /**
         * チャンネルのWebRTC状態を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelWebRTCState(channelID, options) {
            const localVarAxiosArgs = exports.WebrtcApiAxiosParamCreator(configuration).getChannelWebRTCState(channelID, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のWebRTCの状態を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options) {
            const localVarAxiosArgs = exports.WebrtcApiAxiosParamCreator(configuration).getWebRTCState(options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のWebRTCの状態を変更します。
         * @param {PutWebRTCState} putWebRTCState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebRTCState(putWebRTCState, options) {
            const localVarAxiosArgs = exports.WebrtcApiAxiosParamCreator(configuration).putWebRTCState(putWebRTCState, options);
            return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * WebrtcApi - factory interface
 * @export
 */
exports.WebrtcApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルのWebRTC状態を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelWebRTCState(channelID, options) {
            return exports.WebrtcApiFp(configuration).getChannelWebRTCState(channelID, options)(axios, basePath);
        },
        /**
         * 自身のWebRTCの状態を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options) {
            return exports.WebrtcApiFp(configuration).getWebRTCState(options)(axios, basePath);
        },
        /**
         * 自身のWebRTCの状態を変更します。
         * @param {PutWebRTCState} putWebRTCState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebRTCState(putWebRTCState, options) {
            return exports.WebrtcApiFp(configuration).putWebRTCState(putWebRTCState, options)(axios, basePath);
        },
    };
};
/**
 * WebrtcApi - object-oriented interface
 * @export
 * @class WebrtcApi
 * @extends {BaseAPI}
 */
class WebrtcApi extends base_1.BaseAPI {
    /**
     * チャンネルのWebRTC状態を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getChannelWebRTCState(channelID, options) {
        return exports.WebrtcApiFp(this.configuration).getChannelWebRTCState(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 自身のWebRTCの状態を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getWebRTCState(options) {
        return exports.WebrtcApiFp(this.configuration).getWebRTCState(options)(this.axios, this.basePath);
    }
    /**
     * 自身のWebRTCの状態を変更します。
     * @param {PutWebRTCState} putWebRTCState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    putWebRTCState(putWebRTCState, options) {
        return exports.WebrtcApiFp(this.configuration).putWebRTCState(putWebRTCState, options)(this.axios, this.basePath);
    }
}
exports.WebrtcApi = WebrtcApi;
class Apis extends base_1.BaseAPI {
    /**
     * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
     * @param {number} [limit] 取得する件数 1-50
     * @param {boolean} [subscribe] 購読チャンネルのみを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    getActivities(limit, subscribe, options) {
        return exports.ActivityApiFp(this.configuration).getActivities(limit, subscribe, options)(this.axios, this.basePath);
    }
    /**
     * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
     * @param {UserLogin} userLogin
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    login(userLogin, redirect, options) {
        return exports.AuthenticationApiFp(this.configuration).login(userLogin, redirect, options)(this.axios, this.basePath);
    }
    /**
     * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logout(redirect, options) {
        return exports.AuthenticationApiFp(this.configuration).logout(redirect, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {string} clientId
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return exports.AuthorizationApiFp(this.configuration).getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {string} clientId
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return exports.AuthorizationApiFp(this.configuration).postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可承諾
     * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2AuthorizeDecide(submit, options) {
        return exports.AuthorizationApiFp(this.configuration).postOauth2AuthorizeDecide(submit, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 トークンエンドポイント
     * @param {string} grantType
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [clientId]
     * @param {string} [codeVerifier]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [scope]
     * @param {string} [refreshToken]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
        return exports.AuthorizationApiFp(this.configuration).postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにBotを参加させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PostBotChannel} postBotChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    addChannelBot(channelID, postBotChannel, options) {
        return exports.BotApiFp(this.configuration).addChannelBot(channelID, postBotChannel, options)(this.axios, this.basePath);
    }
    /**
     * Botの購読イベントを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotEvents} putBotEvents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotEvents(botID, putBotEvents, options) {
        return exports.BotApiFp(this.configuration).changeBotEvents(botID, putBotEvents, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotIcon(botID, file, options) {
        return exports.BotApiFp(this.configuration).changeBotIcon(botID, file, options)(this.axios, this.basePath);
    }
    /**
     * Botの状態を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotState} putBotState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotState(botID, putBotState, options) {
        return exports.BotApiFp(this.configuration).changeBotState(botID, putBotState, options)(this.axios, this.basePath);
    }
    /**
     * Botを作成します。
     * @param {PostBot} postBot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    createBots(postBot, options) {
        return exports.BotApiFp(this.configuration).createBots(postBot, options)(this.axios, this.basePath);
    }
    /**
     * Botを削除します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    deleteBot(botID, options) {
        return exports.BotApiFp(this.configuration).deleteBot(botID, options)(this.axios, this.basePath);
    }
    /**
     * Bot情報を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PatchBot} patchBot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    editBot(botID, patchBot, options) {
        return exports.BotApiFp(this.configuration).editBot(botID, patchBot, options)(this.axios, this.basePath);
    }
    /**
     * Botを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBot(botID, options) {
        return exports.BotApiFp(this.configuration).getBot(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botが参加しているチャンネルのUUIDの配列を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotChannels(botID, options) {
        return exports.BotApiFp(this.configuration).getBotChannels(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの詳細を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotDetail(botID, options) {
        return exports.BotApiFp(this.configuration).getBotDetail(botID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotIcon(botID, options) {
        return exports.BotApiFp(this.configuration).getBotIcon(botID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したBotの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBots(options) {
        return exports.BotApiFp(this.configuration).getBots(options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに参加しているBot一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getChannelBots(channelID, options) {
        return exports.BotApiFp(this.configuration).getChannelBots(channelID, options)(this.axios, this.basePath);
    }
    /**
     * Botの各種トークンを再発行します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    reissueBotTokens(botID, options) {
        return exports.BotApiFp(this.configuration).reissueBotTokens(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botをチャンネルから退出させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    removeChannelBot(channelID, botID, options) {
        return exports.BotApiFp(this.configuration).removeChannelBot(channelID, botID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの親チャンネルを変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PutParentChannel} putParentChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    changeChannelParent(channelID, putParentChannel, options) {
        return exports.ChannelApiFp(this.configuration).changeChannelParent(channelID, putParentChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SetChannelTopic} setChannelTopic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    changeChannelTopic(channelID, setChannelTopic, options) {
        return exports.ChannelApiFp(this.configuration).changeChannelTopic(channelID, setChannelTopic, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを作成します。
     * @param {CreateChannel} createChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannel(createChannel, options) {
        return exports.ChannelApiFp(this.configuration).createChannel(createChannel, options)(this.axios, this.basePath);
    }
    /**
     * 子チャンネルを作成します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {CreateChannelChild} createChannelChild
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannelChild(channelID, createChannelChild, options) {
        return exports.ChannelApiFp(this.configuration).createChannelChild(channelID, createChannelChild, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを削除します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    deleteChannel(channelID, options) {
        return exports.ChannelApiFp(this.configuration).deleteChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PatchChannel} patchChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannel(channelID, patchChannel, options) {
        return exports.ChannelApiFp(this.configuration).editChannel(channelID, patchChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannel(channelID, options) {
        return exports.ChannelApiFp(this.configuration).getChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルイベントのリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options) {
        return exports.ChannelApiFp(this.configuration).getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの統計情報を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelStats(channelID, options) {
        return exports.ChannelApiFp(this.configuration).getChannelStats(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelTopic(channelID, options) {
        return exports.ChannelApiFp(this.configuration).getChannelTopic(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 現在のチャンネル閲覧者のリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelViewers(channelID, options) {
        return exports.ChannelApiFp(this.configuration).getChannelViewers(channelID, options)(this.axios, this.basePath);
    }
    /**
     * (すべての)チャンネルのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannels(options) {
        return exports.ChannelApiFp(this.configuration).getChannels(options)(this.axios, this.basePath);
    }
    /**
     * クライアントを登録します。
     * @param {PostClient} postClient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    createClient(postClient, options) {
        return exports.ClientApiFp(this.configuration).createClient(postClient, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    deleteClient(clientID, options) {
        return exports.ClientApiFp(this.configuration).deleteClient(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したトークンの認可を取り消します。
     * @param {string} oauth2TokenID 操作の対象となるTokenのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    deleteToken(oauth2TokenID, options) {
        return exports.ClientApiFp(this.configuration).deleteToken(oauth2TokenID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClient(clientID, options) {
        return exports.ClientApiFp(this.configuration).getClient(clientID, options)(this.axios, this.basePath);
    }
    /**
     * クライアントの詳細を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClientDetail(clientID, options) {
        return exports.ClientApiFp(this.configuration).getClientDetail(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が登録しているクライアントの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClients(options) {
        return exports.ClientApiFp(this.configuration).getClients(options)(this.axios, this.basePath);
    }
    /**
     * 自分が許可しているクライアントの一覧とトークン情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getTokens(options) {
        return exports.ClientApiFp(this.configuration).getTokens(options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を変更します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {PatchClient} patchClient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    patchClient(clientID, patchClient, options) {
        return exports.ClientApiFp(this.configuration).patchClient(clientID, patchClient, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルを削除します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    deleteFile(fileID, options) {
        return exports.FileApiFp(this.configuration).deleteFile(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルの中身を取得します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFile(fileID, dl, options) {
        return exports.FileApiFp(this.configuration).getFile(fileID, dl, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのメタデータを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileMeta(fileID, options) {
        return exports.FileApiFp(this.configuration).getFileMeta(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのサムネイルを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileThumbnail(fileID, options) {
        return exports.FileApiFp(this.configuration).getFileThumbnail(fileID, options)(this.axios, this.basePath);
    }
    /**
     * ファイルをアップロードします
     * @param {any} file ファイル本体
     * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    uploadFile(file, aclReadable, options) {
        return exports.FileApiFp(this.configuration).uploadFile(file, aclReadable, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを現在見ている人・編集している人を取得します。
     * @param {string} channelId 現在いるチャンネルId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    getHeartbeat(channelId, options) {
        return exports.HeartbeatApiFp(this.configuration).getHeartbeat(channelId, options)(this.axios, this.basePath);
    }
    /**
     * どのチャンネルを見ているか・編集しているかを送信します。
     * @param {Heartbeat} heartbeat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    postHeartbeat(heartbeat, options) {
        return exports.HeartbeatApiFp(this.configuration).postHeartbeat(heartbeat, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを削除します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    deleteMessage(messageID, options) {
        return exports.MessageApiFp(this.configuration).deleteMessage(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを編集します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {SendMessage} sendMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    editMessage(messageID, sendMessage, options) {
        return exports.MessageApiFp(this.configuration).editMessage(messageID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルに存在するメッセージを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getDirectMessages(userID, limit, offset, since, until, inclusive, order, options) {
        return exports.MessageApiFp(this.configuration).getDirectMessages(userID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessage(messageID, options) {
        return exports.MessageApiFp(this.configuration).getMessage(messageID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに存在するメッセージを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessages(channelID, limit, offset, since, until, inclusive, order, options) {
        return exports.MessageApiFp(this.configuration).getMessages(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * メッセージ通報を最大50件取得します。
     * @param {number} [p] ページ番号(ゼロオリジン)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getReports(p, options) {
        return exports.MessageApiFp(this.configuration).getReports(p, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルにメッセージを投稿します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SendMessage} sendMessage
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postDirectMessage(userID, sendMessage, embed, options) {
        return exports.MessageApiFp(this.configuration).postDirectMessage(userID, sendMessage, embed, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージを投稿します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SendMessage} sendMessage
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postMessage(channelID, sendMessage, embed, options) {
        return exports.MessageApiFp(this.configuration).postMessage(channelID, sendMessage, embed, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを通報します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {ReportMessage} reportMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    reportMessage(messageID, reportMessage, options) {
        return exports.MessageApiFp(this.configuration).reportMessage(messageID, reportMessage, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {NotificationUsers} notificationUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    changeSubscribers(channelID, notificationUsers, options) {
        return exports.NotificationApiFp(this.configuration).changeSubscribers(channelID, notificationUsers, options)(this.axios, this.basePath);
    }
    /**
     * 通知ストリーム(Server Sent Events)に接続します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    connectNotification(options) {
        return exports.NotificationApiFp(this.configuration).connectNotification(options)(this.axios, this.basePath);
    }
    /**
     * 自分が通知を入れているチャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getMySubscribeChannels(options) {
        return exports.NotificationApiFp(this.configuration).getMySubscribeChannels(options)(this.axios, this.basePath);
    }
    /**
     * 通知を点けているユーザーのIDの配列を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getSubscribers(channelID, options) {
        return exports.NotificationApiFp(this.configuration).getSubscribers(channelID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーが通知を入れているチャンネルのリストを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getUserSubscribeChannels(userID, options) {
        return exports.NotificationApiFp(this.configuration).getUserSubscribeChannels(userID, options)(this.axios, this.basePath);
    }
    /**
     * FCMデバイスを登録します。
     * @param {FCMToken} fCMToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    registerNotificationDevice(fCMToken, options) {
        return exports.NotificationApiFp(this.configuration).registerNotificationDevice(fCMToken, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを取得します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPinnedMessage(pinID, options) {
        return exports.PinApiFp(this.configuration).getPinnedMessage(pinID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのピン留め一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPinnedMessages(channelID, options) {
        return exports.PinApiFp(this.configuration).getPinnedMessages(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージをピン留めします。
     * @param {MessageIDObject} messageIDObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinMessage(messageIDObject, options) {
        return exports.PinApiFp(this.configuration).pinMessage(messageIDObject, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを外します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    unpinMessage(pinID, options) {
        return exports.PinApiFp(this.configuration).unpinMessage(pinID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのアイコン画像を取得します。
     * @param {string} username 画像を取得するユーザーのユーザー名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getPublicUserIcon(username, options) {
        return exports.PublicApiFp(this.configuration).getPublicUserIcon(username, options)(this.axios, this.basePath);
    }
    /**
     * 対象のセッションをログアウトします。
     * @param {string} referenceID 操作の対象となるセッションの参照ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    deleteSession(referenceID, options) {
        return exports.SessionsApiFp(this.configuration).deleteSession(referenceID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションを全てログアウトします。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    deleteSessions(options) {
        return exports.SessionsApiFp(this.configuration).deleteSessions(options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    getSessions(options) {
        return exports.SessionsApiFp(this.configuration).getSessions(options)(this.axios, this.basePath);
    }
    /**
     * スタンプを新規作成します。
     * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} file 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    createStamp(name, file, options) {
        return exports.StampApiFp(this.configuration).createStamp(name, file, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを削除します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    deleteStamp(stampID, options) {
        return exports.StampApiFp(this.configuration).deleteStamp(stampID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを修正します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    editStamp(stampID, name, file, options) {
        return exports.StampApiFp(this.configuration).editStamp(stampID, name, file, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに押されているスタンプを全て取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getMessageStamps(messageID, options) {
        return exports.StampApiFp(this.configuration).getMessageStamps(messageID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプの情報を取得します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamp(stampID, options) {
        return exports.StampApiFp(this.configuration).getStamp(stampID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStampHistory(options) {
        return exports.StampApiFp(this.configuration).getStampHistory(options)(this.axios, this.basePath);
    }
    /**
     * 全スタンプのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamps(options) {
        return exports.StampApiFp(this.configuration).getStamps(options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {MessageStampPost} [messageStampPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampMessage(messageID, stampID, messageStampPost, options) {
        return exports.StampApiFp(this.configuration).stampMessage(messageID, stampID, messageStampPost, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定したスタンプを外します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    unstampMessage(messageID, stampID, options) {
        return exports.StampApiFp(this.configuration).unstampMessage(messageID, stampID, options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    getStaredChannels(options) {
        return exports.StarApiFp(this.configuration).getStaredChannels(options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストにチャンネルを追加します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    starChannel(channelID, options) {
        return exports.StarApiFp(this.configuration).starChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    unstarChannel(channelID, options) {
        return exports.StarApiFp(this.configuration).unstarChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 未読チャンネル情報のリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    getUnreadChannels(options) {
        return exports.UnreadApiFp(this.configuration).getUnreadChannels(options)(this.axios, this.basePath);
    }
    /**
     * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    readMessages(channelID, options) {
        return exports.UnreadApiFp(this.configuration).readMessages(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を変更します。
     * @param {UserData} userData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeMe(userData, options) {
        return exports.UserApiFp(this.configuration).changeMe(userData, options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコンを更新します。
     * @param {any} [file] 1MBまでのpng, jpeg, gif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeMyIcon(file, options) {
        return exports.UserApiFp(this.configuration).changeMyIcon(file, options)(this.axios, this.basePath);
    }
    /**
     * 自分のパスワードを変更します。
     * @param {ChangePassword} changePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changePassword(changePassword, options) {
        return exports.UserApiFp(this.configuration).changePassword(changePassword, options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMe(options) {
        return exports.UserApiFp(this.configuration).getMe(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMyIcon(options) {
        return exports.UserApiFp(this.configuration).getMyIcon(options)(this.axios, this.basePath);
    }
    /**
     * 自分のQRコードを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getQrCode(options) {
        return exports.UserApiFp(this.configuration).getQrCode(options)(this.axios, this.basePath);
    }
    /**
     * ユーザーの詳細を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(userID, options) {
        return exports.UserApiFp(this.configuration).getUser(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのアイコン画像を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserIcon(userID, options) {
        return exports.UserApiFp(this.configuration).getUserIcon(userID, options)(this.axios, this.basePath);
    }
    /**
     * 全ユーザーのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsers(options) {
        return exports.UserApiFp(this.configuration).getUsers(options)(this.axios, this.basePath);
    }
    /**
     * ユーザー登録します
     * @param {UserRegister} userRegister
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    registerUser(userRegister, options) {
        return exports.UserApiFp(this.configuration).registerUser(userRegister, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループにメンバーを追加します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {AddUserGroup} addUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    addGroupMember(groupID, addUserGroup, options) {
        return exports.UserGroupApiFp(this.configuration).addGroupMember(groupID, addUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを作成します
     * @param {PostUserGroup} postUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    createGroup(postUserGroup, options) {
        return exports.UserGroupApiFp(this.configuration).createGroup(postUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    deleteGroup(groupID, options) {
        return exports.UserGroupApiFp(this.configuration).deleteGroup(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループからメンバーを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    deleteGroupMember(groupID, userID, options) {
        return exports.UserGroupApiFp(this.configuration).deleteGroupMember(groupID, userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループの情報を変更します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {PatchUserGroup} patchUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    editGroup(groupID, patchUserGroup, options) {
        return exports.UserGroupApiFp(this.configuration).editGroup(groupID, patchUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroup(groupID, options) {
        return exports.UserGroupApiFp(this.configuration).getGroup(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループのメンバーのIDを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroupMembers(groupID, options) {
        return exports.UserGroupApiFp(this.configuration).getGroupMembers(groupID, options)(this.axios, this.basePath);
    }
    /**
     * 全てのユーザーグループを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroups(options) {
        return exports.UserGroupApiFp(this.configuration).getGroups(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getMyGroups(options) {
        return exports.UserGroupApiFp(this.configuration).getMyGroups(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getUserGroups(userID, options) {
        return exports.UserGroupApiFp(this.configuration).getUserGroups(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーにタグを追加します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SetTag} setTag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    addUserTag(userID, setTag, options) {
        return exports.UserTagApiFp(this.configuration).addUserTag(userID, setTag, options)(this.axios, this.basePath);
    }
    /**
     * タグのロック、アンロックを変更します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {SetTagLock} setTagLock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    changeLockUserTag(userID, tagID, setTagLock, options) {
        return exports.UserTagApiFp(this.configuration).changeLockUserTag(userID, tagID, setTagLock, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    deleteUserTag(userID, tagID, options) {
        return exports.UserTagApiFp(this.configuration).deleteUserTag(userID, tagID, options)(this.axios, this.basePath);
    }
    /**
     * 指定されたタグの情報を取得します。
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getTag(tagID, options) {
        return exports.UserTagApiFp(this.configuration).getTag(tagID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのタグのリストを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getUserTags(userID, options) {
        return exports.UserTagApiFp(this.configuration).getUserTags(userID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したwebhookのアイコンを変更します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    changeWebhookIcon(webhookID, file, options) {
        return exports.WebhookApiFp(this.configuration).changeWebhookIcon(webhookID, file, options)(this.axios, this.basePath);
    }
    /**
     * webhookを作成します。
     * @param {PostWebhook} postWebhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    createWebhooks(postWebhook, options) {
        return exports.WebhookApiFp(this.configuration).createWebhooks(postWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookを削除します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    deleteWebhook(webhookID, options) {
        return exports.WebhookApiFp(this.configuration).deleteWebhook(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * webhookを修正します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {PatchWebhook} patchWebhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    editWebhook(webhookID, patchWebhook, options) {
        return exports.WebhookApiFp(this.configuration).editWebhook(webhookID, patchWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookの詳細を取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhook(webhookID, options) {
        return exports.WebhookApiFp(this.configuration).getWebhook(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したWebhookのアイコンを取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhookIcon(webhookID, options) {
        return exports.WebhookApiFp(this.configuration).getWebhookIcon(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したwebhookの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhooks(options) {
        return exports.WebhookApiFp(this.configuration).getWebhooks(options)(this.axios, this.basePath);
    }
    /**
     * Github-Compatibleなwebhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postGitHubWebhook(webhookID, body, options) {
        return exports.WebhookApiFp(this.configuration).postGitHubWebhook(webhookID, body, options)(this.axios, this.basePath);
    }
    /**
     * webhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {string} body
     * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
     * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options) {
        return exports.WebhookApiFp(this.configuration).postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのWebRTC状態を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getChannelWebRTCState(channelID, options) {
        return exports.WebrtcApiFp(this.configuration).getChannelWebRTCState(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 自身のWebRTCの状態を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getWebRTCState(options) {
        return exports.WebrtcApiFp(this.configuration).getWebRTCState(options)(this.axios, this.basePath);
    }
    /**
     * 自身のWebRTCの状態を変更します。
     * @param {PutWebRTCState} putWebRTCState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    putWebRTCState(putWebRTCState, options) {
        return exports.WebrtcApiFp(this.configuration).putWebRTCState(putWebRTCState, options)(this.axios, this.basePath);
    }
}
exports.Apis = Apis;
