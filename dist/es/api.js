// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * traQ API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.6.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as globalImportUrl from 'url';
import globalAxios from 'axios';
import { BASE_PATH, BaseAPI, RequiredError } from './base';
/**
    * @export
    * @enum {string}
    */
export var ChannelEventTypeEnum;
(function (ChannelEventTypeEnum) {
    ChannelEventTypeEnum["TopicChanged"] = "TopicChanged";
    ChannelEventTypeEnum["SubscribersChanged"] = "SubscribersChanged";
    ChannelEventTypeEnum["PinAdded"] = "PinAdded";
    ChannelEventTypeEnum["PinRemoved"] = "PinRemoved";
    ChannelEventTypeEnum["NameChanged"] = "NameChanged";
    ChannelEventTypeEnum["ParentChanged"] = "ParentChanged";
    ChannelEventTypeEnum["VisibilityChanged"] = "VisibilityChanged";
    ChannelEventTypeEnum["ForcedNotificationChanged"] = "ForcedNotificationChanged";
    ChannelEventTypeEnum["ChildCreated"] = "ChildCreated";
})(ChannelEventTypeEnum || (ChannelEventTypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
export var ClientScope;
(function (ClientScope) {
    ClientScope["Read"] = "read";
    ClientScope["Write"] = "write";
    ClientScope["ManageBot"] = "manage_bot";
})(ClientScope || (ClientScope = {}));
/**
 * editing,monitoring,noneのユーザーの状態
 * @export
 * @enum {string}
 */
export var HeartbeatStatus;
(function (HeartbeatStatus) {
    HeartbeatStatus["None"] = "none";
    HeartbeatStatus["Monitoring"] = "monitoring";
    HeartbeatStatus["Editing"] = "editing";
})(HeartbeatStatus || (HeartbeatStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
export var OAuth2Prompt;
(function (OAuth2Prompt) {
    OAuth2Prompt["None"] = "none";
})(OAuth2Prompt || (OAuth2Prompt = {}));
/**
 *
 * @export
 * @enum {string}
 */
export var OAuth2ResponseType;
(function (OAuth2ResponseType) {
    OAuth2ResponseType["Code"] = "code";
    OAuth2ResponseType["Token"] = "token";
    OAuth2ResponseType["None"] = "none";
})(OAuth2ResponseType || (OAuth2ResponseType = {}));
/**
 * アカウントの状態 (0:停止,1:有効,2:一時停止)
 * @export
 * @enum {string}
 */
export var UserStatus;
(function (UserStatus) {
    UserStatus[UserStatus["NUMBER_0"] = 0] = "NUMBER_0";
    UserStatus[UserStatus["NUMBER_1"] = 1] = "NUMBER_1";
    UserStatus[UserStatus["NUMBER_2"] = 2] = "NUMBER_2";
})(UserStatus || (UserStatus = {}));
/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLatestMessagesGet(limit, subscribe, options = {}) {
            const localVarPath = `/activity/latest-messages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (subscribe !== undefined) {
                localVarQueryParameter['subscribe'] = subscribe;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function (configuration) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLatestMessagesGet(limit, subscribe, options) {
            const localVarAxiosArgs = ActivityApiAxiosParamCreator(configuration).activityLatestMessagesGet(limit, subscribe, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityLatestMessagesGet(limit, subscribe, options) {
            return ActivityApiFp(configuration).activityLatestMessagesGet(limit, subscribe, options)(axios, basePath);
        },
    };
};
/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
     * @param {number} [limit] 取得する件数 1-50
     * @param {boolean} [subscribe] 購読チャンネルのみを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    activityLatestMessagesGet(limit, subscribe, options) {
        return ActivityApiFp(this.configuration).activityLatestMessagesGet(limit, subscribe, options)(this.axios, this.basePath);
    }
}
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {UserLogin} [userLogin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(redirect, userLogin, options = {}) {
            const localVarPath = `/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("UserLogin" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userLogin !== undefined ? userLogin : {}) : (userLogin || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost(redirect, options = {}) {
            const localVarPath = `/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {UserLogin} [userLogin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(redirect, userLogin, options) {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).loginPost(redirect, userLogin, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost(redirect, options) {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).logoutPost(redirect, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {UserLogin} [userLogin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(redirect, userLogin, options) {
            return AuthenticationApiFp(configuration).loginPost(redirect, userLogin, options)(axios, basePath);
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost(redirect, options) {
            return AuthenticationApiFp(configuration).logoutPost(redirect, options)(axios, basePath);
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
     * @param {string} [redirect] リダイレクト先
     * @param {UserLogin} [userLogin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    loginPost(redirect, userLogin, options) {
        return AuthenticationApiFp(this.configuration).loginPost(redirect, userLogin, options)(this.axios, this.basePath);
    }
    /**
     * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logoutPost(redirect, options) {
        return AuthenticationApiFp(this.configuration).logoutPost(redirect, options)(this.axios, this.basePath);
    }
}
/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeDecidePost(submit, options = {}) {
            // verify required parameter 'submit' is not null or undefined
            if (submit === null || submit === undefined) {
                throw new RequiredError('submit', 'Required parameter submit was null or undefined when calling oauth2AuthorizeDecidePost.');
            }
            const localVarPath = `/oauth2/authorize/decide`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication cookieAuth required
            if (submit !== undefined) {
                localVarFormParams.set('submit', submit);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [clientId]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options = {}) {
            const localVarPath = `/oauth2/authorize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }
            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            if (codeChallenge !== undefined) {
                localVarQueryParameter['code_challenge'] = codeChallenge;
            }
            if (codeChallengeMethod !== undefined) {
                localVarQueryParameter['code_challenge_method'] = codeChallengeMethod;
            }
            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }
            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [clientId]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options = {}) {
            const localVarPath = `/oauth2/authorize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (responseType !== undefined) {
                localVarFormParams.set('response_type', responseType);
            }
            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId);
            }
            if (redirectUri !== undefined) {
                localVarFormParams.set('redirect_uri', redirectUri);
            }
            if (scope !== undefined) {
                localVarFormParams.set('scope', scope);
            }
            if (state !== undefined) {
                localVarFormParams.set('state', state);
            }
            if (codeChallenge !== undefined) {
                localVarFormParams.set('code_challenge', codeChallenge);
            }
            if (codeChallengeMethod !== undefined) {
                localVarFormParams.set('code_challenge_method', codeChallengeMethod);
            }
            if (nonce !== undefined) {
                localVarFormParams.set('nonce', nonce);
            }
            if (prompt !== undefined) {
                localVarFormParams.set('prompt', prompt);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options = {}) {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType', 'Required parameter grantType was null or undefined when calling oauth2TokenPost.');
            }
            const localVarPath = `/oauth2/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType);
            }
            if (code !== undefined) {
                localVarFormParams.set('code', code);
            }
            if (redirectUri !== undefined) {
                localVarFormParams.set('redirect_uri', redirectUri);
            }
            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId);
            }
            if (codeVerifier !== undefined) {
                localVarFormParams.set('code_verifier', codeVerifier);
            }
            if (username !== undefined) {
                localVarFormParams.set('username', username);
            }
            if (password !== undefined) {
                localVarFormParams.set('password', password);
            }
            if (scope !== undefined) {
                localVarFormParams.set('scope', scope);
            }
            if (refreshToken !== undefined) {
                localVarFormParams.set('refresh_token', refreshToken);
            }
            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function (configuration) {
    return {
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeDecidePost(submit, options) {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).oauth2AuthorizeDecidePost(submit, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [clientId]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [clientId]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeDecidePost(submit, options) {
            return AuthorizationApiFp(configuration).oauth2AuthorizeDecidePost(submit, options)(axios, basePath);
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [clientId]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            return AuthorizationApiFp(configuration).oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(axios, basePath);
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [clientId]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            return AuthorizationApiFp(configuration).oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(axios, basePath);
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
            return AuthorizationApiFp(configuration).oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(axios, basePath);
        },
    };
};
/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     * OAuth2 認可承諾
     * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    oauth2AuthorizeDecidePost(submit, options) {
        return AuthorizationApiFp(this.configuration).oauth2AuthorizeDecidePost(submit, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [clientId]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return AuthorizationApiFp(this.configuration).oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [clientId]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return AuthorizationApiFp(this.configuration).oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 トークンエンドポイント
     * @param {string} grantType
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [clientId]
     * @param {string} [codeVerifier]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [scope]
     * @param {string} [refreshToken]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
        return AuthorizationApiFp(this.configuration).oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(this.axios, this.basePath);
    }
}
/**
 * BotApi - axios parameter creator
 * @export
 */
export const BotApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDChannelsGet(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDChannelsGet.');
            }
            const localVarPath = `/bots/{botID}/channels`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDDelete(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDDelete.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDDetailGet(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDDetailGet.');
            }
            const localVarPath = `/bots/{botID}/detail`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} [putBotEvents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDEventsPut(botID, putBotEvents, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDEventsPut.');
            }
            const localVarPath = `/bots/{botID}/events`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PutBotEvents" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putBotEvents !== undefined ? putBotEvents : {}) : (putBotEvents || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDGet(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDGet.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDIconGet(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDIconGet.');
            }
            const localVarPath = `/bots/{botID}/icon`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDIconPut(botID, file, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDIconPut.');
            }
            const localVarPath = `/bots/{botID}/icon`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} [patchBot]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDPatch(botID, patchBot, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDPatch.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchBot" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchBot !== undefined ? patchBot : {}) : (patchBot || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDReissuePost(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDReissuePost.');
            }
            const localVarPath = `/bots/{botID}/reissue`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} [putBotState]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDStatePut(botID, putBotState, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling botsBotIDStatePut.');
            }
            const localVarPath = `/bots/{botID}/state`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PutBotState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putBotState !== undefined ? putBotState : {}) : (putBotState || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGet(options = {}) {
            const localVarPath = `/bots`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを作成します。
         * @param {PostBot} [postBot]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPost(postBot, options = {}) {
            const localVarPath = `/bots`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostBot" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBot !== undefined ? postBot : {}) : (postBot || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsBotIDDelete(channelID, botID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDBotsBotIDDelete.');
            }
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling channelsChannelIDBotsBotIDDelete.');
            }
            const localVarPath = `/channels/{channelID}/bots/{botID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)))
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsGet(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDBotsGet.');
            }
            const localVarPath = `/channels/{channelID}/bots`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} [postBotChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsPost(channelID, postBotChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDBotsPost.');
            }
            const localVarPath = `/channels/{channelID}/bots`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostBotChannel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBotChannel !== undefined ? postBotChannel : {}) : (postBotChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BotApi - functional programming interface
 * @export
 */
export const BotApiFp = function (configuration) {
    return {
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDChannelsGet(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDChannelsGet(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDDelete(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDDelete(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDDetailGet(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDDetailGet(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} [putBotEvents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDEventsPut(botID, putBotEvents, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDEventsPut(botID, putBotEvents, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDGet(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDGet(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDIconGet(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDIconGet(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDIconPut(botID, file, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDIconPut(botID, file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} [patchBot]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDPatch(botID, patchBot, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDPatch(botID, patchBot, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDReissuePost(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDReissuePost(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} [putBotState]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDStatePut(botID, putBotState, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsBotIDStatePut(botID, putBotState, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGet(options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを作成します。
         * @param {PostBot} [postBot]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPost(postBot, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).botsPost(postBot, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsBotIDDelete(channelID, botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).channelsChannelIDBotsBotIDDelete(channelID, botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsGet(channelID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).channelsChannelIDBotsGet(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} [postBotChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsPost(channelID, postBotChannel, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).channelsChannelIDBotsPost(channelID, postBotChannel, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * BotApi - factory interface
 * @export
 */
export const BotApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDChannelsGet(botID, options) {
            return BotApiFp(configuration).botsBotIDChannelsGet(botID, options)(axios, basePath);
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDDelete(botID, options) {
            return BotApiFp(configuration).botsBotIDDelete(botID, options)(axios, basePath);
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDDetailGet(botID, options) {
            return BotApiFp(configuration).botsBotIDDetailGet(botID, options)(axios, basePath);
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} [putBotEvents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDEventsPut(botID, putBotEvents, options) {
            return BotApiFp(configuration).botsBotIDEventsPut(botID, putBotEvents, options)(axios, basePath);
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDGet(botID, options) {
            return BotApiFp(configuration).botsBotIDGet(botID, options)(axios, basePath);
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDIconGet(botID, options) {
            return BotApiFp(configuration).botsBotIDIconGet(botID, options)(axios, basePath);
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDIconPut(botID, file, options) {
            return BotApiFp(configuration).botsBotIDIconPut(botID, file, options)(axios, basePath);
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} [patchBot]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDPatch(botID, patchBot, options) {
            return BotApiFp(configuration).botsBotIDPatch(botID, patchBot, options)(axios, basePath);
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDReissuePost(botID, options) {
            return BotApiFp(configuration).botsBotIDReissuePost(botID, options)(axios, basePath);
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} [putBotState]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBotIDStatePut(botID, putBotState, options) {
            return BotApiFp(configuration).botsBotIDStatePut(botID, putBotState, options)(axios, basePath);
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGet(options) {
            return BotApiFp(configuration).botsGet(options)(axios, basePath);
        },
        /**
         * Botを作成します。
         * @param {PostBot} [postBot]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPost(postBot, options) {
            return BotApiFp(configuration).botsPost(postBot, options)(axios, basePath);
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsBotIDDelete(channelID, botID, options) {
            return BotApiFp(configuration).channelsChannelIDBotsBotIDDelete(channelID, botID, options)(axios, basePath);
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsGet(channelID, options) {
            return BotApiFp(configuration).channelsChannelIDBotsGet(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} [postBotChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDBotsPost(channelID, postBotChannel, options) {
            return BotApiFp(configuration).channelsChannelIDBotsPost(channelID, postBotChannel, options)(axios, basePath);
        },
    };
};
/**
 * BotApi - object-oriented interface
 * @export
 * @class BotApi
 * @extends {BaseAPI}
 */
export class BotApi extends BaseAPI {
    /**
     * Botが参加しているチャンネルのUUIDの配列を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDChannelsGet(botID, options) {
        return BotApiFp(this.configuration).botsBotIDChannelsGet(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botを削除します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDDelete(botID, options) {
        return BotApiFp(this.configuration).botsBotIDDelete(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの詳細を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDDetailGet(botID, options) {
        return BotApiFp(this.configuration).botsBotIDDetailGet(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの購読イベントを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotEvents} [putBotEvents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDEventsPut(botID, putBotEvents, options) {
        return BotApiFp(this.configuration).botsBotIDEventsPut(botID, putBotEvents, options)(this.axios, this.basePath);
    }
    /**
     * Botを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDGet(botID, options) {
        return BotApiFp(this.configuration).botsBotIDGet(botID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDIconGet(botID, options) {
        return BotApiFp(this.configuration).botsBotIDIconGet(botID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDIconPut(botID, file, options) {
        return BotApiFp(this.configuration).botsBotIDIconPut(botID, file, options)(this.axios, this.basePath);
    }
    /**
     * Bot情報を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PatchBot} [patchBot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDPatch(botID, patchBot, options) {
        return BotApiFp(this.configuration).botsBotIDPatch(botID, patchBot, options)(this.axios, this.basePath);
    }
    /**
     * Botの各種トークンを再発行します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDReissuePost(botID, options) {
        return BotApiFp(this.configuration).botsBotIDReissuePost(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの状態を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotState} [putBotState]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDStatePut(botID, putBotState, options) {
        return BotApiFp(this.configuration).botsBotIDStatePut(botID, putBotState, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したBotの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsGet(options) {
        return BotApiFp(this.configuration).botsGet(options)(this.axios, this.basePath);
    }
    /**
     * Botを作成します。
     * @param {PostBot} [postBot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsPost(postBot, options) {
        return BotApiFp(this.configuration).botsPost(postBot, options)(this.axios, this.basePath);
    }
    /**
     * Botをチャンネルから退出させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    channelsChannelIDBotsBotIDDelete(channelID, botID, options) {
        return BotApiFp(this.configuration).channelsChannelIDBotsBotIDDelete(channelID, botID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに参加しているBot一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    channelsChannelIDBotsGet(channelID, options) {
        return BotApiFp(this.configuration).channelsChannelIDBotsGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにBotを参加させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PostBotChannel} [postBotChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    channelsChannelIDBotsPost(channelID, postBotChannel, options) {
        return BotApiFp(this.configuration).channelsChannelIDBotsPost(channelID, postBotChannel, options)(this.axios, this.basePath);
    }
}
/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} [createChannelChild]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDChildrenPost(channelID, createChannelChild, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDChildrenPost.');
            }
            const localVarPath = `/channels/{channelID}/children`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("CreateChannelChild" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createChannelChild !== undefined ? createChannelChild : {}) : (createChannelChild || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDDelete(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDDelete.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDEventsGet.');
            }
            const localVarPath = `/channels/{channelID}/events`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDGet(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDGet.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} [putParentChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDParentPut(channelID, putParentChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDParentPut.');
            }
            const localVarPath = `/channels/{channelID}/parent`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PutParentChannel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putParentChannel !== undefined ? putParentChannel : {}) : (putParentChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} [patchChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDPatch(channelID, patchChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDPatch.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchChannel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchChannel !== undefined ? patchChannel : {}) : (patchChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDTopicGet(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDTopicGet.');
            }
            const localVarPath = `/channels/{channelID}/topic`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} [setChannelTopic]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDTopicPut(channelID, setChannelTopic, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDTopicPut.');
            }
            const localVarPath = `/channels/{channelID}/topic`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SetChannelTopic" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setChannelTopic !== undefined ? setChannelTopic : {}) : (setChannelTopic || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsGet(options = {}) {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} [createChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsPost(createChannel, options = {}) {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("CreateChannel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createChannel !== undefined ? createChannel : {}) : (createChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function (configuration) {
    return {
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} [createChannelChild]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDChildrenPost(channelID, createChannelChild, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsChannelIDChildrenPost(channelID, createChannelChild, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDDelete(channelID, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsChannelIDDelete(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDGet(channelID, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsChannelIDGet(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} [putParentChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDParentPut(channelID, putParentChannel, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsChannelIDParentPut(channelID, putParentChannel, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} [patchChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDPatch(channelID, patchChannel, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsChannelIDPatch(channelID, patchChannel, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDTopicGet(channelID, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsChannelIDTopicGet(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} [setChannelTopic]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDTopicPut(channelID, setChannelTopic, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsChannelIDTopicPut(channelID, setChannelTopic, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsGet(options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} [createChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsPost(createChannel, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).channelsPost(createChannel, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} [createChannelChild]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDChildrenPost(channelID, createChannelChild, options) {
            return ChannelApiFp(configuration).channelsChannelIDChildrenPost(channelID, createChannelChild, options)(axios, basePath);
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDDelete(channelID, options) {
            return ChannelApiFp(configuration).channelsChannelIDDelete(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options) {
            return ChannelApiFp(configuration).channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDGet(channelID, options) {
            return ChannelApiFp(configuration).channelsChannelIDGet(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} [putParentChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDParentPut(channelID, putParentChannel, options) {
            return ChannelApiFp(configuration).channelsChannelIDParentPut(channelID, putParentChannel, options)(axios, basePath);
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} [patchChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDPatch(channelID, patchChannel, options) {
            return ChannelApiFp(configuration).channelsChannelIDPatch(channelID, patchChannel, options)(axios, basePath);
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDTopicGet(channelID, options) {
            return ChannelApiFp(configuration).channelsChannelIDTopicGet(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} [setChannelTopic]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDTopicPut(channelID, setChannelTopic, options) {
            return ChannelApiFp(configuration).channelsChannelIDTopicPut(channelID, setChannelTopic, options)(axios, basePath);
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsGet(options) {
            return ChannelApiFp(configuration).channelsGet(options)(axios, basePath);
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} [createChannel]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsPost(createChannel, options) {
            return ChannelApiFp(configuration).channelsPost(createChannel, options)(axios, basePath);
        },
    };
};
/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
    /**
     * 子チャンネルを作成します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {CreateChannelChild} [createChannelChild]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDChildrenPost(channelID, createChannelChild, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDChildrenPost(channelID, createChannelChild, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを削除します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDDelete(channelID, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDDelete(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルイベントのリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDGet(channelID, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの親チャンネルを変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PutParentChannel} [putParentChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDParentPut(channelID, putParentChannel, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDParentPut(channelID, putParentChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PatchChannel} [patchChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDPatch(channelID, patchChannel, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDPatch(channelID, patchChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDTopicGet(channelID, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDTopicGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SetChannelTopic} [setChannelTopic]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDTopicPut(channelID, setChannelTopic, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDTopicPut(channelID, setChannelTopic, options)(this.axios, this.basePath);
    }
    /**
     * (すべての)チャンネルのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsGet(options) {
        return ChannelApiFp(this.configuration).channelsGet(options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを作成します。
     * @param {CreateChannel} [createChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsPost(createChannel, options) {
        return ChannelApiFp(this.configuration).channelsPost(createChannel, options)(this.axios, this.basePath);
    }
}
/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDDelete(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new RequiredError('clientID', 'Required parameter clientID was null or undefined when calling clientsClientIDDelete.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDDetailGet(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new RequiredError('clientID', 'Required parameter clientID was null or undefined when calling clientsClientIDDetailGet.');
            }
            const localVarPath = `/clients/{clientID}/detail`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDGet(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new RequiredError('clientID', 'Required parameter clientID was null or undefined when calling clientsClientIDGet.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} [patchClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDPatch(clientID, patchClient, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new RequiredError('clientID', 'Required parameter clientID was null or undefined when calling clientsClientIDPatch.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchClient" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchClient !== undefined ? patchClient : {}) : (patchClient || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGet(options = {}) {
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クライアントを登録します。
         * @param {PostClient} [postClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsPost(postClient, options = {}) {
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostClient" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postClient !== undefined ? postClient : {}) : (postClient || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeTokensGet(options = {}) {
            const localVarPath = `/users/me/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options = {}) {
            // verify required parameter 'oauth2TokenID' is not null or undefined
            if (oauth2TokenID === null || oauth2TokenID === undefined) {
                throw new RequiredError('oauth2TokenID', 'Required parameter oauth2TokenID was null or undefined when calling usersMeTokensOauth2TokenIDDelete.');
            }
            const localVarPath = `/users/me/tokens/{oauth2TokenID}`
                .replace(`{${"oauth2TokenID"}}`, encodeURIComponent(String(oauth2TokenID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function (configuration) {
    return {
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDDelete(clientID, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).clientsClientIDDelete(clientID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDDetailGet(clientID, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).clientsClientIDDetailGet(clientID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDGet(clientID, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).clientsClientIDGet(clientID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} [patchClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDPatch(clientID, patchClient, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).clientsClientIDPatch(clientID, patchClient, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGet(options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).clientsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クライアントを登録します。
         * @param {PostClient} [postClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsPost(postClient, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).clientsPost(postClient, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeTokensGet(options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).usersMeTokensGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDDelete(clientID, options) {
            return ClientApiFp(configuration).clientsClientIDDelete(clientID, options)(axios, basePath);
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDDetailGet(clientID, options) {
            return ClientApiFp(configuration).clientsClientIDDetailGet(clientID, options)(axios, basePath);
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDGet(clientID, options) {
            return ClientApiFp(configuration).clientsClientIDGet(clientID, options)(axios, basePath);
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} [patchClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsClientIDPatch(clientID, patchClient, options) {
            return ClientApiFp(configuration).clientsClientIDPatch(clientID, patchClient, options)(axios, basePath);
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGet(options) {
            return ClientApiFp(configuration).clientsGet(options)(axios, basePath);
        },
        /**
         * クライアントを登録します。
         * @param {PostClient} [postClient]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsPost(postClient, options) {
            return ClientApiFp(configuration).clientsPost(postClient, options)(axios, basePath);
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeTokensGet(options) {
            return ClientApiFp(configuration).usersMeTokensGet(options)(axios, basePath);
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options) {
            return ClientApiFp(configuration).usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options)(axios, basePath);
        },
    };
};
/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsClientIDDelete(clientID, options) {
        return ClientApiFp(this.configuration).clientsClientIDDelete(clientID, options)(this.axios, this.basePath);
    }
    /**
     * クライアントの詳細を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsClientIDDetailGet(clientID, options) {
        return ClientApiFp(this.configuration).clientsClientIDDetailGet(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsClientIDGet(clientID, options) {
        return ClientApiFp(this.configuration).clientsClientIDGet(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を変更します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {PatchClient} [patchClient]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsClientIDPatch(clientID, patchClient, options) {
        return ClientApiFp(this.configuration).clientsClientIDPatch(clientID, patchClient, options)(this.axios, this.basePath);
    }
    /**
     * 自分が登録しているクライアントの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsGet(options) {
        return ClientApiFp(this.configuration).clientsGet(options)(this.axios, this.basePath);
    }
    /**
     * クライアントを登録します。
     * @param {PostClient} [postClient]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsPost(postClient, options) {
        return ClientApiFp(this.configuration).clientsPost(postClient, options)(this.axios, this.basePath);
    }
    /**
     * 自分が許可しているクライアントの一覧とトークン情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    usersMeTokensGet(options) {
        return ClientApiFp(this.configuration).usersMeTokensGet(options)(this.axios, this.basePath);
    }
    /**
     * 指定したトークンの認可を取り消します。
     * @param {string} oauth2TokenID 操作の対象となるTokenのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options) {
        return ClientApiFp(this.configuration).usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options)(this.axios, this.basePath);
    }
}
/**
 * ClipApi - axios parameter creator
 * @export
 */
export const ClipApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したクリップを削除します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDDelete(clipID, options = {}) {
            // verify required parameter 'clipID' is not null or undefined
            if (clipID === null || clipID === undefined) {
                throw new RequiredError('clipID', 'Required parameter clipID was null or undefined when calling usersMeClipsClipIDDelete.');
            }
            const localVarPath = `/users/me/clips/{clipID}`
                .replace(`{${"clipID"}}`, encodeURIComponent(String(clipID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクリップのフォルダ情報を取得します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDFolderGet(clipID, options = {}) {
            // verify required parameter 'clipID' is not null or undefined
            if (clipID === null || clipID === undefined) {
                throw new RequiredError('clipID', 'Required parameter clipID was null or undefined when calling usersMeClipsClipIDFolderGet.');
            }
            const localVarPath = `/users/me/clips/{clipID}/folder`
                .replace(`{${"clipID"}}`, encodeURIComponent(String(clipID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクリップのフォルダを変更します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {ClipsFolderIDObject} [clipsFolderIDObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options = {}) {
            // verify required parameter 'clipID' is not null or undefined
            if (clipID === null || clipID === undefined) {
                throw new RequiredError('clipID', 'Required parameter clipID was null or undefined when calling usersMeClipsClipIDFolderPut.');
            }
            const localVarPath = `/users/me/clips/{clipID}/folder`
                .replace(`{${"clipID"}}`, encodeURIComponent(String(clipID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("ClipsFolderIDObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(clipsFolderIDObject !== undefined ? clipsFolderIDObject : {}) : (clipsFolderIDObject || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクリップのメッセージを取得します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDGet(clipID, options = {}) {
            // verify required parameter 'clipID' is not null or undefined
            if (clipID === null || clipID === undefined) {
                throw new RequiredError('clipID', 'Required parameter clipID was null or undefined when calling usersMeClipsClipIDGet.');
            }
            const localVarPath = `/users/me/clips/{clipID}`
                .replace(`{${"clipID"}}`, encodeURIComponent(String(clipID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クリップフォルダを削除します。フォルダ内のクリップは全て削除されます。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDDelete(folderID, options = {}) {
            // verify required parameter 'folderID' is not null or undefined
            if (folderID === null || folderID === undefined) {
                throw new RequiredError('folderID', 'Required parameter folderID was null or undefined when calling usersMeClipsFoldersFolderIDDelete.');
            }
            const localVarPath = `/users/me/clips/folders/{folderID}`
                .replace(`{${"folderID"}}`, encodeURIComponent(String(folderID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フォルダ内のクリップ一覧を取得します。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDGet(folderID, options = {}) {
            // verify required parameter 'folderID' is not null or undefined
            if (folderID === null || folderID === undefined) {
                throw new RequiredError('folderID', 'Required parameter folderID was null or undefined when calling usersMeClipsFoldersFolderIDGet.');
            }
            const localVarPath = `/users/me/clips/folders/{folderID}`
                .replace(`{${"folderID"}}`, encodeURIComponent(String(folderID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クリップフォルダ名を変更します。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {ClipsFolderNameObject} [clipsFolderNameObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options = {}) {
            // verify required parameter 'folderID' is not null or undefined
            if (folderID === null || folderID === undefined) {
                throw new RequiredError('folderID', 'Required parameter folderID was null or undefined when calling usersMeClipsFoldersFolderIDPatch.');
            }
            const localVarPath = `/users/me/clips/folders/{folderID}`
                .replace(`{${"folderID"}}`, encodeURIComponent(String(folderID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("ClipsFolderNameObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(clipsFolderNameObject !== undefined ? clipsFolderNameObject : {}) : (clipsFolderNameObject || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クリップフォルダ一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersGet(options = {}) {
            const localVarPath = `/users/me/clips/folders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クリップフォルダを作成します。
         * @param {ClipsFolderNameObject} [clipsFolderNameObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersPost(clipsFolderNameObject, options = {}) {
            const localVarPath = `/users/me/clips/folders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("ClipsFolderNameObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(clipsFolderNameObject !== undefined ? clipsFolderNameObject : {}) : (clipsFolderNameObject || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 全てのクリップを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsGet(options = {}) {
            const localVarPath = `/users/me/clips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しくメッセージをクリップします。
         * @param {SetClip} [setClip]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsPost(setClip, options = {}) {
            const localVarPath = `/users/me/clips`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SetClip" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setClip !== undefined ? setClip : {}) : (setClip || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ClipApi - functional programming interface
 * @export
 */
export const ClipApiFp = function (configuration) {
    return {
        /**
         * 指定したクリップを削除します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDDelete(clipID, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsClipIDDelete(clipID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクリップのフォルダ情報を取得します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDFolderGet(clipID, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsClipIDFolderGet(clipID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクリップのフォルダを変更します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {ClipsFolderIDObject} [clipsFolderIDObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクリップのメッセージを取得します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDGet(clipID, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsClipIDGet(clipID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クリップフォルダを削除します。フォルダ内のクリップは全て削除されます。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDDelete(folderID, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsFoldersFolderIDDelete(folderID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * フォルダ内のクリップ一覧を取得します。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDGet(folderID, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsFoldersFolderIDGet(folderID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クリップフォルダ名を変更します。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {ClipsFolderNameObject} [clipsFolderNameObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クリップフォルダ一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersGet(options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsFoldersGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クリップフォルダを作成します。
         * @param {ClipsFolderNameObject} [clipsFolderNameObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersPost(clipsFolderNameObject, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsFoldersPost(clipsFolderNameObject, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 全てのクリップを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsGet(options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 新しくメッセージをクリップします。
         * @param {SetClip} [setClip]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsPost(setClip, options) {
            const localVarAxiosArgs = ClipApiAxiosParamCreator(configuration).usersMeClipsPost(setClip, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ClipApi - factory interface
 * @export
 */
export const ClipApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したクリップを削除します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDDelete(clipID, options) {
            return ClipApiFp(configuration).usersMeClipsClipIDDelete(clipID, options)(axios, basePath);
        },
        /**
         * 指定したクリップのフォルダ情報を取得します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDFolderGet(clipID, options) {
            return ClipApiFp(configuration).usersMeClipsClipIDFolderGet(clipID, options)(axios, basePath);
        },
        /**
         * 指定したクリップのフォルダを変更します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {ClipsFolderIDObject} [clipsFolderIDObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options) {
            return ClipApiFp(configuration).usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options)(axios, basePath);
        },
        /**
         * 指定したクリップのメッセージを取得します。
         * @param {string} clipID 捜査の対象となるクリップのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsClipIDGet(clipID, options) {
            return ClipApiFp(configuration).usersMeClipsClipIDGet(clipID, options)(axios, basePath);
        },
        /**
         * クリップフォルダを削除します。フォルダ内のクリップは全て削除されます。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDDelete(folderID, options) {
            return ClipApiFp(configuration).usersMeClipsFoldersFolderIDDelete(folderID, options)(axios, basePath);
        },
        /**
         * フォルダ内のクリップ一覧を取得します。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDGet(folderID, options) {
            return ClipApiFp(configuration).usersMeClipsFoldersFolderIDGet(folderID, options)(axios, basePath);
        },
        /**
         * クリップフォルダ名を変更します。
         * @param {string} folderID 操作の対象となるクリップフォルダのID
         * @param {ClipsFolderNameObject} [clipsFolderNameObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options) {
            return ClipApiFp(configuration).usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options)(axios, basePath);
        },
        /**
         * クリップフォルダ一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersGet(options) {
            return ClipApiFp(configuration).usersMeClipsFoldersGet(options)(axios, basePath);
        },
        /**
         * クリップフォルダを作成します。
         * @param {ClipsFolderNameObject} [clipsFolderNameObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsFoldersPost(clipsFolderNameObject, options) {
            return ClipApiFp(configuration).usersMeClipsFoldersPost(clipsFolderNameObject, options)(axios, basePath);
        },
        /**
         * 全てのクリップを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsGet(options) {
            return ClipApiFp(configuration).usersMeClipsGet(options)(axios, basePath);
        },
        /**
         * 新しくメッセージをクリップします。
         * @param {SetClip} [setClip]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeClipsPost(setClip, options) {
            return ClipApiFp(configuration).usersMeClipsPost(setClip, options)(axios, basePath);
        },
    };
};
/**
 * ClipApi - object-oriented interface
 * @export
 * @class ClipApi
 * @extends {BaseAPI}
 */
export class ClipApi extends BaseAPI {
    /**
     * 指定したクリップを削除します。
     * @param {string} clipID 捜査の対象となるクリップのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsClipIDDelete(clipID, options) {
        return ClipApiFp(this.configuration).usersMeClipsClipIDDelete(clipID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップのフォルダ情報を取得します。
     * @param {string} clipID 捜査の対象となるクリップのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsClipIDFolderGet(clipID, options) {
        return ClipApiFp(this.configuration).usersMeClipsClipIDFolderGet(clipID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップのフォルダを変更します。
     * @param {string} clipID 捜査の対象となるクリップのID
     * @param {ClipsFolderIDObject} [clipsFolderIDObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options) {
        return ClipApiFp(this.configuration).usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップのメッセージを取得します。
     * @param {string} clipID 捜査の対象となるクリップのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsClipIDGet(clipID, options) {
        return ClipApiFp(this.configuration).usersMeClipsClipIDGet(clipID, options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダを削除します。フォルダ内のクリップは全て削除されます。
     * @param {string} folderID 操作の対象となるクリップフォルダのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersFolderIDDelete(folderID, options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersFolderIDDelete(folderID, options)(this.axios, this.basePath);
    }
    /**
     * フォルダ内のクリップ一覧を取得します。
     * @param {string} folderID 操作の対象となるクリップフォルダのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersFolderIDGet(folderID, options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersFolderIDGet(folderID, options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダ名を変更します。
     * @param {string} folderID 操作の対象となるクリップフォルダのID
     * @param {ClipsFolderNameObject} [clipsFolderNameObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダ一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersGet(options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersGet(options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダを作成します。
     * @param {ClipsFolderNameObject} [clipsFolderNameObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersPost(clipsFolderNameObject, options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersPost(clipsFolderNameObject, options)(this.axios, this.basePath);
    }
    /**
     * 全てのクリップを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsGet(options) {
        return ClipApiFp(this.configuration).usersMeClipsGet(options)(this.axios, this.basePath);
    }
    /**
     * 新しくメッセージをクリップします。
     * @param {SetClip} [setClip]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsPost(setClip, options) {
        return ClipApiFp(this.configuration).usersMeClipsPost(setClip, options)(this.axios, this.basePath);
    }
}
/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDDelete(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID', 'Required parameter fileID was null or undefined when calling filesFileIDDelete.');
            }
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDGet(fileID, dl, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID', 'Required parameter fileID was null or undefined when calling filesFileIDGet.');
            }
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (dl !== undefined) {
                localVarQueryParameter['dl'] = dl;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDMetaGet(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID', 'Required parameter fileID was null or undefined when calling filesFileIDMetaGet.');
            }
            const localVarPath = `/files/{fileID}/meta`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDThumbnailGet(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID', 'Required parameter fileID was null or undefined when calling filesFileIDThumbnailGet.');
            }
            const localVarPath = `/files/{fileID}/thumbnail`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost(file, aclReadable, options = {}) {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling filesPost.');
            }
            const localVarPath = `/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (aclReadable !== undefined) {
                localVarFormParams.append('acl_readable', aclReadable);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function (configuration) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDDelete(fileID, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).filesFileIDDelete(fileID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDGet(fileID, dl, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).filesFileIDGet(fileID, dl, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDMetaGet(fileID, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).filesFileIDMetaGet(fileID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDThumbnailGet(fileID, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).filesFileIDThumbnailGet(fileID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost(file, aclReadable, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).filesPost(file, aclReadable, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDDelete(fileID, options) {
            return FileApiFp(configuration).filesFileIDDelete(fileID, options)(axios, basePath);
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDGet(fileID, dl, options) {
            return FileApiFp(configuration).filesFileIDGet(fileID, dl, options)(axios, basePath);
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDMetaGet(fileID, options) {
            return FileApiFp(configuration).filesFileIDMetaGet(fileID, options)(axios, basePath);
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesFileIDThumbnailGet(fileID, options) {
            return FileApiFp(configuration).filesFileIDThumbnailGet(fileID, options)(axios, basePath);
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost(file, aclReadable, options) {
            return FileApiFp(configuration).filesPost(file, aclReadable, options)(axios, basePath);
        },
    };
};
/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * 指定したファイルを削除します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesFileIDDelete(fileID, options) {
        return FileApiFp(this.configuration).filesFileIDDelete(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルの中身を取得します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesFileIDGet(fileID, dl, options) {
        return FileApiFp(this.configuration).filesFileIDGet(fileID, dl, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのメタデータを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesFileIDMetaGet(fileID, options) {
        return FileApiFp(this.configuration).filesFileIDMetaGet(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのサムネイルを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesFileIDThumbnailGet(fileID, options) {
        return FileApiFp(this.configuration).filesFileIDThumbnailGet(fileID, options)(this.axios, this.basePath);
    }
    /**
     * ファイルをアップロードします
     * @param {any} file ファイル本体
     * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesPost(file, aclReadable, options) {
        return FileApiFp(this.configuration).filesPost(file, aclReadable, options)(this.axios, this.basePath);
    }
}
/**
 * HeartbeatApi - axios parameter creator
 * @export
 */
export const HeartbeatApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatGet(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId', 'Required parameter channelId was null or undefined when calling heartbeatGet.');
            }
            const localVarPath = `/heartbeat`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} [heartbeat]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatPost(heartbeat, options = {}) {
            const localVarPath = `/heartbeat`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("Heartbeat" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(heartbeat !== undefined ? heartbeat : {}) : (heartbeat || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * HeartbeatApi - functional programming interface
 * @export
 */
export const HeartbeatApiFp = function (configuration) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatGet(channelId, options) {
            const localVarAxiosArgs = HeartbeatApiAxiosParamCreator(configuration).heartbeatGet(channelId, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} [heartbeat]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatPost(heartbeat, options) {
            const localVarAxiosArgs = HeartbeatApiAxiosParamCreator(configuration).heartbeatPost(heartbeat, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * HeartbeatApi - factory interface
 * @export
 */
export const HeartbeatApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatGet(channelId, options) {
            return HeartbeatApiFp(configuration).heartbeatGet(channelId, options)(axios, basePath);
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} [heartbeat]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatPost(heartbeat, options) {
            return HeartbeatApiFp(configuration).heartbeatPost(heartbeat, options)(axios, basePath);
        },
    };
};
/**
 * HeartbeatApi - object-oriented interface
 * @export
 * @class HeartbeatApi
 * @extends {BaseAPI}
 */
export class HeartbeatApi extends BaseAPI {
    /**
     * チャンネルを現在見ている人・編集している人を取得します。
     * @param {string} channelId 現在いるチャンネルId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    heartbeatGet(channelId, options) {
        return HeartbeatApiFp(this.configuration).heartbeatGet(channelId, options)(this.axios, this.basePath);
    }
    /**
     * どのチャンネルを見ているか・編集しているかを送信します。
     * @param {Heartbeat} [heartbeat]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    heartbeatPost(heartbeat, options) {
        return HeartbeatApiFp(this.configuration).heartbeatPost(heartbeat, options)(this.axios, this.basePath);
    }
}
/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDMessagesGet.');
            }
            const localVarPath = `/channels/{channelID}/messages`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDMessagesPost(channelID, sendMessage, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDMessagesPost.');
            }
            const localVarPath = `/channels/{channelID}/messages`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SendMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDDelete(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling messagesMessageIDDelete.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDGet(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling messagesMessageIDGet.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDPut(messageID, sendMessage, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling messagesMessageIDPut.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SendMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} [reportMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDReportPost(messageID, reportMessage, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling messagesMessageIDReportPost.');
            }
            const localVarPath = `/messages/{messageID}/report`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("ReportMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(reportMessage !== undefined ? reportMessage : {}) : (reportMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesReportsGet(p, options = {}) {
            const localVarPath = `/messages/reports`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            if (p !== undefined) {
                localVarQueryParameter['p'] = p;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDMessagesGet.');
            }
            const localVarPath = `/users/{userID}/messages`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDMessagesPost(userID, sendMessage, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDMessagesPost.');
            }
            const localVarPath = `/users/{userID}/messages`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SendMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function (configuration) {
    return {
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDMessagesPost(channelID, sendMessage, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).channelsChannelIDMessagesPost(channelID, sendMessage, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDDelete(messageID, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).messagesMessageIDDelete(messageID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDGet(messageID, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).messagesMessageIDGet(messageID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDPut(messageID, sendMessage, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).messagesMessageIDPut(messageID, sendMessage, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} [reportMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDReportPost(messageID, reportMessage, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).messagesMessageIDReportPost(messageID, reportMessage, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesReportsGet(p, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).messagesReportsGet(p, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDMessagesPost(userID, sendMessage, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).usersUserIDMessagesPost(userID, sendMessage, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options) {
            return MessageApiFp(configuration).channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDMessagesPost(channelID, sendMessage, options) {
            return MessageApiFp(configuration).channelsChannelIDMessagesPost(channelID, sendMessage, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDDelete(messageID, options) {
            return MessageApiFp(configuration).messagesMessageIDDelete(messageID, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDGet(messageID, options) {
            return MessageApiFp(configuration).messagesMessageIDGet(messageID, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDPut(messageID, sendMessage, options) {
            return MessageApiFp(configuration).messagesMessageIDPut(messageID, sendMessage, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} [reportMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDReportPost(messageID, reportMessage, options) {
            return MessageApiFp(configuration).messagesMessageIDReportPost(messageID, reportMessage, options)(axios, basePath);
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesReportsGet(p, options) {
            return MessageApiFp(configuration).messagesReportsGet(p, options)(axios, basePath);
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options) {
            return MessageApiFp(configuration).usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} [sendMessage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDMessagesPost(userID, sendMessage, options) {
            return MessageApiFp(configuration).usersUserIDMessagesPost(userID, sendMessage, options)(axios, basePath);
        },
    };
};
/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * チャンネルに存在するメッセージを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options) {
        return MessageApiFp(this.configuration).channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージを投稿します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SendMessage} [sendMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    channelsChannelIDMessagesPost(channelID, sendMessage, options) {
        return MessageApiFp(this.configuration).channelsChannelIDMessagesPost(channelID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを削除します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesMessageIDDelete(messageID, options) {
        return MessageApiFp(this.configuration).messagesMessageIDDelete(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesMessageIDGet(messageID, options) {
        return MessageApiFp(this.configuration).messagesMessageIDGet(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを編集します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {SendMessage} [sendMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesMessageIDPut(messageID, sendMessage, options) {
        return MessageApiFp(this.configuration).messagesMessageIDPut(messageID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを通報します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {ReportMessage} [reportMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesMessageIDReportPost(messageID, reportMessage, options) {
        return MessageApiFp(this.configuration).messagesMessageIDReportPost(messageID, reportMessage, options)(this.axios, this.basePath);
    }
    /**
     * メッセージ通報を最大50件取得します。
     * @param {number} [p] ページ番号(ゼロオリジン)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesReportsGet(p, options) {
        return MessageApiFp(this.configuration).messagesReportsGet(p, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルに存在するメッセージを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options) {
        return MessageApiFp(this.configuration).usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルにメッセージを投稿します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SendMessage} [sendMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    usersUserIDMessagesPost(userID, sendMessage, options) {
        return MessageApiFp(this.configuration).usersUserIDMessagesPost(userID, sendMessage, options)(this.axios, this.basePath);
    }
}
/**
 * MuteApi - axios parameter creator
 * @export
 */
export const MuteApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したチャンネルのミュートを解除します。既に解除されていた場合は204を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteChannelIDDelete(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling usersMeMuteChannelIDDelete.');
            }
            const localVarPath = `/users/me/mute/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したチャンネルをミュートします。ただし、強制通知チャンネルはミュートできません。既にミュートしていた場合は204を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteChannelIDPost(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling usersMeMuteChannelIDPost.');
            }
            const localVarPath = `/users/me/mute/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ミュートしているチャンネルのIDの配列を返します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteGet(options = {}) {
            const localVarPath = `/users/me/mute`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MuteApi - functional programming interface
 * @export
 */
export const MuteApiFp = function (configuration) {
    return {
        /**
         * 指定したチャンネルのミュートを解除します。既に解除されていた場合は204を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteChannelIDDelete(channelID, options) {
            const localVarAxiosArgs = MuteApiAxiosParamCreator(configuration).usersMeMuteChannelIDDelete(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したチャンネルをミュートします。ただし、強制通知チャンネルはミュートできません。既にミュートしていた場合は204を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteChannelIDPost(channelID, options) {
            const localVarAxiosArgs = MuteApiAxiosParamCreator(configuration).usersMeMuteChannelIDPost(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ミュートしているチャンネルのIDの配列を返します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteGet(options) {
            const localVarAxiosArgs = MuteApiAxiosParamCreator(configuration).usersMeMuteGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * MuteApi - factory interface
 * @export
 */
export const MuteApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したチャンネルのミュートを解除します。既に解除されていた場合は204を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteChannelIDDelete(channelID, options) {
            return MuteApiFp(configuration).usersMeMuteChannelIDDelete(channelID, options)(axios, basePath);
        },
        /**
         * 指定したチャンネルをミュートします。ただし、強制通知チャンネルはミュートできません。既にミュートしていた場合は204を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteChannelIDPost(channelID, options) {
            return MuteApiFp(configuration).usersMeMuteChannelIDPost(channelID, options)(axios, basePath);
        },
        /**
         * ミュートしているチャンネルのIDの配列を返します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeMuteGet(options) {
            return MuteApiFp(configuration).usersMeMuteGet(options)(axios, basePath);
        },
    };
};
/**
 * MuteApi - object-oriented interface
 * @export
 * @class MuteApi
 * @extends {BaseAPI}
 */
export class MuteApi extends BaseAPI {
    /**
     * 指定したチャンネルのミュートを解除します。既に解除されていた場合は204を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MuteApi
     */
    usersMeMuteChannelIDDelete(channelID, options) {
        return MuteApiFp(this.configuration).usersMeMuteChannelIDDelete(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルをミュートします。ただし、強制通知チャンネルはミュートできません。既にミュートしていた場合は204を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MuteApi
     */
    usersMeMuteChannelIDPost(channelID, options) {
        return MuteApiFp(this.configuration).usersMeMuteChannelIDPost(channelID, options)(this.axios, this.basePath);
    }
    /**
     * ミュートしているチャンネルのIDの配列を返します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MuteApi
     */
    usersMeMuteGet(options) {
        return MuteApiFp(this.configuration).usersMeMuteGet(options)(this.axios, this.basePath);
    }
}
/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDNotificationGet(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDNotificationGet.');
            }
            const localVarPath = `/channels/{channelID}/notification`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} [notificationUsers]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDNotificationPut(channelID, notificationUsers, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDNotificationPut.');
            }
            const localVarPath = `/channels/{channelID}/notification`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("NotificationUsers" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(notificationUsers !== undefined ? notificationUsers : {}) : (notificationUsers || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} [fCMToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationDevicePost(fCMToken, options = {}) {
            const localVarPath = `/notification/device`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("FCMToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(fCMToken !== undefined ? fCMToken : {}) : (fCMToken || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationGet(options = {}) {
            const localVarPath = `/notification`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeNotificationGet(options = {}) {
            const localVarPath = `/users/me/notification`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDNotificationGet(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDNotificationGet.');
            }
            const localVarPath = `/users/{userID}/notification`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function (configuration) {
    return {
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDNotificationGet(channelID, options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).channelsChannelIDNotificationGet(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} [notificationUsers]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDNotificationPut(channelID, notificationUsers, options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).channelsChannelIDNotificationPut(channelID, notificationUsers, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} [fCMToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationDevicePost(fCMToken, options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).notificationDevicePost(fCMToken, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationGet(options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).notificationGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeNotificationGet(options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).usersMeNotificationGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDNotificationGet(userID, options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).usersUserIDNotificationGet(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDNotificationGet(channelID, options) {
            return NotificationApiFp(configuration).channelsChannelIDNotificationGet(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} [notificationUsers]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDNotificationPut(channelID, notificationUsers, options) {
            return NotificationApiFp(configuration).channelsChannelIDNotificationPut(channelID, notificationUsers, options)(axios, basePath);
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} [fCMToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationDevicePost(fCMToken, options) {
            return NotificationApiFp(configuration).notificationDevicePost(fCMToken, options)(axios, basePath);
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationGet(options) {
            return NotificationApiFp(configuration).notificationGet(options)(axios, basePath);
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeNotificationGet(options) {
            return NotificationApiFp(configuration).usersMeNotificationGet(options)(axios, basePath);
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDNotificationGet(userID, options) {
            return NotificationApiFp(configuration).usersUserIDNotificationGet(userID, options)(axios, basePath);
        },
    };
};
/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * 通知を点けているユーザーのIDの配列を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    channelsChannelIDNotificationGet(channelID, options) {
        return NotificationApiFp(this.configuration).channelsChannelIDNotificationGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {NotificationUsers} [notificationUsers]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    channelsChannelIDNotificationPut(channelID, notificationUsers, options) {
        return NotificationApiFp(this.configuration).channelsChannelIDNotificationPut(channelID, notificationUsers, options)(this.axios, this.basePath);
    }
    /**
     * FCMデバイスを登録します。
     * @param {FCMToken} [fCMToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    notificationDevicePost(fCMToken, options) {
        return NotificationApiFp(this.configuration).notificationDevicePost(fCMToken, options)(this.axios, this.basePath);
    }
    /**
     * 通知ストリーム(Server Sent Events)に接続します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    notificationGet(options) {
        return NotificationApiFp(this.configuration).notificationGet(options)(this.axios, this.basePath);
    }
    /**
     * 自分が通知を入れているチャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    usersMeNotificationGet(options) {
        return NotificationApiFp(this.configuration).usersMeNotificationGet(options)(this.axios, this.basePath);
    }
    /**
     * ユーザーが通知を入れているチャンネルのリストを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    usersUserIDNotificationGet(userID, options) {
        return NotificationApiFp(this.configuration).usersUserIDNotificationGet(userID, options)(this.axios, this.basePath);
    }
}
/**
 * PinApi - axios parameter creator
 * @export
 */
export const PinApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDPinsGet(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling channelsChannelIDPinsGet.');
            }
            const localVarPath = `/channels/{channelID}/pins`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPinIDDelete(pinID, options = {}) {
            // verify required parameter 'pinID' is not null or undefined
            if (pinID === null || pinID === undefined) {
                throw new RequiredError('pinID', 'Required parameter pinID was null or undefined when calling pinsPinIDDelete.');
            }
            const localVarPath = `/pins/{pinID}`
                .replace(`{${"pinID"}}`, encodeURIComponent(String(pinID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPinIDGet(pinID, options = {}) {
            // verify required parameter 'pinID' is not null or undefined
            if (pinID === null || pinID === undefined) {
                throw new RequiredError('pinID', 'Required parameter pinID was null or undefined when calling pinsPinIDGet.');
            }
            const localVarPath = `/pins/{pinID}`
                .replace(`{${"pinID"}}`, encodeURIComponent(String(pinID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} [messageIDObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPost(messageIDObject, options = {}) {
            const localVarPath = `/pins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("MessageIDObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(messageIDObject !== undefined ? messageIDObject : {}) : (messageIDObject || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PinApi - functional programming interface
 * @export
 */
export const PinApiFp = function (configuration) {
    return {
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDPinsGet(channelID, options) {
            const localVarAxiosArgs = PinApiAxiosParamCreator(configuration).channelsChannelIDPinsGet(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPinIDDelete(pinID, options) {
            const localVarAxiosArgs = PinApiAxiosParamCreator(configuration).pinsPinIDDelete(pinID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPinIDGet(pinID, options) {
            const localVarAxiosArgs = PinApiAxiosParamCreator(configuration).pinsPinIDGet(pinID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} [messageIDObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPost(messageIDObject, options) {
            const localVarAxiosArgs = PinApiAxiosParamCreator(configuration).pinsPost(messageIDObject, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PinApi - factory interface
 * @export
 */
export const PinApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsChannelIDPinsGet(channelID, options) {
            return PinApiFp(configuration).channelsChannelIDPinsGet(channelID, options)(axios, basePath);
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPinIDDelete(pinID, options) {
            return PinApiFp(configuration).pinsPinIDDelete(pinID, options)(axios, basePath);
        },
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPinIDGet(pinID, options) {
            return PinApiFp(configuration).pinsPinIDGet(pinID, options)(axios, basePath);
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} [messageIDObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPost(messageIDObject, options) {
            return PinApiFp(configuration).pinsPost(messageIDObject, options)(axios, basePath);
        },
    };
};
/**
 * PinApi - object-oriented interface
 * @export
 * @class PinApi
 * @extends {BaseAPI}
 */
export class PinApi extends BaseAPI {
    /**
     * チャンネルのピン留め一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    channelsChannelIDPinsGet(channelID, options) {
        return PinApiFp(this.configuration).channelsChannelIDPinsGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを外します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinsPinIDDelete(pinID, options) {
        return PinApiFp(this.configuration).pinsPinIDDelete(pinID, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを取得します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinsPinIDGet(pinID, options) {
        return PinApiFp(this.configuration).pinsPinIDGet(pinID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージをピン留めします。
     * @param {MessageIDObject} [messageIDObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinsPost(messageIDObject, options) {
        return PinApiFp(this.configuration).pinsPost(messageIDObject, options)(this.axios, this.basePath);
    }
}
/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIconUsernameGet(username, options = {}) {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username', 'Required parameter username was null or undefined when calling publicIconUsernameGet.');
            }
            const localVarPath = `/public/icon/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function (configuration) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIconUsernameGet(username, options) {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).publicIconUsernameGet(username, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIconUsernameGet(username, options) {
            return PublicApiFp(configuration).publicIconUsernameGet(username, options)(axios, basePath);
        },
    };
};
/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 指定したユーザーのアイコン画像を取得します。
     * @param {string} username 画像を取得するユーザーのユーザー名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    publicIconUsernameGet(username, options) {
        return PublicApiFp(this.configuration).publicIconUsernameGet(username, options)(this.axios, this.basePath);
    }
}
/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsDelete(options = {}) {
            const localVarPath = `/users/me/sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsGet(options = {}) {
            const localVarPath = `/users/me/sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsReferenceIDDelete(referenceID, options = {}) {
            // verify required parameter 'referenceID' is not null or undefined
            if (referenceID === null || referenceID === undefined) {
                throw new RequiredError('referenceID', 'Required parameter referenceID was null or undefined when calling usersMeSessionsReferenceIDDelete.');
            }
            const localVarPath = `/users/me/sessions/{referenceID}`
                .replace(`{${"referenceID"}}`, encodeURIComponent(String(referenceID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function (configuration) {
    return {
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsDelete(options) {
            const localVarAxiosArgs = SessionsApiAxiosParamCreator(configuration).usersMeSessionsDelete(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsGet(options) {
            const localVarAxiosArgs = SessionsApiAxiosParamCreator(configuration).usersMeSessionsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsReferenceIDDelete(referenceID, options) {
            const localVarAxiosArgs = SessionsApiAxiosParamCreator(configuration).usersMeSessionsReferenceIDDelete(referenceID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsDelete(options) {
            return SessionsApiFp(configuration).usersMeSessionsDelete(options)(axios, basePath);
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsGet(options) {
            return SessionsApiFp(configuration).usersMeSessionsGet(options)(axios, basePath);
        },
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeSessionsReferenceIDDelete(referenceID, options) {
            return SessionsApiFp(configuration).usersMeSessionsReferenceIDDelete(referenceID, options)(axios, basePath);
        },
    };
};
/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * 自分のログインセッションを全てログアウトします。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    usersMeSessionsDelete(options) {
        return SessionsApiFp(this.configuration).usersMeSessionsDelete(options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    usersMeSessionsGet(options) {
        return SessionsApiFp(this.configuration).usersMeSessionsGet(options)(this.axios, this.basePath);
    }
    /**
     * 対象のセッションをログアウトします。
     * @param {string} referenceID 操作の対象となるセッションの参照ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    usersMeSessionsReferenceIDDelete(referenceID, options) {
        return SessionsApiFp(this.configuration).usersMeSessionsReferenceIDDelete(referenceID, options)(this.axios, this.basePath);
    }
}
/**
 * StampApi - axios parameter creator
 * @export
 */
export const StampApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsGet(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling messagesMessageIDStampsGet.');
            }
            const localVarPath = `/messages/{messageID}/stamps`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsStampIDDelete(messageID, stampID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling messagesMessageIDStampsStampIDDelete.');
            }
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling messagesMessageIDStampsStampIDDelete.');
            }
            const localVarPath = `/messages/{messageID}/stamps/{stampID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)))
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsStampIDPost(messageID, stampID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling messagesMessageIDStampsStampIDPost.');
            }
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling messagesMessageIDStampsStampIDPost.');
            }
            const localVarPath = `/messages/{messageID}/stamps/{stampID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)))
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsGet(options = {}) {
            const localVarPath = `/stamps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsPost(name, file, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling stampsPost.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling stampsPost.');
            }
            const localVarPath = `/stamps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDDelete(stampID, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling stampsStampIDDelete.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDGet(stampID, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling stampsStampIDGet.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDPatch(stampID, name, file, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling stampsStampIDPatch.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStampHistoryGet(options = {}) {
            const localVarPath = `/users/me/stamp-history`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StampApi - functional programming interface
 * @export
 */
export const StampApiFp = function (configuration) {
    return {
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsGet(messageID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).messagesMessageIDStampsGet(messageID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsStampIDDelete(messageID, stampID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).messagesMessageIDStampsStampIDDelete(messageID, stampID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsStampIDPost(messageID, stampID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).messagesMessageIDStampsStampIDPost(messageID, stampID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsGet(options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).stampsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsPost(name, file, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).stampsPost(name, file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDDelete(stampID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).stampsStampIDDelete(stampID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDGet(stampID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).stampsStampIDGet(stampID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDPatch(stampID, name, file, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).stampsStampIDPatch(stampID, name, file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStampHistoryGet(options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).usersMeStampHistoryGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StampApi - factory interface
 * @export
 */
export const StampApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsGet(messageID, options) {
            return StampApiFp(configuration).messagesMessageIDStampsGet(messageID, options)(axios, basePath);
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsStampIDDelete(messageID, stampID, options) {
            return StampApiFp(configuration).messagesMessageIDStampsStampIDDelete(messageID, stampID, options)(axios, basePath);
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesMessageIDStampsStampIDPost(messageID, stampID, options) {
            return StampApiFp(configuration).messagesMessageIDStampsStampIDPost(messageID, stampID, options)(axios, basePath);
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsGet(options) {
            return StampApiFp(configuration).stampsGet(options)(axios, basePath);
        },
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsPost(name, file, options) {
            return StampApiFp(configuration).stampsPost(name, file, options)(axios, basePath);
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDDelete(stampID, options) {
            return StampApiFp(configuration).stampsStampIDDelete(stampID, options)(axios, basePath);
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDGet(stampID, options) {
            return StampApiFp(configuration).stampsStampIDGet(stampID, options)(axios, basePath);
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampsStampIDPatch(stampID, name, file, options) {
            return StampApiFp(configuration).stampsStampIDPatch(stampID, name, file, options)(axios, basePath);
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStampHistoryGet(options) {
            return StampApiFp(configuration).usersMeStampHistoryGet(options)(axios, basePath);
        },
    };
};
/**
 * StampApi - object-oriented interface
 * @export
 * @class StampApi
 * @extends {BaseAPI}
 */
export class StampApi extends BaseAPI {
    /**
     * 指定したメッセージに押されているスタンプを全て取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    messagesMessageIDStampsGet(messageID, options) {
        return StampApiFp(this.configuration).messagesMessageIDStampsGet(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定したスタンプを外します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    messagesMessageIDStampsStampIDDelete(messageID, stampID, options) {
        return StampApiFp(this.configuration).messagesMessageIDStampsStampIDDelete(messageID, stampID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    messagesMessageIDStampsStampIDPost(messageID, stampID, options) {
        return StampApiFp(this.configuration).messagesMessageIDStampsStampIDPost(messageID, stampID, options)(this.axios, this.basePath);
    }
    /**
     * 全スタンプのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsGet(options) {
        return StampApiFp(this.configuration).stampsGet(options)(this.axios, this.basePath);
    }
    /**
     * スタンプを新規作成します。
     * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} file 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsPost(name, file, options) {
        return StampApiFp(this.configuration).stampsPost(name, file, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを削除します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsStampIDDelete(stampID, options) {
        return StampApiFp(this.configuration).stampsStampIDDelete(stampID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプの情報を取得します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsStampIDGet(stampID, options) {
        return StampApiFp(this.configuration).stampsStampIDGet(stampID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを修正します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsStampIDPatch(stampID, name, file, options) {
        return StampApiFp(this.configuration).stampsStampIDPatch(stampID, name, file, options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    usersMeStampHistoryGet(options) {
        return StampApiFp(this.configuration).usersMeStampHistoryGet(options)(this.axios, this.basePath);
    }
}
/**
 * StarApi - axios parameter creator
 * @export
 */
export const StarApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsChannelIDDelete(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling usersMeStarsChannelIDDelete.');
            }
            const localVarPath = `/users/me/stars/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsChannelIDPut(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling usersMeStarsChannelIDPut.');
            }
            const localVarPath = `/users/me/stars/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsGet(options = {}) {
            const localVarPath = `/users/me/stars`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StarApi - functional programming interface
 * @export
 */
export const StarApiFp = function (configuration) {
    return {
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsChannelIDDelete(channelID, options) {
            const localVarAxiosArgs = StarApiAxiosParamCreator(configuration).usersMeStarsChannelIDDelete(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsChannelIDPut(channelID, options) {
            const localVarAxiosArgs = StarApiAxiosParamCreator(configuration).usersMeStarsChannelIDPut(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsGet(options) {
            const localVarAxiosArgs = StarApiAxiosParamCreator(configuration).usersMeStarsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StarApi - factory interface
 * @export
 */
export const StarApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsChannelIDDelete(channelID, options) {
            return StarApiFp(configuration).usersMeStarsChannelIDDelete(channelID, options)(axios, basePath);
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsChannelIDPut(channelID, options) {
            return StarApiFp(configuration).usersMeStarsChannelIDPut(channelID, options)(axios, basePath);
        },
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeStarsGet(options) {
            return StarApiFp(configuration).usersMeStarsGet(options)(axios, basePath);
        },
    };
};
/**
 * StarApi - object-oriented interface
 * @export
 * @class StarApi
 * @extends {BaseAPI}
 */
export class StarApi extends BaseAPI {
    /**
     * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    usersMeStarsChannelIDDelete(channelID, options) {
        return StarApiFp(this.configuration).usersMeStarsChannelIDDelete(channelID, options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストにチャンネルを追加します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    usersMeStarsChannelIDPut(channelID, options) {
        return StarApiFp(this.configuration).usersMeStarsChannelIDPut(channelID, options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    usersMeStarsGet(options) {
        return StarApiFp(this.configuration).usersMeStarsGet(options)(this.axios, this.basePath);
    }
}
/**
 * UnreadApi - axios parameter creator
 * @export
 */
export const UnreadApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeUnreadChannelsChannelIDDelete(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling usersMeUnreadChannelsChannelIDDelete.');
            }
            const localVarPath = `/users/me/unread/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeUnreadChannelsGet(options = {}) {
            const localVarPath = `/users/me/unread/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UnreadApi - functional programming interface
 * @export
 */
export const UnreadApiFp = function (configuration) {
    return {
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeUnreadChannelsChannelIDDelete(channelID, options) {
            const localVarAxiosArgs = UnreadApiAxiosParamCreator(configuration).usersMeUnreadChannelsChannelIDDelete(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeUnreadChannelsGet(options) {
            const localVarAxiosArgs = UnreadApiAxiosParamCreator(configuration).usersMeUnreadChannelsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UnreadApi - factory interface
 * @export
 */
export const UnreadApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeUnreadChannelsChannelIDDelete(channelID, options) {
            return UnreadApiFp(configuration).usersMeUnreadChannelsChannelIDDelete(channelID, options)(axios, basePath);
        },
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeUnreadChannelsGet(options) {
            return UnreadApiFp(configuration).usersMeUnreadChannelsGet(options)(axios, basePath);
        },
    };
};
/**
 * UnreadApi - object-oriented interface
 * @export
 * @class UnreadApi
 * @extends {BaseAPI}
 */
export class UnreadApi extends BaseAPI {
    /**
     * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    usersMeUnreadChannelsChannelIDDelete(channelID, options) {
        return UnreadApiFp(this.configuration).usersMeUnreadChannelsChannelIDDelete(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 未読チャンネル情報のリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    usersMeUnreadChannelsGet(options) {
        return UnreadApiFp(this.configuration).usersMeUnreadChannelsGet(options)(this.axios, this.basePath);
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options = {}) {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options = {}) {
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeIconGet(options = {}) {
            const localVarPath = `/users/me/icon`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeIconPut(file, options = {}) {
            const localVarPath = `/users/me/icon`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} [changePassword]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePasswordPut(changePassword, options = {}) {
            const localVarPath = `/users/me/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("ChangePassword" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(changePassword !== undefined ? changePassword : {}) : (changePassword || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} [userData]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePatch(userData, options = {}) {
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("UserData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userData !== undefined ? userData : {}) : (userData || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeQrCodeGet(options = {}) {
            const localVarPath = `/users/me/qr-code`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} [userRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(userRegister, options = {}) {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("UserRegister" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userRegister !== undefined ? userRegister : {}) : (userRegister || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDGet.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDIconGet(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDIconGet.');
            }
            const localVarPath = `/users/{userID}/icon`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration) {
    return {
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersMeGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeIconGet(options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersMeIconGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeIconPut(file, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersMeIconPut(file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} [changePassword]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePasswordPut(changePassword, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersMePasswordPut(changePassword, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} [userData]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePatch(userData, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersMePatch(userData, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeQrCodeGet(options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersMeQrCodeGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} [userRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(userRegister, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersPost(userRegister, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersUserIDGet(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDIconGet(userID, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).usersUserIDIconGet(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options) {
            return UserApiFp(configuration).usersGet(options)(axios, basePath);
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options) {
            return UserApiFp(configuration).usersMeGet(options)(axios, basePath);
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeIconGet(options) {
            return UserApiFp(configuration).usersMeIconGet(options)(axios, basePath);
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeIconPut(file, options) {
            return UserApiFp(configuration).usersMeIconPut(file, options)(axios, basePath);
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} [changePassword]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePasswordPut(changePassword, options) {
            return UserApiFp(configuration).usersMePasswordPut(changePassword, options)(axios, basePath);
        },
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} [userData]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePatch(userData, options) {
            return UserApiFp(configuration).usersMePatch(userData, options)(axios, basePath);
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeQrCodeGet(options) {
            return UserApiFp(configuration).usersMeQrCodeGet(options)(axios, basePath);
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} [userRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(userRegister, options) {
            return UserApiFp(configuration).usersPost(userRegister, options)(axios, basePath);
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGet(userID, options) {
            return UserApiFp(configuration).usersUserIDGet(userID, options)(axios, basePath);
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDIconGet(userID, options) {
            return UserApiFp(configuration).usersUserIDIconGet(userID, options)(axios, basePath);
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 全ユーザーのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersGet(options) {
        return UserApiFp(this.configuration).usersGet(options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMeGet(options) {
        return UserApiFp(this.configuration).usersMeGet(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMeIconGet(options) {
        return UserApiFp(this.configuration).usersMeIconGet(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコンを更新します。
     * @param {any} [file] 1MBまでのpng, jpeg, gif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMeIconPut(file, options) {
        return UserApiFp(this.configuration).usersMeIconPut(file, options)(this.axios, this.basePath);
    }
    /**
     * 自分のパスワードを変更します。
     * @param {ChangePassword} [changePassword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMePasswordPut(changePassword, options) {
        return UserApiFp(this.configuration).usersMePasswordPut(changePassword, options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を変更します。
     * @param {UserData} [userData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMePatch(userData, options) {
        return UserApiFp(this.configuration).usersMePatch(userData, options)(this.axios, this.basePath);
    }
    /**
     * 自分のQRコードを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMeQrCodeGet(options) {
        return UserApiFp(this.configuration).usersMeQrCodeGet(options)(this.axios, this.basePath);
    }
    /**
     * ユーザー登録します
     * @param {UserRegister} [userRegister]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersPost(userRegister, options) {
        return UserApiFp(this.configuration).usersPost(userRegister, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーの詳細を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersUserIDGet(userID, options) {
        return UserApiFp(this.configuration).usersUserIDGet(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのアイコン画像を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersUserIDIconGet(userID, options) {
        return UserApiFp(this.configuration).usersUserIDIconGet(userID, options)(this.axios, this.basePath);
    }
}
/**
 * UserGroupApi - axios parameter creator
 * @export
 */
export const UserGroupApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet(options = {}) {
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDDelete(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling groupsGroupIDDelete.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDGet(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling groupsGroupIDGet.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersGet(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling groupsGroupIDMembersGet.');
            }
            const localVarPath = `/groups/{groupID}/members`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} [addUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersPost(groupID, addUserGroup, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling groupsGroupIDMembersPost.');
            }
            const localVarPath = `/groups/{groupID}/members`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("AddUserGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(addUserGroup !== undefined ? addUserGroup : {}) : (addUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersUserIDDelete(groupID, userID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling groupsGroupIDMembersUserIDDelete.');
            }
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling groupsGroupIDMembersUserIDDelete.');
            }
            const localVarPath = `/groups/{groupID}/members/{userID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)))
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} [patchUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDPatch(groupID, patchUserGroup, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling groupsGroupIDPatch.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchUserGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserGroup !== undefined ? patchUserGroup : {}) : (patchUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} [postUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost(postUserGroup, options = {}) {
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostUserGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserGroup !== undefined ? postUserGroup : {}) : (postUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGroupsGet(options = {}) {
            const localVarPath = `/users/me/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGroupsGet(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDGroupsGet.');
            }
            const localVarPath = `/users/{userID}/groups`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserGroupApi - functional programming interface
 * @export
 */
export const UserGroupApiFp = function (configuration) {
    return {
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet(options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).groupsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDDelete(groupID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).groupsGroupIDDelete(groupID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDGet(groupID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).groupsGroupIDGet(groupID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersGet(groupID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).groupsGroupIDMembersGet(groupID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} [addUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersPost(groupID, addUserGroup, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).groupsGroupIDMembersPost(groupID, addUserGroup, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersUserIDDelete(groupID, userID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).groupsGroupIDMembersUserIDDelete(groupID, userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} [patchUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDPatch(groupID, patchUserGroup, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).groupsGroupIDPatch(groupID, patchUserGroup, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} [postUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost(postUserGroup, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).groupsPost(postUserGroup, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGroupsGet(options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).usersMeGroupsGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGroupsGet(userID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).usersUserIDGroupsGet(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserGroupApi - factory interface
 * @export
 */
export const UserGroupApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet(options) {
            return UserGroupApiFp(configuration).groupsGet(options)(axios, basePath);
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDDelete(groupID, options) {
            return UserGroupApiFp(configuration).groupsGroupIDDelete(groupID, options)(axios, basePath);
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDGet(groupID, options) {
            return UserGroupApiFp(configuration).groupsGroupIDGet(groupID, options)(axios, basePath);
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersGet(groupID, options) {
            return UserGroupApiFp(configuration).groupsGroupIDMembersGet(groupID, options)(axios, basePath);
        },
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} [addUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersPost(groupID, addUserGroup, options) {
            return UserGroupApiFp(configuration).groupsGroupIDMembersPost(groupID, addUserGroup, options)(axios, basePath);
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDMembersUserIDDelete(groupID, userID, options) {
            return UserGroupApiFp(configuration).groupsGroupIDMembersUserIDDelete(groupID, userID, options)(axios, basePath);
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} [patchUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIDPatch(groupID, patchUserGroup, options) {
            return UserGroupApiFp(configuration).groupsGroupIDPatch(groupID, patchUserGroup, options)(axios, basePath);
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} [postUserGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost(postUserGroup, options) {
            return UserGroupApiFp(configuration).groupsPost(postUserGroup, options)(axios, basePath);
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGroupsGet(options) {
            return UserGroupApiFp(configuration).usersMeGroupsGet(options)(axios, basePath);
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDGroupsGet(userID, options) {
            return UserGroupApiFp(configuration).usersUserIDGroupsGet(userID, options)(axios, basePath);
        },
    };
};
/**
 * UserGroupApi - object-oriented interface
 * @export
 * @class UserGroupApi
 * @extends {BaseAPI}
 */
export class UserGroupApi extends BaseAPI {
    /**
     * 全てのユーザーグループを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGet(options) {
        return UserGroupApiFp(this.configuration).groupsGet(options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDDelete(groupID, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDDelete(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDGet(groupID, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDGet(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループのメンバーのIDを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDMembersGet(groupID, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDMembersGet(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループにメンバーを追加します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {AddUserGroup} [addUserGroup]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDMembersPost(groupID, addUserGroup, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDMembersPost(groupID, addUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループからメンバーを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDMembersUserIDDelete(groupID, userID, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDMembersUserIDDelete(groupID, userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループの情報を変更します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {PatchUserGroup} [patchUserGroup]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDPatch(groupID, patchUserGroup, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDPatch(groupID, patchUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを作成します
     * @param {PostUserGroup} [postUserGroup]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsPost(postUserGroup, options) {
        return UserGroupApiFp(this.configuration).groupsPost(postUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    usersMeGroupsGet(options) {
        return UserGroupApiFp(this.configuration).usersMeGroupsGet(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    usersUserIDGroupsGet(userID, options) {
        return UserGroupApiFp(this.configuration).usersUserIDGroupsGet(userID, options)(this.axios, this.basePath);
    }
}
/**
 * UserTagApi - axios parameter creator
 * @export
 */
export const UserTagApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsTagIDGet(tagID, options = {}) {
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new RequiredError('tagID', 'Required parameter tagID was null or undefined when calling tagsTagIDGet.');
            }
            const localVarPath = `/tags/{tagID}`
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsGet(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDTagsGet.');
            }
            const localVarPath = `/users/{userID}/tags`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} [setTag]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsPost(userID, setTag, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDTagsPost.');
            }
            const localVarPath = `/users/{userID}/tags`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SetTag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setTag !== undefined ? setTag : {}) : (setTag || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsTagIDDelete(userID, tagID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDTagsTagIDDelete.');
            }
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new RequiredError('tagID', 'Required parameter tagID was null or undefined when calling usersUserIDTagsTagIDDelete.');
            }
            const localVarPath = `/users/{userID}/tags/{tagID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} [setTagLock]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling usersUserIDTagsTagIDPatch.');
            }
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new RequiredError('tagID', 'Required parameter tagID was null or undefined when calling usersUserIDTagsTagIDPatch.');
            }
            const localVarPath = `/users/{userID}/tags/{tagID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("SetTagLock" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setTagLock !== undefined ? setTagLock : {}) : (setTagLock || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserTagApi - functional programming interface
 * @export
 */
export const UserTagApiFp = function (configuration) {
    return {
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsTagIDGet(tagID, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).tagsTagIDGet(tagID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsGet(userID, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).usersUserIDTagsGet(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} [setTag]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsPost(userID, setTag, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).usersUserIDTagsPost(userID, setTag, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsTagIDDelete(userID, tagID, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).usersUserIDTagsTagIDDelete(userID, tagID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} [setTagLock]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserTagApi - factory interface
 * @export
 */
export const UserTagApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsTagIDGet(tagID, options) {
            return UserTagApiFp(configuration).tagsTagIDGet(tagID, options)(axios, basePath);
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsGet(userID, options) {
            return UserTagApiFp(configuration).usersUserIDTagsGet(userID, options)(axios, basePath);
        },
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} [setTag]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsPost(userID, setTag, options) {
            return UserTagApiFp(configuration).usersUserIDTagsPost(userID, setTag, options)(axios, basePath);
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsTagIDDelete(userID, tagID, options) {
            return UserTagApiFp(configuration).usersUserIDTagsTagIDDelete(userID, tagID, options)(axios, basePath);
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} [setTagLock]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options) {
            return UserTagApiFp(configuration).usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options)(axios, basePath);
        },
    };
};
/**
 * UserTagApi - object-oriented interface
 * @export
 * @class UserTagApi
 * @extends {BaseAPI}
 */
export class UserTagApi extends BaseAPI {
    /**
     * 指定されたタグの情報を取得します。
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    tagsTagIDGet(tagID, options) {
        return UserTagApiFp(this.configuration).tagsTagIDGet(tagID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのタグのリストを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    usersUserIDTagsGet(userID, options) {
        return UserTagApiFp(this.configuration).usersUserIDTagsGet(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーにタグを追加します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SetTag} [setTag]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    usersUserIDTagsPost(userID, setTag, options) {
        return UserTagApiFp(this.configuration).usersUserIDTagsPost(userID, setTag, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    usersUserIDTagsTagIDDelete(userID, tagID, options) {
        return UserTagApiFp(this.configuration).usersUserIDTagsTagIDDelete(userID, tagID, options)(this.axios, this.basePath);
    }
    /**
     * タグのロック、アンロックを変更します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {SetTagLock} [setTagLock]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options) {
        return UserTagApiFp(this.configuration).usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options)(this.axios, this.basePath);
    }
}
/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(options = {}) {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} [postWebhook]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(postWebhook, options = {}) {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PostWebhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postWebhook !== undefined ? postWebhook : {}) : (postWebhook || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDDelete(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling webhooksWebhookIDDelete.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDGet(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling webhooksWebhookIDGet.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDGithubPost(webhookID, body, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling webhooksWebhookIDGithubPost.');
            }
            const localVarPath = `/webhooks/{webhookID}/github`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("object" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDIconGet(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling webhooksWebhookIDIconGet.');
            }
            const localVarPath = `/webhooks/{webhookID}/icon`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDIconPut(webhookID, file, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling webhooksWebhookIDIconPut.');
            }
            const localVarPath = `/webhooks/{webhookID}/icon`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} [patchWebhook]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDPatch(webhookID, patchWebhook, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling webhooksWebhookIDPatch.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("PatchWebhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchWebhook !== undefined ? patchWebhook : {}) : (patchWebhook || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling webhooksWebhookIDPost.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xTRAQChannelId !== undefined && xTRAQChannelId !== null) {
                localVarHeaderParameter['X-TRAQ-Channel-Id'] = String(xTRAQChannelId);
            }
            if (xTRAQSignature !== undefined && xTRAQSignature !== null) {
                localVarHeaderParameter['X-TRAQ-Signature'] = String(xTRAQSignature);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = ("string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function (configuration) {
    return {
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksGet(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} [postWebhook]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(postWebhook, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksPost(postWebhook, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDDelete(webhookID, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksWebhookIDDelete(webhookID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDGet(webhookID, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksWebhookIDGet(webhookID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDGithubPost(webhookID, body, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksWebhookIDGithubPost(webhookID, body, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDIconGet(webhookID, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksWebhookIDIconGet(webhookID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDIconPut(webhookID, file, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksWebhookIDIconPut(webhookID, file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} [patchWebhook]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDPatch(webhookID, patchWebhook, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksWebhookIDPatch(webhookID, patchWebhook, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(options) {
            return WebhookApiFp(configuration).webhooksGet(options)(axios, basePath);
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} [postWebhook]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(postWebhook, options) {
            return WebhookApiFp(configuration).webhooksPost(postWebhook, options)(axios, basePath);
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDDelete(webhookID, options) {
            return WebhookApiFp(configuration).webhooksWebhookIDDelete(webhookID, options)(axios, basePath);
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDGet(webhookID, options) {
            return WebhookApiFp(configuration).webhooksWebhookIDGet(webhookID, options)(axios, basePath);
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDGithubPost(webhookID, body, options) {
            return WebhookApiFp(configuration).webhooksWebhookIDGithubPost(webhookID, body, options)(axios, basePath);
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDIconGet(webhookID, options) {
            return WebhookApiFp(configuration).webhooksWebhookIDIconGet(webhookID, options)(axios, basePath);
        },
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDIconPut(webhookID, file, options) {
            return WebhookApiFp(configuration).webhooksWebhookIDIconPut(webhookID, file, options)(axios, basePath);
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} [patchWebhook]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDPatch(webhookID, patchWebhook, options) {
            return WebhookApiFp(configuration).webhooksWebhookIDPatch(webhookID, patchWebhook, options)(axios, basePath);
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {string} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options) {
            return WebhookApiFp(configuration).webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options)(axios, basePath);
        },
    };
};
/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 自分が作成したwebhookの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksGet(options) {
        return WebhookApiFp(this.configuration).webhooksGet(options)(this.axios, this.basePath);
    }
    /**
     * webhookを作成します。
     * @param {PostWebhook} [postWebhook]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksPost(postWebhook, options) {
        return WebhookApiFp(this.configuration).webhooksPost(postWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookを削除します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDDelete(webhookID, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDDelete(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * webhookの詳細を取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDGet(webhookID, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDGet(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * Github-Compatibleなwebhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDGithubPost(webhookID, body, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDGithubPost(webhookID, body, options)(this.axios, this.basePath);
    }
    /**
     * 指定したWebhookのアイコンを取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDIconGet(webhookID, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDIconGet(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したwebhookのアイコンを変更します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDIconPut(webhookID, file, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDIconPut(webhookID, file, options)(this.axios, this.basePath);
    }
    /**
     * webhookを修正します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {PatchWebhook} [patchWebhook]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDPatch(webhookID, patchWebhook, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDPatch(webhookID, patchWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
     * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options)(this.axios, this.basePath);
    }
}
export class Apis extends BaseAPI {
    /**
     * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
     * @param {number} [limit] 取得する件数 1-50
     * @param {boolean} [subscribe] 購読チャンネルのみを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    activityLatestMessagesGet(limit, subscribe, options) {
        return ActivityApiFp(this.configuration).activityLatestMessagesGet(limit, subscribe, options)(this.axios, this.basePath);
    }
    /**
     * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
     * @param {string} [redirect] リダイレクト先
     * @param {UserLogin} [userLogin]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    loginPost(redirect, userLogin, options) {
        return AuthenticationApiFp(this.configuration).loginPost(redirect, userLogin, options)(this.axios, this.basePath);
    }
    /**
     * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logoutPost(redirect, options) {
        return AuthenticationApiFp(this.configuration).logoutPost(redirect, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可承諾
     * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    oauth2AuthorizeDecidePost(submit, options) {
        return AuthorizationApiFp(this.configuration).oauth2AuthorizeDecidePost(submit, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [clientId]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return AuthorizationApiFp(this.configuration).oauth2AuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [clientId]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return AuthorizationApiFp(this.configuration).oauth2AuthorizePost(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 トークンエンドポイント
     * @param {string} grantType
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [clientId]
     * @param {string} [codeVerifier]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [scope]
     * @param {string} [refreshToken]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
        return AuthorizationApiFp(this.configuration).oauth2TokenPost(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(this.axios, this.basePath);
    }
    /**
     * Botが参加しているチャンネルのUUIDの配列を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDChannelsGet(botID, options) {
        return BotApiFp(this.configuration).botsBotIDChannelsGet(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botを削除します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDDelete(botID, options) {
        return BotApiFp(this.configuration).botsBotIDDelete(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの詳細を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDDetailGet(botID, options) {
        return BotApiFp(this.configuration).botsBotIDDetailGet(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの購読イベントを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotEvents} [putBotEvents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDEventsPut(botID, putBotEvents, options) {
        return BotApiFp(this.configuration).botsBotIDEventsPut(botID, putBotEvents, options)(this.axios, this.basePath);
    }
    /**
     * Botを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDGet(botID, options) {
        return BotApiFp(this.configuration).botsBotIDGet(botID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDIconGet(botID, options) {
        return BotApiFp(this.configuration).botsBotIDIconGet(botID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDIconPut(botID, file, options) {
        return BotApiFp(this.configuration).botsBotIDIconPut(botID, file, options)(this.axios, this.basePath);
    }
    /**
     * Bot情報を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PatchBot} [patchBot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDPatch(botID, patchBot, options) {
        return BotApiFp(this.configuration).botsBotIDPatch(botID, patchBot, options)(this.axios, this.basePath);
    }
    /**
     * Botの各種トークンを再発行します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDReissuePost(botID, options) {
        return BotApiFp(this.configuration).botsBotIDReissuePost(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの状態を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotState} [putBotState]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsBotIDStatePut(botID, putBotState, options) {
        return BotApiFp(this.configuration).botsBotIDStatePut(botID, putBotState, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したBotの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsGet(options) {
        return BotApiFp(this.configuration).botsGet(options)(this.axios, this.basePath);
    }
    /**
     * Botを作成します。
     * @param {PostBot} [postBot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    botsPost(postBot, options) {
        return BotApiFp(this.configuration).botsPost(postBot, options)(this.axios, this.basePath);
    }
    /**
     * Botをチャンネルから退出させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    channelsChannelIDBotsBotIDDelete(channelID, botID, options) {
        return BotApiFp(this.configuration).channelsChannelIDBotsBotIDDelete(channelID, botID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに参加しているBot一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    channelsChannelIDBotsGet(channelID, options) {
        return BotApiFp(this.configuration).channelsChannelIDBotsGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにBotを参加させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PostBotChannel} [postBotChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    channelsChannelIDBotsPost(channelID, postBotChannel, options) {
        return BotApiFp(this.configuration).channelsChannelIDBotsPost(channelID, postBotChannel, options)(this.axios, this.basePath);
    }
    /**
     * 子チャンネルを作成します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {CreateChannelChild} [createChannelChild]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDChildrenPost(channelID, createChannelChild, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDChildrenPost(channelID, createChannelChild, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを削除します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDDelete(channelID, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDDelete(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルイベントのリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDEventsGet(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDGet(channelID, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの親チャンネルを変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PutParentChannel} [putParentChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDParentPut(channelID, putParentChannel, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDParentPut(channelID, putParentChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PatchChannel} [patchChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDPatch(channelID, patchChannel, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDPatch(channelID, patchChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDTopicGet(channelID, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDTopicGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SetChannelTopic} [setChannelTopic]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsChannelIDTopicPut(channelID, setChannelTopic, options) {
        return ChannelApiFp(this.configuration).channelsChannelIDTopicPut(channelID, setChannelTopic, options)(this.axios, this.basePath);
    }
    /**
     * (すべての)チャンネルのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsGet(options) {
        return ChannelApiFp(this.configuration).channelsGet(options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを作成します。
     * @param {CreateChannel} [createChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    channelsPost(createChannel, options) {
        return ChannelApiFp(this.configuration).channelsPost(createChannel, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsClientIDDelete(clientID, options) {
        return ClientApiFp(this.configuration).clientsClientIDDelete(clientID, options)(this.axios, this.basePath);
    }
    /**
     * クライアントの詳細を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsClientIDDetailGet(clientID, options) {
        return ClientApiFp(this.configuration).clientsClientIDDetailGet(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsClientIDGet(clientID, options) {
        return ClientApiFp(this.configuration).clientsClientIDGet(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を変更します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {PatchClient} [patchClient]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsClientIDPatch(clientID, patchClient, options) {
        return ClientApiFp(this.configuration).clientsClientIDPatch(clientID, patchClient, options)(this.axios, this.basePath);
    }
    /**
     * 自分が登録しているクライアントの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsGet(options) {
        return ClientApiFp(this.configuration).clientsGet(options)(this.axios, this.basePath);
    }
    /**
     * クライアントを登録します。
     * @param {PostClient} [postClient]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    clientsPost(postClient, options) {
        return ClientApiFp(this.configuration).clientsPost(postClient, options)(this.axios, this.basePath);
    }
    /**
     * 自分が許可しているクライアントの一覧とトークン情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    usersMeTokensGet(options) {
        return ClientApiFp(this.configuration).usersMeTokensGet(options)(this.axios, this.basePath);
    }
    /**
     * 指定したトークンの認可を取り消します。
     * @param {string} oauth2TokenID 操作の対象となるTokenのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options) {
        return ClientApiFp(this.configuration).usersMeTokensOauth2TokenIDDelete(oauth2TokenID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップを削除します。
     * @param {string} clipID 捜査の対象となるクリップのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsClipIDDelete(clipID, options) {
        return ClipApiFp(this.configuration).usersMeClipsClipIDDelete(clipID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップのフォルダ情報を取得します。
     * @param {string} clipID 捜査の対象となるクリップのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsClipIDFolderGet(clipID, options) {
        return ClipApiFp(this.configuration).usersMeClipsClipIDFolderGet(clipID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップのフォルダを変更します。
     * @param {string} clipID 捜査の対象となるクリップのID
     * @param {ClipsFolderIDObject} [clipsFolderIDObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options) {
        return ClipApiFp(this.configuration).usersMeClipsClipIDFolderPut(clipID, clipsFolderIDObject, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクリップのメッセージを取得します。
     * @param {string} clipID 捜査の対象となるクリップのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsClipIDGet(clipID, options) {
        return ClipApiFp(this.configuration).usersMeClipsClipIDGet(clipID, options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダを削除します。フォルダ内のクリップは全て削除されます。
     * @param {string} folderID 操作の対象となるクリップフォルダのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersFolderIDDelete(folderID, options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersFolderIDDelete(folderID, options)(this.axios, this.basePath);
    }
    /**
     * フォルダ内のクリップ一覧を取得します。
     * @param {string} folderID 操作の対象となるクリップフォルダのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersFolderIDGet(folderID, options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersFolderIDGet(folderID, options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダ名を変更します。
     * @param {string} folderID 操作の対象となるクリップフォルダのID
     * @param {ClipsFolderNameObject} [clipsFolderNameObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersFolderIDPatch(folderID, clipsFolderNameObject, options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダ一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersGet(options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersGet(options)(this.axios, this.basePath);
    }
    /**
     * クリップフォルダを作成します。
     * @param {ClipsFolderNameObject} [clipsFolderNameObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsFoldersPost(clipsFolderNameObject, options) {
        return ClipApiFp(this.configuration).usersMeClipsFoldersPost(clipsFolderNameObject, options)(this.axios, this.basePath);
    }
    /**
     * 全てのクリップを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsGet(options) {
        return ClipApiFp(this.configuration).usersMeClipsGet(options)(this.axios, this.basePath);
    }
    /**
     * 新しくメッセージをクリップします。
     * @param {SetClip} [setClip]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClipApi
     */
    usersMeClipsPost(setClip, options) {
        return ClipApiFp(this.configuration).usersMeClipsPost(setClip, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルを削除します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesFileIDDelete(fileID, options) {
        return FileApiFp(this.configuration).filesFileIDDelete(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルの中身を取得します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesFileIDGet(fileID, dl, options) {
        return FileApiFp(this.configuration).filesFileIDGet(fileID, dl, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのメタデータを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesFileIDMetaGet(fileID, options) {
        return FileApiFp(this.configuration).filesFileIDMetaGet(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのサムネイルを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesFileIDThumbnailGet(fileID, options) {
        return FileApiFp(this.configuration).filesFileIDThumbnailGet(fileID, options)(this.axios, this.basePath);
    }
    /**
     * ファイルをアップロードします
     * @param {any} file ファイル本体
     * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    filesPost(file, aclReadable, options) {
        return FileApiFp(this.configuration).filesPost(file, aclReadable, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを現在見ている人・編集している人を取得します。
     * @param {string} channelId 現在いるチャンネルId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    heartbeatGet(channelId, options) {
        return HeartbeatApiFp(this.configuration).heartbeatGet(channelId, options)(this.axios, this.basePath);
    }
    /**
     * どのチャンネルを見ているか・編集しているかを送信します。
     * @param {Heartbeat} [heartbeat]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    heartbeatPost(heartbeat, options) {
        return HeartbeatApiFp(this.configuration).heartbeatPost(heartbeat, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに存在するメッセージを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options) {
        return MessageApiFp(this.configuration).channelsChannelIDMessagesGet(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージを投稿します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SendMessage} [sendMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    channelsChannelIDMessagesPost(channelID, sendMessage, options) {
        return MessageApiFp(this.configuration).channelsChannelIDMessagesPost(channelID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを削除します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesMessageIDDelete(messageID, options) {
        return MessageApiFp(this.configuration).messagesMessageIDDelete(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesMessageIDGet(messageID, options) {
        return MessageApiFp(this.configuration).messagesMessageIDGet(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを編集します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {SendMessage} [sendMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesMessageIDPut(messageID, sendMessage, options) {
        return MessageApiFp(this.configuration).messagesMessageIDPut(messageID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを通報します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {ReportMessage} [reportMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesMessageIDReportPost(messageID, reportMessage, options) {
        return MessageApiFp(this.configuration).messagesMessageIDReportPost(messageID, reportMessage, options)(this.axios, this.basePath);
    }
    /**
     * メッセージ通報を最大50件取得します。
     * @param {number} [p] ページ番号(ゼロオリジン)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    messagesReportsGet(p, options) {
        return MessageApiFp(this.configuration).messagesReportsGet(p, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルに存在するメッセージを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options) {
        return MessageApiFp(this.configuration).usersUserIDMessagesGet(userID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルにメッセージを投稿します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SendMessage} [sendMessage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    usersUserIDMessagesPost(userID, sendMessage, options) {
        return MessageApiFp(this.configuration).usersUserIDMessagesPost(userID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルのミュートを解除します。既に解除されていた場合は204を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MuteApi
     */
    usersMeMuteChannelIDDelete(channelID, options) {
        return MuteApiFp(this.configuration).usersMeMuteChannelIDDelete(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したチャンネルをミュートします。ただし、強制通知チャンネルはミュートできません。既にミュートしていた場合は204を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MuteApi
     */
    usersMeMuteChannelIDPost(channelID, options) {
        return MuteApiFp(this.configuration).usersMeMuteChannelIDPost(channelID, options)(this.axios, this.basePath);
    }
    /**
     * ミュートしているチャンネルのIDの配列を返します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MuteApi
     */
    usersMeMuteGet(options) {
        return MuteApiFp(this.configuration).usersMeMuteGet(options)(this.axios, this.basePath);
    }
    /**
     * 通知を点けているユーザーのIDの配列を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    channelsChannelIDNotificationGet(channelID, options) {
        return NotificationApiFp(this.configuration).channelsChannelIDNotificationGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {NotificationUsers} [notificationUsers]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    channelsChannelIDNotificationPut(channelID, notificationUsers, options) {
        return NotificationApiFp(this.configuration).channelsChannelIDNotificationPut(channelID, notificationUsers, options)(this.axios, this.basePath);
    }
    /**
     * FCMデバイスを登録します。
     * @param {FCMToken} [fCMToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    notificationDevicePost(fCMToken, options) {
        return NotificationApiFp(this.configuration).notificationDevicePost(fCMToken, options)(this.axios, this.basePath);
    }
    /**
     * 通知ストリーム(Server Sent Events)に接続します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    notificationGet(options) {
        return NotificationApiFp(this.configuration).notificationGet(options)(this.axios, this.basePath);
    }
    /**
     * 自分が通知を入れているチャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    usersMeNotificationGet(options) {
        return NotificationApiFp(this.configuration).usersMeNotificationGet(options)(this.axios, this.basePath);
    }
    /**
     * ユーザーが通知を入れているチャンネルのリストを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    usersUserIDNotificationGet(userID, options) {
        return NotificationApiFp(this.configuration).usersUserIDNotificationGet(userID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのピン留め一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    channelsChannelIDPinsGet(channelID, options) {
        return PinApiFp(this.configuration).channelsChannelIDPinsGet(channelID, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを外します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinsPinIDDelete(pinID, options) {
        return PinApiFp(this.configuration).pinsPinIDDelete(pinID, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを取得します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinsPinIDGet(pinID, options) {
        return PinApiFp(this.configuration).pinsPinIDGet(pinID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージをピン留めします。
     * @param {MessageIDObject} [messageIDObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinsPost(messageIDObject, options) {
        return PinApiFp(this.configuration).pinsPost(messageIDObject, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのアイコン画像を取得します。
     * @param {string} username 画像を取得するユーザーのユーザー名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    publicIconUsernameGet(username, options) {
        return PublicApiFp(this.configuration).publicIconUsernameGet(username, options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションを全てログアウトします。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    usersMeSessionsDelete(options) {
        return SessionsApiFp(this.configuration).usersMeSessionsDelete(options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    usersMeSessionsGet(options) {
        return SessionsApiFp(this.configuration).usersMeSessionsGet(options)(this.axios, this.basePath);
    }
    /**
     * 対象のセッションをログアウトします。
     * @param {string} referenceID 操作の対象となるセッションの参照ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    usersMeSessionsReferenceIDDelete(referenceID, options) {
        return SessionsApiFp(this.configuration).usersMeSessionsReferenceIDDelete(referenceID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに押されているスタンプを全て取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    messagesMessageIDStampsGet(messageID, options) {
        return StampApiFp(this.configuration).messagesMessageIDStampsGet(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定したスタンプを外します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    messagesMessageIDStampsStampIDDelete(messageID, stampID, options) {
        return StampApiFp(this.configuration).messagesMessageIDStampsStampIDDelete(messageID, stampID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    messagesMessageIDStampsStampIDPost(messageID, stampID, options) {
        return StampApiFp(this.configuration).messagesMessageIDStampsStampIDPost(messageID, stampID, options)(this.axios, this.basePath);
    }
    /**
     * 全スタンプのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsGet(options) {
        return StampApiFp(this.configuration).stampsGet(options)(this.axios, this.basePath);
    }
    /**
     * スタンプを新規作成します。
     * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} file 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsPost(name, file, options) {
        return StampApiFp(this.configuration).stampsPost(name, file, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを削除します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsStampIDDelete(stampID, options) {
        return StampApiFp(this.configuration).stampsStampIDDelete(stampID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプの情報を取得します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsStampIDGet(stampID, options) {
        return StampApiFp(this.configuration).stampsStampIDGet(stampID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを修正します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampsStampIDPatch(stampID, name, file, options) {
        return StampApiFp(this.configuration).stampsStampIDPatch(stampID, name, file, options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    usersMeStampHistoryGet(options) {
        return StampApiFp(this.configuration).usersMeStampHistoryGet(options)(this.axios, this.basePath);
    }
    /**
     * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    usersMeStarsChannelIDDelete(channelID, options) {
        return StarApiFp(this.configuration).usersMeStarsChannelIDDelete(channelID, options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストにチャンネルを追加します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    usersMeStarsChannelIDPut(channelID, options) {
        return StarApiFp(this.configuration).usersMeStarsChannelIDPut(channelID, options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    usersMeStarsGet(options) {
        return StarApiFp(this.configuration).usersMeStarsGet(options)(this.axios, this.basePath);
    }
    /**
     * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    usersMeUnreadChannelsChannelIDDelete(channelID, options) {
        return UnreadApiFp(this.configuration).usersMeUnreadChannelsChannelIDDelete(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 未読チャンネル情報のリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    usersMeUnreadChannelsGet(options) {
        return UnreadApiFp(this.configuration).usersMeUnreadChannelsGet(options)(this.axios, this.basePath);
    }
    /**
     * 全ユーザーのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersGet(options) {
        return UserApiFp(this.configuration).usersGet(options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMeGet(options) {
        return UserApiFp(this.configuration).usersMeGet(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMeIconGet(options) {
        return UserApiFp(this.configuration).usersMeIconGet(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコンを更新します。
     * @param {any} [file] 1MBまでのpng, jpeg, gif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMeIconPut(file, options) {
        return UserApiFp(this.configuration).usersMeIconPut(file, options)(this.axios, this.basePath);
    }
    /**
     * 自分のパスワードを変更します。
     * @param {ChangePassword} [changePassword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMePasswordPut(changePassword, options) {
        return UserApiFp(this.configuration).usersMePasswordPut(changePassword, options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を変更します。
     * @param {UserData} [userData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMePatch(userData, options) {
        return UserApiFp(this.configuration).usersMePatch(userData, options)(this.axios, this.basePath);
    }
    /**
     * 自分のQRコードを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersMeQrCodeGet(options) {
        return UserApiFp(this.configuration).usersMeQrCodeGet(options)(this.axios, this.basePath);
    }
    /**
     * ユーザー登録します
     * @param {UserRegister} [userRegister]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersPost(userRegister, options) {
        return UserApiFp(this.configuration).usersPost(userRegister, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーの詳細を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersUserIDGet(userID, options) {
        return UserApiFp(this.configuration).usersUserIDGet(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのアイコン画像を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    usersUserIDIconGet(userID, options) {
        return UserApiFp(this.configuration).usersUserIDIconGet(userID, options)(this.axios, this.basePath);
    }
    /**
     * 全てのユーザーグループを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGet(options) {
        return UserGroupApiFp(this.configuration).groupsGet(options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDDelete(groupID, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDDelete(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDGet(groupID, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDGet(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループのメンバーのIDを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDMembersGet(groupID, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDMembersGet(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループにメンバーを追加します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {AddUserGroup} [addUserGroup]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDMembersPost(groupID, addUserGroup, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDMembersPost(groupID, addUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループからメンバーを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDMembersUserIDDelete(groupID, userID, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDMembersUserIDDelete(groupID, userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループの情報を変更します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {PatchUserGroup} [patchUserGroup]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsGroupIDPatch(groupID, patchUserGroup, options) {
        return UserGroupApiFp(this.configuration).groupsGroupIDPatch(groupID, patchUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを作成します
     * @param {PostUserGroup} [postUserGroup]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    groupsPost(postUserGroup, options) {
        return UserGroupApiFp(this.configuration).groupsPost(postUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    usersMeGroupsGet(options) {
        return UserGroupApiFp(this.configuration).usersMeGroupsGet(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    usersUserIDGroupsGet(userID, options) {
        return UserGroupApiFp(this.configuration).usersUserIDGroupsGet(userID, options)(this.axios, this.basePath);
    }
    /**
     * 指定されたタグの情報を取得します。
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    tagsTagIDGet(tagID, options) {
        return UserTagApiFp(this.configuration).tagsTagIDGet(tagID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのタグのリストを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    usersUserIDTagsGet(userID, options) {
        return UserTagApiFp(this.configuration).usersUserIDTagsGet(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーにタグを追加します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SetTag} [setTag]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    usersUserIDTagsPost(userID, setTag, options) {
        return UserTagApiFp(this.configuration).usersUserIDTagsPost(userID, setTag, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    usersUserIDTagsTagIDDelete(userID, tagID, options) {
        return UserTagApiFp(this.configuration).usersUserIDTagsTagIDDelete(userID, tagID, options)(this.axios, this.basePath);
    }
    /**
     * タグのロック、アンロックを変更します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {SetTagLock} [setTagLock]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options) {
        return UserTagApiFp(this.configuration).usersUserIDTagsTagIDPatch(userID, tagID, setTagLock, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したwebhookの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksGet(options) {
        return WebhookApiFp(this.configuration).webhooksGet(options)(this.axios, this.basePath);
    }
    /**
     * webhookを作成します。
     * @param {PostWebhook} [postWebhook]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksPost(postWebhook, options) {
        return WebhookApiFp(this.configuration).webhooksPost(postWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookを削除します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDDelete(webhookID, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDDelete(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * webhookの詳細を取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDGet(webhookID, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDGet(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * Github-Compatibleなwebhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDGithubPost(webhookID, body, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDGithubPost(webhookID, body, options)(this.axios, this.basePath);
    }
    /**
     * 指定したWebhookのアイコンを取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDIconGet(webhookID, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDIconGet(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したwebhookのアイコンを変更します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDIconPut(webhookID, file, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDIconPut(webhookID, file, options)(this.axios, this.basePath);
    }
    /**
     * webhookを修正します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {PatchWebhook} [patchWebhook]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDPatch(webhookID, patchWebhook, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDPatch(webhookID, patchWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
     * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options) {
        return WebhookApiFp(this.configuration).webhooksWebhookIDPost(webhookID, xTRAQChannelId, xTRAQSignature, body, options)(this.axios, this.basePath);
    }
}
