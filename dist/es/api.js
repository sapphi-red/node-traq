// tslint:disable
/**
 * traQ API
 * traQ v2 API
 *
 * The version of the OpenAPI document: 2.6.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as globalImportUrl from 'url';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError } from './base';
/**
    * @export
    * @enum {string}
    */
export var ChannelEventTypeEnum;
(function (ChannelEventTypeEnum) {
    ChannelEventTypeEnum["TopicChanged"] = "TopicChanged";
    ChannelEventTypeEnum["SubscribersChanged"] = "SubscribersChanged";
    ChannelEventTypeEnum["PinAdded"] = "PinAdded";
    ChannelEventTypeEnum["PinRemoved"] = "PinRemoved";
    ChannelEventTypeEnum["NameChanged"] = "NameChanged";
    ChannelEventTypeEnum["ParentChanged"] = "ParentChanged";
    ChannelEventTypeEnum["VisibilityChanged"] = "VisibilityChanged";
    ChannelEventTypeEnum["ForcedNotificationChanged"] = "ForcedNotificationChanged";
    ChannelEventTypeEnum["ChildCreated"] = "ChildCreated";
})(ChannelEventTypeEnum || (ChannelEventTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
export var ChannelViewerStateEnum;
(function (ChannelViewerStateEnum) {
    ChannelViewerStateEnum["None"] = "none";
    ChannelViewerStateEnum["Monitoring"] = "monitoring";
    ChannelViewerStateEnum["Editing"] = "editing";
})(ChannelViewerStateEnum || (ChannelViewerStateEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
export var ClientScope;
(function (ClientScope) {
    ClientScope["Read"] = "read";
    ClientScope["Write"] = "write";
    ClientScope["ManageBot"] = "manage_bot";
})(ClientScope || (ClientScope = {}));
/**
 * editing,monitoring,noneのユーザーの状態
 * @export
 * @enum {string}
 */
export var HeartbeatStatus;
(function (HeartbeatStatus) {
    HeartbeatStatus["None"] = "none";
    HeartbeatStatus["Monitoring"] = "monitoring";
    HeartbeatStatus["Editing"] = "editing";
})(HeartbeatStatus || (HeartbeatStatus = {}));
/**
 *
 * @export
 * @enum {string}
 */
export var OAuth2Prompt;
(function (OAuth2Prompt) {
    OAuth2Prompt["None"] = "none";
})(OAuth2Prompt || (OAuth2Prompt = {}));
/**
 *
 * @export
 * @enum {string}
 */
export var OAuth2ResponseType;
(function (OAuth2ResponseType) {
    OAuth2ResponseType["Code"] = "code";
    OAuth2ResponseType["Token"] = "token";
    OAuth2ResponseType["None"] = "none";
})(OAuth2ResponseType || (OAuth2ResponseType = {}));
/**
 * アカウントの状態 (0:停止,1:有効,2:一時停止)
 * @export
 * @enum {string}
 */
export var UserStatus;
(function (UserStatus) {
    UserStatus[UserStatus["NUMBER_0"] = 0] = "NUMBER_0";
    UserStatus[UserStatus["NUMBER_1"] = 1] = "NUMBER_1";
    UserStatus[UserStatus["NUMBER_2"] = 2] = "NUMBER_2";
})(UserStatus || (UserStatus = {}));
/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(limit, subscribe, options = {}) {
            const localVarPath = `/activity/latest-messages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (subscribe !== undefined) {
                localVarQueryParameter['subscribe'] = subscribe;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function (configuration) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(limit, subscribe, options) {
            const localVarAxiosArgs = ActivityApiAxiosParamCreator(configuration).getActivities(limit, subscribe, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
         * @param {number} [limit] 取得する件数 1-50
         * @param {boolean} [subscribe] 購読チャンネルのみを取得する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(limit, subscribe, options) {
            return ActivityApiFp(configuration).getActivities(limit, subscribe, options)(axios, basePath);
        },
    };
};
/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
     * @param {number} [limit] 取得する件数 1-50
     * @param {boolean} [subscribe] 購読チャンネルのみを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    getActivities(limit, subscribe, options) {
        return ActivityApiFp(this.configuration).getActivities(limit, subscribe, options)(this.axios, this.basePath);
    }
}
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {UserLogin} userLogin
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(userLogin, redirect, options = {}) {
            // verify required parameter 'userLogin' is not null or undefined
            if (userLogin === null || userLogin === undefined) {
                throw new RequiredError('userLogin', 'Required parameter userLogin was null or undefined when calling login.');
            }
            const localVarPath = `/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof userLogin !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userLogin !== undefined ? userLogin : {}) : (userLogin || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, options = {}) {
            const localVarPath = `/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {UserLogin} userLogin
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(userLogin, redirect, options) {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).login(userLogin, redirect, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, options) {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).logout(redirect, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
         * @param {UserLogin} userLogin
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(userLogin, redirect, options) {
            return AuthenticationApiFp(configuration).login(userLogin, redirect, options)(axios, basePath);
        },
        /**
         * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
         * @param {string} [redirect] リダイレクト先
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(redirect, options) {
            return AuthenticationApiFp(configuration).logout(redirect, options)(axios, basePath);
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
     * @param {UserLogin} userLogin
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    login(userLogin, redirect, options) {
        return AuthenticationApiFp(this.configuration).login(userLogin, redirect, options)(this.axios, this.basePath);
    }
    /**
     * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logout(redirect, options) {
        return AuthenticationApiFp(this.configuration).logout(redirect, options)(this.axios, this.basePath);
    }
}
/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options = {}) {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling getOauth2Authorize.');
            }
            const localVarPath = `/oauth2/authorize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }
            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            if (codeChallenge !== undefined) {
                localVarQueryParameter['code_challenge'] = codeChallenge;
            }
            if (codeChallengeMethod !== undefined) {
                localVarQueryParameter['code_challenge_method'] = codeChallengeMethod;
            }
            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }
            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options = {}) {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling postOauth2Authorize.');
            }
            const localVarPath = `/oauth2/authorize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (responseType !== undefined) {
                localVarFormParams.set('response_type', responseType);
            }
            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId);
            }
            if (redirectUri !== undefined) {
                localVarFormParams.set('redirect_uri', redirectUri);
            }
            if (scope !== undefined) {
                localVarFormParams.set('scope', scope);
            }
            if (state !== undefined) {
                localVarFormParams.set('state', state);
            }
            if (codeChallenge !== undefined) {
                localVarFormParams.set('code_challenge', codeChallenge);
            }
            if (codeChallengeMethod !== undefined) {
                localVarFormParams.set('code_challenge_method', codeChallengeMethod);
            }
            if (nonce !== undefined) {
                localVarFormParams.set('nonce', nonce);
            }
            if (prompt !== undefined) {
                localVarFormParams.set('prompt', prompt);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2AuthorizeDecide(submit, options = {}) {
            // verify required parameter 'submit' is not null or undefined
            if (submit === null || submit === undefined) {
                throw new RequiredError('submit', 'Required parameter submit was null or undefined when calling postOauth2AuthorizeDecide.');
            }
            const localVarPath = `/oauth2/authorize/decide`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication cookieAuth required
            if (submit !== undefined) {
                localVarFormParams.set('submit', submit);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options = {}) {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType', 'Required parameter grantType was null or undefined when calling postOauth2Token.');
            }
            const localVarPath = `/oauth2/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType);
            }
            if (code !== undefined) {
                localVarFormParams.set('code', code);
            }
            if (redirectUri !== undefined) {
                localVarFormParams.set('redirect_uri', redirectUri);
            }
            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId);
            }
            if (codeVerifier !== undefined) {
                localVarFormParams.set('code_verifier', codeVerifier);
            }
            if (username !== undefined) {
                localVarFormParams.set('username', username);
            }
            if (password !== undefined) {
                localVarFormParams.set('password', password);
            }
            if (scope !== undefined) {
                localVarFormParams.set('scope', scope);
            }
            if (refreshToken !== undefined) {
                localVarFormParams.set('refresh_token', refreshToken);
            }
            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function (configuration) {
    return {
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2AuthorizeDecide(submit, options) {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).postOauth2AuthorizeDecide(submit, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            return AuthorizationApiFp(configuration).getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(axios, basePath);
        },
        /**
         * OAuth2 認可エンドポイント
         * @param {string} clientId
         * @param {OAuth2ResponseType} [responseType]
         * @param {string} [redirectUri]
         * @param {string} [scope]
         * @param {string} [state]
         * @param {string} [codeChallenge]
         * @param {string} [codeChallengeMethod]
         * @param {string} [nonce]
         * @param {OAuth2Prompt} [prompt]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
            return AuthorizationApiFp(configuration).postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(axios, basePath);
        },
        /**
         * OAuth2 認可承諾
         * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2AuthorizeDecide(submit, options) {
            return AuthorizationApiFp(configuration).postOauth2AuthorizeDecide(submit, options)(axios, basePath);
        },
        /**
         * OAuth2 トークンエンドポイント
         * @param {string} grantType
         * @param {string} [code]
         * @param {string} [redirectUri]
         * @param {string} [clientId]
         * @param {string} [codeVerifier]
         * @param {string} [username]
         * @param {string} [password]
         * @param {string} [scope]
         * @param {string} [refreshToken]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
            return AuthorizationApiFp(configuration).postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(axios, basePath);
        },
    };
};
/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     * OAuth2 認可エンドポイント
     * @param {string} clientId
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return AuthorizationApiFp(this.configuration).getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {string} clientId
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return AuthorizationApiFp(this.configuration).postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可承諾
     * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2AuthorizeDecide(submit, options) {
        return AuthorizationApiFp(this.configuration).postOauth2AuthorizeDecide(submit, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 トークンエンドポイント
     * @param {string} grantType
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [clientId]
     * @param {string} [codeVerifier]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [scope]
     * @param {string} [refreshToken]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
        return AuthorizationApiFp(this.configuration).postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(this.axios, this.basePath);
    }
}
/**
 * BotApi - axios parameter creator
 * @export
 */
export const BotApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} postBotChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannelBot(channelID, postBotChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling addChannelBot.');
            }
            // verify required parameter 'postBotChannel' is not null or undefined
            if (postBotChannel === null || postBotChannel === undefined) {
                throw new RequiredError('postBotChannel', 'Required parameter postBotChannel was null or undefined when calling addChannelBot.');
            }
            const localVarPath = `/channels/{channelID}/bots`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postBotChannel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBotChannel !== undefined ? postBotChannel : {}) : (postBotChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} putBotEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotEvents(botID, putBotEvents, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling changeBotEvents.');
            }
            // verify required parameter 'putBotEvents' is not null or undefined
            if (putBotEvents === null || putBotEvents === undefined) {
                throw new RequiredError('putBotEvents', 'Required parameter putBotEvents was null or undefined when calling changeBotEvents.');
            }
            const localVarPath = `/bots/{botID}/events`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putBotEvents !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putBotEvents !== undefined ? putBotEvents : {}) : (putBotEvents || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botID, file, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling changeBotIcon.');
            }
            const localVarPath = `/bots/{botID}/icon`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} putBotState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotState(botID, putBotState, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling changeBotState.');
            }
            // verify required parameter 'putBotState' is not null or undefined
            if (putBotState === null || putBotState === undefined) {
                throw new RequiredError('putBotState', 'Required parameter putBotState was null or undefined when calling changeBotState.');
            }
            const localVarPath = `/bots/{botID}/state`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putBotState !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putBotState !== undefined ? putBotState : {}) : (putBotState || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを作成します。
         * @param {PostBot} postBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBots(postBot, options = {}) {
            // verify required parameter 'postBot' is not null or undefined
            if (postBot === null || postBot === undefined) {
                throw new RequiredError('postBot', 'Required parameter postBot was null or undefined when calling createBots.');
            }
            const localVarPath = `/bots`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postBot !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postBot !== undefined ? postBot : {}) : (postBot || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling deleteBot.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} patchBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botID, patchBot, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling editBot.');
            }
            // verify required parameter 'patchBot' is not null or undefined
            if (patchBot === null || patchBot === undefined) {
                throw new RequiredError('patchBot', 'Required parameter patchBot was null or undefined when calling editBot.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchBot !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchBot !== undefined ? patchBot : {}) : (patchBot || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling getBot.');
            }
            const localVarPath = `/bots/{botID}`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotChannels(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling getBotChannels.');
            }
            const localVarPath = `/bots/{botID}/channels`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotDetail(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling getBotDetail.');
            }
            const localVarPath = `/bots/{botID}/detail`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling getBotIcon.');
            }
            const localVarPath = `/bots/{botID}/icon`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(options = {}) {
            const localVarPath = `/bots`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelBots.');
            }
            const localVarPath = `/channels/{channelID}/bots`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBotTokens(botID, options = {}) {
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling reissueBotTokens.');
            }
            const localVarPath = `/bots/{botID}/reissue`
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChannelBot(channelID, botID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling removeChannelBot.');
            }
            // verify required parameter 'botID' is not null or undefined
            if (botID === null || botID === undefined) {
                throw new RequiredError('botID', 'Required parameter botID was null or undefined when calling removeChannelBot.');
            }
            const localVarPath = `/channels/{channelID}/bots/{botID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)))
                .replace(`{${"botID"}}`, encodeURIComponent(String(botID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BotApi - functional programming interface
 * @export
 */
export const BotApiFp = function (configuration) {
    return {
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} postBotChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannelBot(channelID, postBotChannel, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).addChannelBot(channelID, postBotChannel, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} putBotEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotEvents(botID, putBotEvents, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).changeBotEvents(botID, putBotEvents, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botID, file, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).changeBotIcon(botID, file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} putBotState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotState(botID, putBotState, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).changeBotState(botID, putBotState, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを作成します。
         * @param {PostBot} postBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBots(postBot, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).createBots(postBot, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).deleteBot(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} patchBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botID, patchBot, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).editBot(botID, patchBot, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).getBot(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotChannels(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).getBotChannels(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotDetail(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).getBotDetail(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).getBotIcon(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).getBots(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).getChannelBots(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBotTokens(botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).reissueBotTokens(botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChannelBot(channelID, botID, options) {
            const localVarAxiosArgs = BotApiAxiosParamCreator(configuration).removeChannelBot(channelID, botID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * BotApi - factory interface
 * @export
 */
export const BotApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルにBotを参加させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PostBotChannel} postBotChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannelBot(channelID, postBotChannel, options) {
            return BotApiFp(configuration).addChannelBot(channelID, postBotChannel, options)(axios, basePath);
        },
        /**
         * Botの購読イベントを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotEvents} putBotEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotEvents(botID, putBotEvents, options) {
            return BotApiFp(configuration).changeBotEvents(botID, putBotEvents, options)(axios, basePath);
        },
        /**
         * 指定したBotのアイコンを変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotIcon(botID, file, options) {
            return BotApiFp(configuration).changeBotIcon(botID, file, options)(axios, basePath);
        },
        /**
         * Botの状態を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PutBotState} putBotState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeBotState(botID, putBotState, options) {
            return BotApiFp(configuration).changeBotState(botID, putBotState, options)(axios, basePath);
        },
        /**
         * Botを作成します。
         * @param {PostBot} postBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBots(postBot, options) {
            return BotApiFp(configuration).createBots(postBot, options)(axios, basePath);
        },
        /**
         * Botを削除します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(botID, options) {
            return BotApiFp(configuration).deleteBot(botID, options)(axios, basePath);
        },
        /**
         * Bot情報を変更します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {PatchBot} patchBot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editBot(botID, patchBot, options) {
            return BotApiFp(configuration).editBot(botID, patchBot, options)(axios, basePath);
        },
        /**
         * Botを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBot(botID, options) {
            return BotApiFp(configuration).getBot(botID, options)(axios, basePath);
        },
        /**
         * Botが参加しているチャンネルのUUIDの配列を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotChannels(botID, options) {
            return BotApiFp(configuration).getBotChannels(botID, options)(axios, basePath);
        },
        /**
         * Botの詳細を取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotDetail(botID, options) {
            return BotApiFp(configuration).getBotDetail(botID, options)(axios, basePath);
        },
        /**
         * 指定したBotのアイコンを取得します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotIcon(botID, options) {
            return BotApiFp(configuration).getBotIcon(botID, options)(axios, basePath);
        },
        /**
         * 自分が作成したBotの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(options) {
            return BotApiFp(configuration).getBots(options)(axios, basePath);
        },
        /**
         * チャンネルに参加しているBot一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelBots(channelID, options) {
            return BotApiFp(configuration).getChannelBots(channelID, options)(axios, basePath);
        },
        /**
         * Botの各種トークンを再発行します。
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reissueBotTokens(botID, options) {
            return BotApiFp(configuration).reissueBotTokens(botID, options)(axios, basePath);
        },
        /**
         * Botをチャンネルから退出させます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {string} botID 操作の対象となるBotのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChannelBot(channelID, botID, options) {
            return BotApiFp(configuration).removeChannelBot(channelID, botID, options)(axios, basePath);
        },
    };
};
/**
 * BotApi - object-oriented interface
 * @export
 * @class BotApi
 * @extends {BaseAPI}
 */
export class BotApi extends BaseAPI {
    /**
     * チャンネルにBotを参加させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PostBotChannel} postBotChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    addChannelBot(channelID, postBotChannel, options) {
        return BotApiFp(this.configuration).addChannelBot(channelID, postBotChannel, options)(this.axios, this.basePath);
    }
    /**
     * Botの購読イベントを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotEvents} putBotEvents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotEvents(botID, putBotEvents, options) {
        return BotApiFp(this.configuration).changeBotEvents(botID, putBotEvents, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotIcon(botID, file, options) {
        return BotApiFp(this.configuration).changeBotIcon(botID, file, options)(this.axios, this.basePath);
    }
    /**
     * Botの状態を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotState} putBotState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotState(botID, putBotState, options) {
        return BotApiFp(this.configuration).changeBotState(botID, putBotState, options)(this.axios, this.basePath);
    }
    /**
     * Botを作成します。
     * @param {PostBot} postBot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    createBots(postBot, options) {
        return BotApiFp(this.configuration).createBots(postBot, options)(this.axios, this.basePath);
    }
    /**
     * Botを削除します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    deleteBot(botID, options) {
        return BotApiFp(this.configuration).deleteBot(botID, options)(this.axios, this.basePath);
    }
    /**
     * Bot情報を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PatchBot} patchBot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    editBot(botID, patchBot, options) {
        return BotApiFp(this.configuration).editBot(botID, patchBot, options)(this.axios, this.basePath);
    }
    /**
     * Botを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBot(botID, options) {
        return BotApiFp(this.configuration).getBot(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botが参加しているチャンネルのUUIDの配列を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotChannels(botID, options) {
        return BotApiFp(this.configuration).getBotChannels(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの詳細を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotDetail(botID, options) {
        return BotApiFp(this.configuration).getBotDetail(botID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotIcon(botID, options) {
        return BotApiFp(this.configuration).getBotIcon(botID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したBotの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBots(options) {
        return BotApiFp(this.configuration).getBots(options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに参加しているBot一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getChannelBots(channelID, options) {
        return BotApiFp(this.configuration).getChannelBots(channelID, options)(this.axios, this.basePath);
    }
    /**
     * Botの各種トークンを再発行します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    reissueBotTokens(botID, options) {
        return BotApiFp(this.configuration).reissueBotTokens(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botをチャンネルから退出させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    removeChannelBot(channelID, botID, options) {
        return BotApiFp(this.configuration).removeChannelBot(channelID, botID, options)(this.axios, this.basePath);
    }
}
/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} putParentChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelParent(channelID, putParentChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling changeChannelParent.');
            }
            // verify required parameter 'putParentChannel' is not null or undefined
            if (putParentChannel === null || putParentChannel === undefined) {
                throw new RequiredError('putParentChannel', 'Required parameter putParentChannel was null or undefined when calling changeChannelParent.');
            }
            const localVarPath = `/channels/{channelID}/parent`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putParentChannel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putParentChannel !== undefined ? putParentChannel : {}) : (putParentChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} setChannelTopic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelTopic(channelID, setChannelTopic, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling changeChannelTopic.');
            }
            // verify required parameter 'setChannelTopic' is not null or undefined
            if (setChannelTopic === null || setChannelTopic === undefined) {
                throw new RequiredError('setChannelTopic', 'Required parameter setChannelTopic was null or undefined when calling changeChannelTopic.');
            }
            const localVarPath = `/channels/{channelID}/topic`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof setChannelTopic !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setChannelTopic !== undefined ? setChannelTopic : {}) : (setChannelTopic || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} createChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(createChannel, options = {}) {
            // verify required parameter 'createChannel' is not null or undefined
            if (createChannel === null || createChannel === undefined) {
                throw new RequiredError('createChannel', 'Required parameter createChannel was null or undefined when calling createChannel.');
            }
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof createChannel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createChannel !== undefined ? createChannel : {}) : (createChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} createChannelChild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelChild(channelID, createChannelChild, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling createChannelChild.');
            }
            // verify required parameter 'createChannelChild' is not null or undefined
            if (createChannelChild === null || createChannelChild === undefined) {
                throw new RequiredError('createChannelChild', 'Required parameter createChannelChild was null or undefined when calling createChannelChild.');
            }
            const localVarPath = `/channels/{channelID}/children`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof createChannelChild !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createChannelChild !== undefined ? createChannelChild : {}) : (createChannelChild || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling deleteChannel.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} patchChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelID, patchChannel, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling editChannel.');
            }
            // verify required parameter 'patchChannel' is not null or undefined
            if (patchChannel === null || patchChannel === undefined) {
                throw new RequiredError('patchChannel', 'Required parameter patchChannel was null or undefined when calling editChannel.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchChannel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchChannel !== undefined ? patchChannel : {}) : (patchChannel || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannel.');
            }
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelEvents.');
            }
            const localVarPath = `/channels/{channelID}/events`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの統計情報を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelStats.');
            }
            const localVarPath = `/channels/{channelID}/stats`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelTopic.');
            }
            const localVarPath = `/channels/{channelID}/topic`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 現在のチャンネル閲覧者のリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelViewers.');
            }
            const localVarPath = `/channels/{channelID}/viewers`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options = {}) {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function (configuration) {
    return {
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} putParentChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelParent(channelID, putParentChannel, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).changeChannelParent(channelID, putParentChannel, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} setChannelTopic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelTopic(channelID, setChannelTopic, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).changeChannelTopic(channelID, setChannelTopic, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} createChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(createChannel, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).createChannel(createChannel, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} createChannelChild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelChild(channelID, createChannelChild, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).createChannelChild(channelID, createChannelChild, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(channelID, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).deleteChannel(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} patchChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelID, patchChannel, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).editChannel(channelID, patchChannel, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelID, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).getChannel(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの統計情報を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelID, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).getChannelStats(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelID, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).getChannelTopic(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 現在のチャンネル閲覧者のリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelID, options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).getChannelViewers(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options) {
            const localVarAxiosArgs = ChannelApiAxiosParamCreator(configuration).getChannels(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルの親チャンネルを変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PutParentChannel} putParentChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelParent(channelID, putParentChannel, options) {
            return ChannelApiFp(configuration).changeChannelParent(channelID, putParentChannel, options)(axios, basePath);
        },
        /**
         * チャンネルの説明を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SetChannelTopic} setChannelTopic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeChannelTopic(channelID, setChannelTopic, options) {
            return ChannelApiFp(configuration).changeChannelTopic(channelID, setChannelTopic, options)(axios, basePath);
        },
        /**
         * チャンネルを作成します。
         * @param {CreateChannel} createChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(createChannel, options) {
            return ChannelApiFp(configuration).createChannel(createChannel, options)(axios, basePath);
        },
        /**
         * 子チャンネルを作成します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {CreateChannelChild} createChannelChild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelChild(channelID, createChannelChild, options) {
            return ChannelApiFp(configuration).createChannelChild(channelID, createChannelChild, options)(axios, basePath);
        },
        /**
         * チャンネルを削除します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(channelID, options) {
            return ChannelApiFp(configuration).deleteChannel(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルの情報を変更します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {PatchChannel} patchChannel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editChannel(channelID, patchChannel, options) {
            return ChannelApiFp(configuration).editChannel(channelID, patchChannel, options)(axios, basePath);
        },
        /**
         * チャンネルの情報を返します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelID, options) {
            return ChannelApiFp(configuration).getChannel(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルイベントのリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options) {
            return ChannelApiFp(configuration).getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * チャンネルの統計情報を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelStats(channelID, options) {
            return ChannelApiFp(configuration).getChannelStats(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルの説明を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTopic(channelID, options) {
            return ChannelApiFp(configuration).getChannelTopic(channelID, options)(axios, basePath);
        },
        /**
         * 現在のチャンネル閲覧者のリストを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelViewers(channelID, options) {
            return ChannelApiFp(configuration).getChannelViewers(channelID, options)(axios, basePath);
        },
        /**
         * (すべての)チャンネルのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options) {
            return ChannelApiFp(configuration).getChannels(options)(axios, basePath);
        },
    };
};
/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
    /**
     * チャンネルの親チャンネルを変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PutParentChannel} putParentChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    changeChannelParent(channelID, putParentChannel, options) {
        return ChannelApiFp(this.configuration).changeChannelParent(channelID, putParentChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SetChannelTopic} setChannelTopic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    changeChannelTopic(channelID, setChannelTopic, options) {
        return ChannelApiFp(this.configuration).changeChannelTopic(channelID, setChannelTopic, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを作成します。
     * @param {CreateChannel} createChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannel(createChannel, options) {
        return ChannelApiFp(this.configuration).createChannel(createChannel, options)(this.axios, this.basePath);
    }
    /**
     * 子チャンネルを作成します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {CreateChannelChild} createChannelChild
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannelChild(channelID, createChannelChild, options) {
        return ChannelApiFp(this.configuration).createChannelChild(channelID, createChannelChild, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを削除します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    deleteChannel(channelID, options) {
        return ChannelApiFp(this.configuration).deleteChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PatchChannel} patchChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannel(channelID, patchChannel, options) {
        return ChannelApiFp(this.configuration).editChannel(channelID, patchChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannel(channelID, options) {
        return ChannelApiFp(this.configuration).getChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルイベントのリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options) {
        return ChannelApiFp(this.configuration).getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの統計情報を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelStats(channelID, options) {
        return ChannelApiFp(this.configuration).getChannelStats(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelTopic(channelID, options) {
        return ChannelApiFp(this.configuration).getChannelTopic(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 現在のチャンネル閲覧者のリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelViewers(channelID, options) {
        return ChannelApiFp(this.configuration).getChannelViewers(channelID, options)(this.axios, this.basePath);
    }
    /**
     * (すべての)チャンネルのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannels(options) {
        return ChannelApiFp(this.configuration).getChannels(options)(this.axios, this.basePath);
    }
}
/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * クライアントを登録します。
         * @param {PostClient} postClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClient, options = {}) {
            // verify required parameter 'postClient' is not null or undefined
            if (postClient === null || postClient === undefined) {
                throw new RequiredError('postClient', 'Required parameter postClient was null or undefined when calling createClient.');
            }
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postClient !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postClient !== undefined ? postClient : {}) : (postClient || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new RequiredError('clientID', 'Required parameter clientID was null or undefined when calling deleteClient.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(oauth2TokenID, options = {}) {
            // verify required parameter 'oauth2TokenID' is not null or undefined
            if (oauth2TokenID === null || oauth2TokenID === undefined) {
                throw new RequiredError('oauth2TokenID', 'Required parameter oauth2TokenID was null or undefined when calling deleteToken.');
            }
            const localVarPath = `/users/me/tokens/{oauth2TokenID}`
                .replace(`{${"oauth2TokenID"}}`, encodeURIComponent(String(oauth2TokenID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new RequiredError('clientID', 'Required parameter clientID was null or undefined when calling getClient.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientDetail(clientID, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new RequiredError('clientID', 'Required parameter clientID was null or undefined when calling getClientDetail.');
            }
            const localVarPath = `/clients/{clientID}/detail`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(options = {}) {
            const localVarPath = `/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options = {}) {
            const localVarPath = `/users/me/tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} patchClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchClient(clientID, patchClient, options = {}) {
            // verify required parameter 'clientID' is not null or undefined
            if (clientID === null || clientID === undefined) {
                throw new RequiredError('clientID', 'Required parameter clientID was null or undefined when calling patchClient.');
            }
            // verify required parameter 'patchClient' is not null or undefined
            if (patchClient === null || patchClient === undefined) {
                throw new RequiredError('patchClient', 'Required parameter patchClient was null or undefined when calling patchClient.');
            }
            const localVarPath = `/clients/{clientID}`
                .replace(`{${"clientID"}}`, encodeURIComponent(String(clientID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchClient !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchClient !== undefined ? patchClient : {}) : (patchClient || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function (configuration) {
    return {
        /**
         * クライアントを登録します。
         * @param {PostClient} postClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClient, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).createClient(postClient, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientID, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).deleteClient(clientID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(oauth2TokenID, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).deleteToken(oauth2TokenID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientID, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).getClient(clientID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientDetail(clientID, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).getClientDetail(clientID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).getClients(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).getTokens(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} patchClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchClient(clientID, patchClient, options) {
            const localVarAxiosArgs = ClientApiAxiosParamCreator(configuration).patchClient(clientID, patchClient, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * クライアントを登録します。
         * @param {PostClient} postClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(postClient, options) {
            return ClientApiFp(configuration).createClient(postClient, options)(axios, basePath);
        },
        /**
         * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientID, options) {
            return ClientApiFp(configuration).deleteClient(clientID, options)(axios, basePath);
        },
        /**
         * 指定したトークンの認可を取り消します。
         * @param {string} oauth2TokenID 操作の対象となるTokenのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(oauth2TokenID, options) {
            return ClientApiFp(configuration).deleteToken(oauth2TokenID, options)(axios, basePath);
        },
        /**
         * 指定したクライアントIDのクライアントの情報を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClient(clientID, options) {
            return ClientApiFp(configuration).getClient(clientID, options)(axios, basePath);
        },
        /**
         * クライアントの詳細を取得します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientDetail(clientID, options) {
            return ClientApiFp(configuration).getClientDetail(clientID, options)(axios, basePath);
        },
        /**
         * 自分が登録しているクライアントの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClients(options) {
            return ClientApiFp(configuration).getClients(options)(axios, basePath);
        },
        /**
         * 自分が許可しているクライアントの一覧とトークン情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options) {
            return ClientApiFp(configuration).getTokens(options)(axios, basePath);
        },
        /**
         * 指定したクライアントIDのクライアントの情報を変更します。
         * @param {string} clientID 操作の対象となるclientのID
         * @param {PatchClient} patchClient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchClient(clientID, patchClient, options) {
            return ClientApiFp(configuration).patchClient(clientID, patchClient, options)(axios, basePath);
        },
    };
};
/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * クライアントを登録します。
     * @param {PostClient} postClient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    createClient(postClient, options) {
        return ClientApiFp(this.configuration).createClient(postClient, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    deleteClient(clientID, options) {
        return ClientApiFp(this.configuration).deleteClient(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したトークンの認可を取り消します。
     * @param {string} oauth2TokenID 操作の対象となるTokenのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    deleteToken(oauth2TokenID, options) {
        return ClientApiFp(this.configuration).deleteToken(oauth2TokenID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClient(clientID, options) {
        return ClientApiFp(this.configuration).getClient(clientID, options)(this.axios, this.basePath);
    }
    /**
     * クライアントの詳細を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClientDetail(clientID, options) {
        return ClientApiFp(this.configuration).getClientDetail(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が登録しているクライアントの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClients(options) {
        return ClientApiFp(this.configuration).getClients(options)(this.axios, this.basePath);
    }
    /**
     * 自分が許可しているクライアントの一覧とトークン情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getTokens(options) {
        return ClientApiFp(this.configuration).getTokens(options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を変更します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {PatchClient} patchClient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    patchClient(clientID, patchClient, options) {
        return ClientApiFp(this.configuration).patchClient(clientID, patchClient, options)(this.axios, this.basePath);
    }
}
/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID', 'Required parameter fileID was null or undefined when calling deleteFile.');
            }
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileID, dl, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID', 'Required parameter fileID was null or undefined when calling getFile.');
            }
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (dl !== undefined) {
                localVarQueryParameter['dl'] = dl;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID', 'Required parameter fileID was null or undefined when calling getFileMeta.');
            }
            const localVarPath = `/files/{fileID}/meta`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileThumbnail(fileID, options = {}) {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID', 'Required parameter fileID was null or undefined when calling getFileThumbnail.');
            }
            const localVarPath = `/files/{fileID}/thumbnail`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file, aclReadable, options = {}) {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling uploadFile.');
            }
            const localVarPath = `/files`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (aclReadable !== undefined) {
                localVarFormParams.append('acl_readable', aclReadable);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function (configuration) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileID, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).deleteFile(fileID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileID, dl, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).getFile(fileID, dl, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileID, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).getFileMeta(fileID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileThumbnail(fileID, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).getFileThumbnail(fileID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file, aclReadable, options) {
            const localVarAxiosArgs = FileApiAxiosParamCreator(configuration).uploadFile(file, aclReadable, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したファイルを削除します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileID, options) {
            return FileApiFp(configuration).deleteFile(fileID, options)(axios, basePath);
        },
        /**
         * 指定したファイルの中身を取得します。
         * @param {string} fileID 操作の対象となるファイルID
         * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileID, dl, options) {
            return FileApiFp(configuration).getFile(fileID, dl, options)(axios, basePath);
        },
        /**
         * 指定したファイルのメタデータを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileID, options) {
            return FileApiFp(configuration).getFileMeta(fileID, options)(axios, basePath);
        },
        /**
         * 指定したファイルのサムネイルを取得します
         * @param {string} fileID 操作の対象となるファイルID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileThumbnail(fileID, options) {
            return FileApiFp(configuration).getFileThumbnail(fileID, options)(axios, basePath);
        },
        /**
         * ファイルをアップロードします
         * @param {any} file ファイル本体
         * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file, aclReadable, options) {
            return FileApiFp(configuration).uploadFile(file, aclReadable, options)(axios, basePath);
        },
    };
};
/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * 指定したファイルを削除します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    deleteFile(fileID, options) {
        return FileApiFp(this.configuration).deleteFile(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルの中身を取得します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFile(fileID, dl, options) {
        return FileApiFp(this.configuration).getFile(fileID, dl, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのメタデータを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileMeta(fileID, options) {
        return FileApiFp(this.configuration).getFileMeta(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのサムネイルを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileThumbnail(fileID, options) {
        return FileApiFp(this.configuration).getFileThumbnail(fileID, options)(this.axios, this.basePath);
    }
    /**
     * ファイルをアップロードします
     * @param {any} file ファイル本体
     * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    uploadFile(file, aclReadable, options) {
        return FileApiFp(this.configuration).uploadFile(file, aclReadable, options)(this.axios, this.basePath);
    }
}
/**
 * HeartbeatApi - axios parameter creator
 * @export
 */
export const HeartbeatApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeartbeat(channelId, options = {}) {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getHeartbeat.');
            }
            const localVarPath = `/heartbeat`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} heartbeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postHeartbeat(heartbeat, options = {}) {
            // verify required parameter 'heartbeat' is not null or undefined
            if (heartbeat === null || heartbeat === undefined) {
                throw new RequiredError('heartbeat', 'Required parameter heartbeat was null or undefined when calling postHeartbeat.');
            }
            const localVarPath = `/heartbeat`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof heartbeat !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(heartbeat !== undefined ? heartbeat : {}) : (heartbeat || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * HeartbeatApi - functional programming interface
 * @export
 */
export const HeartbeatApiFp = function (configuration) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeartbeat(channelId, options) {
            const localVarAxiosArgs = HeartbeatApiAxiosParamCreator(configuration).getHeartbeat(channelId, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} heartbeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postHeartbeat(heartbeat, options) {
            const localVarAxiosArgs = HeartbeatApiAxiosParamCreator(configuration).postHeartbeat(heartbeat, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * HeartbeatApi - factory interface
 * @export
 */
export const HeartbeatApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルを現在見ている人・編集している人を取得します。
         * @param {string} channelId 現在いるチャンネルId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeartbeat(channelId, options) {
            return HeartbeatApiFp(configuration).getHeartbeat(channelId, options)(axios, basePath);
        },
        /**
         * どのチャンネルを見ているか・編集しているかを送信します。
         * @param {Heartbeat} heartbeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postHeartbeat(heartbeat, options) {
            return HeartbeatApiFp(configuration).postHeartbeat(heartbeat, options)(axios, basePath);
        },
    };
};
/**
 * HeartbeatApi - object-oriented interface
 * @export
 * @class HeartbeatApi
 * @extends {BaseAPI}
 */
export class HeartbeatApi extends BaseAPI {
    /**
     * チャンネルを現在見ている人・編集している人を取得します。
     * @param {string} channelId 現在いるチャンネルId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    getHeartbeat(channelId, options) {
        return HeartbeatApiFp(this.configuration).getHeartbeat(channelId, options)(this.axios, this.basePath);
    }
    /**
     * どのチャンネルを見ているか・編集しているかを送信します。
     * @param {Heartbeat} heartbeat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    postHeartbeat(heartbeat, options) {
        return HeartbeatApiFp(this.configuration).postHeartbeat(heartbeat, options)(this.axios, this.basePath);
    }
}
/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling deleteMessage.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} sendMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageID, sendMessage, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling editMessage.');
            }
            // verify required parameter 'sendMessage' is not null or undefined
            if (sendMessage === null || sendMessage === undefined) {
                throw new RequiredError('sendMessage', 'Required parameter sendMessage was null or undefined when calling editMessage.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof sendMessage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling getDirectMessages.');
            }
            const localVarPath = `/users/{userID}/messages`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling getMessage.');
            }
            const localVarPath = `/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelID, limit, offset, since, until, inclusive, order, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getMessages.');
            }
            const localVarPath = `/channels/{channelID}/messages`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (until !== undefined) {
                localVarQueryParameter['until'] = until.toISOString();
            }
            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(p, options = {}) {
            const localVarPath = `/messages/reports`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            if (p !== undefined) {
                localVarQueryParameter['p'] = p;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userID, sendMessage, embed, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling postDirectMessage.');
            }
            // verify required parameter 'sendMessage' is not null or undefined
            if (sendMessage === null || sendMessage === undefined) {
                throw new RequiredError('sendMessage', 'Required parameter sendMessage was null or undefined when calling postDirectMessage.');
            }
            const localVarPath = `/users/{userID}/messages`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof sendMessage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelID, sendMessage, embed, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling postMessage.');
            }
            // verify required parameter 'sendMessage' is not null or undefined
            if (sendMessage === null || sendMessage === undefined) {
                throw new RequiredError('sendMessage', 'Required parameter sendMessage was null or undefined when calling postMessage.');
            }
            const localVarPath = `/channels/{channelID}/messages`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof sendMessage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendMessage !== undefined ? sendMessage : {}) : (sendMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} reportMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMessage(messageID, reportMessage, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling reportMessage.');
            }
            // verify required parameter 'reportMessage' is not null or undefined
            if (reportMessage === null || reportMessage === undefined) {
                throw new RequiredError('reportMessage', 'Required parameter reportMessage was null or undefined when calling reportMessage.');
            }
            const localVarPath = `/messages/{messageID}/report`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof reportMessage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(reportMessage !== undefined ? reportMessage : {}) : (reportMessage || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function (configuration) {
    return {
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageID, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).deleteMessage(messageID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} sendMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageID, sendMessage, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).editMessage(messageID, sendMessage, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).getDirectMessages(userID, limit, offset, since, until, inclusive, order, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageID, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).getMessage(messageID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelID, limit, offset, since, until, inclusive, order, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).getMessages(channelID, limit, offset, since, until, inclusive, order, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(p, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).getReports(p, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userID, sendMessage, embed, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).postDirectMessage(userID, sendMessage, embed, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelID, sendMessage, embed, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).postMessage(channelID, sendMessage, embed, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} reportMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMessage(messageID, reportMessage, options) {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).reportMessage(messageID, reportMessage, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したメッセージを削除します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageID, options) {
            return MessageApiFp(configuration).deleteMessage(messageID, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを編集します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {SendMessage} sendMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(messageID, sendMessage, options) {
            return MessageApiFp(configuration).editMessage(messageID, sendMessage, options)(axios, basePath);
        },
        /**
         * DMチャンネルに存在するメッセージを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectMessages(userID, limit, offset, since, until, inclusive, order, options) {
            return MessageApiFp(configuration).getDirectMessages(userID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(messageID, options) {
            return MessageApiFp(configuration).getMessage(messageID, options)(axios, basePath);
        },
        /**
         * チャンネルに存在するメッセージを取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {number} [limit] 取得する件数 1-200
         * @param {number} [offset] 取得するオフセット
         * @param {Date} [since] 取得する時間範囲の開始日時
         * @param {Date} [until] 取得する時間範囲の終了日時
         * @param {boolean} [inclusive] 範囲の端を含めるかどうか
         * @param {'asc' | 'desc'} [order] 昇順か降順か
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(channelID, limit, offset, since, until, inclusive, order, options) {
            return MessageApiFp(configuration).getMessages(channelID, limit, offset, since, until, inclusive, order, options)(axios, basePath);
        },
        /**
         * メッセージ通報を最大50件取得します。
         * @param {number} [p] ページ番号(ゼロオリジン)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(p, options) {
            return MessageApiFp(configuration).getReports(p, options)(axios, basePath);
        },
        /**
         * DMチャンネルにメッセージを投稿します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectMessage(userID, sendMessage, embed, options) {
            return MessageApiFp(configuration).postDirectMessage(userID, sendMessage, embed, options)(axios, basePath);
        },
        /**
         * チャンネルにメッセージを投稿します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {SendMessage} sendMessage
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(channelID, sendMessage, embed, options) {
            return MessageApiFp(configuration).postMessage(channelID, sendMessage, embed, options)(axios, basePath);
        },
        /**
         * 指定したメッセージを通報します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {ReportMessage} reportMessage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMessage(messageID, reportMessage, options) {
            return MessageApiFp(configuration).reportMessage(messageID, reportMessage, options)(axios, basePath);
        },
    };
};
/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * 指定したメッセージを削除します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    deleteMessage(messageID, options) {
        return MessageApiFp(this.configuration).deleteMessage(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを編集します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {SendMessage} sendMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    editMessage(messageID, sendMessage, options) {
        return MessageApiFp(this.configuration).editMessage(messageID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルに存在するメッセージを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getDirectMessages(userID, limit, offset, since, until, inclusive, order, options) {
        return MessageApiFp(this.configuration).getDirectMessages(userID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessage(messageID, options) {
        return MessageApiFp(this.configuration).getMessage(messageID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに存在するメッセージを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessages(channelID, limit, offset, since, until, inclusive, order, options) {
        return MessageApiFp(this.configuration).getMessages(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * メッセージ通報を最大50件取得します。
     * @param {number} [p] ページ番号(ゼロオリジン)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getReports(p, options) {
        return MessageApiFp(this.configuration).getReports(p, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルにメッセージを投稿します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SendMessage} sendMessage
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postDirectMessage(userID, sendMessage, embed, options) {
        return MessageApiFp(this.configuration).postDirectMessage(userID, sendMessage, embed, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージを投稿します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SendMessage} sendMessage
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postMessage(channelID, sendMessage, embed, options) {
        return MessageApiFp(this.configuration).postMessage(channelID, sendMessage, embed, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを通報します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {ReportMessage} reportMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    reportMessage(messageID, reportMessage, options) {
        return MessageApiFp(this.configuration).reportMessage(messageID, reportMessage, options)(this.axios, this.basePath);
    }
}
/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} notificationUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscribers(channelID, notificationUsers, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling changeSubscribers.');
            }
            // verify required parameter 'notificationUsers' is not null or undefined
            if (notificationUsers === null || notificationUsers === undefined) {
                throw new RequiredError('notificationUsers', 'Required parameter notificationUsers was null or undefined when calling changeSubscribers.');
            }
            const localVarPath = `/channels/{channelID}/notification`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof notificationUsers !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(notificationUsers !== undefined ? notificationUsers : {}) : (notificationUsers || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectNotification(options = {}) {
            const localVarPath = `/notification`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySubscribeChannels(options = {}) {
            const localVarPath = `/users/me/notification`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribers(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getSubscribers.');
            }
            const localVarPath = `/channels/{channelID}/notification`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscribeChannels(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling getUserSubscribeChannels.');
            }
            const localVarPath = `/users/{userID}/notification`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} fCMToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNotificationDevice(fCMToken, options = {}) {
            // verify required parameter 'fCMToken' is not null or undefined
            if (fCMToken === null || fCMToken === undefined) {
                throw new RequiredError('fCMToken', 'Required parameter fCMToken was null or undefined when calling registerNotificationDevice.');
            }
            const localVarPath = `/notification/device`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof fCMToken !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(fCMToken !== undefined ? fCMToken : {}) : (fCMToken || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function (configuration) {
    return {
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} notificationUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscribers(channelID, notificationUsers, options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).changeSubscribers(channelID, notificationUsers, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectNotification(options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).connectNotification(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySubscribeChannels(options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).getMySubscribeChannels(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribers(channelID, options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).getSubscribers(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscribeChannels(userID, options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).getUserSubscribeChannels(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} fCMToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNotificationDevice(fCMToken, options) {
            const localVarAxiosArgs = NotificationApiAxiosParamCreator(configuration).registerNotificationDevice(fCMToken, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {NotificationUsers} notificationUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscribers(channelID, notificationUsers, options) {
            return NotificationApiFp(configuration).changeSubscribers(channelID, notificationUsers, options)(axios, basePath);
        },
        /**
         * 通知ストリーム(Server Sent Events)に接続します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectNotification(options) {
            return NotificationApiFp(configuration).connectNotification(options)(axios, basePath);
        },
        /**
         * 自分が通知を入れているチャンネルのリストを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySubscribeChannels(options) {
            return NotificationApiFp(configuration).getMySubscribeChannels(options)(axios, basePath);
        },
        /**
         * 通知を点けているユーザーのIDの配列を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribers(channelID, options) {
            return NotificationApiFp(configuration).getSubscribers(channelID, options)(axios, basePath);
        },
        /**
         * ユーザーが通知を入れているチャンネルのリストを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscribeChannels(userID, options) {
            return NotificationApiFp(configuration).getUserSubscribeChannels(userID, options)(axios, basePath);
        },
        /**
         * FCMデバイスを登録します。
         * @param {FCMToken} fCMToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNotificationDevice(fCMToken, options) {
            return NotificationApiFp(configuration).registerNotificationDevice(fCMToken, options)(axios, basePath);
        },
    };
};
/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {NotificationUsers} notificationUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    changeSubscribers(channelID, notificationUsers, options) {
        return NotificationApiFp(this.configuration).changeSubscribers(channelID, notificationUsers, options)(this.axios, this.basePath);
    }
    /**
     * 通知ストリーム(Server Sent Events)に接続します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    connectNotification(options) {
        return NotificationApiFp(this.configuration).connectNotification(options)(this.axios, this.basePath);
    }
    /**
     * 自分が通知を入れているチャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getMySubscribeChannels(options) {
        return NotificationApiFp(this.configuration).getMySubscribeChannels(options)(this.axios, this.basePath);
    }
    /**
     * 通知を点けているユーザーのIDの配列を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getSubscribers(channelID, options) {
        return NotificationApiFp(this.configuration).getSubscribers(channelID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーが通知を入れているチャンネルのリストを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getUserSubscribeChannels(userID, options) {
        return NotificationApiFp(this.configuration).getUserSubscribeChannels(userID, options)(this.axios, this.basePath);
    }
    /**
     * FCMデバイスを登録します。
     * @param {FCMToken} fCMToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    registerNotificationDevice(fCMToken, options) {
        return NotificationApiFp(this.configuration).registerNotificationDevice(fCMToken, options)(this.axios, this.basePath);
    }
}
/**
 * PinApi - axios parameter creator
 * @export
 */
export const PinApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessage(pinID, options = {}) {
            // verify required parameter 'pinID' is not null or undefined
            if (pinID === null || pinID === undefined) {
                throw new RequiredError('pinID', 'Required parameter pinID was null or undefined when calling getPinnedMessage.');
            }
            const localVarPath = `/pins/{pinID}`
                .replace(`{${"pinID"}}`, encodeURIComponent(String(pinID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessages(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getPinnedMessages.');
            }
            const localVarPath = `/channels/{channelID}/pins`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} messageIDObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessage(messageIDObject, options = {}) {
            // verify required parameter 'messageIDObject' is not null or undefined
            if (messageIDObject === null || messageIDObject === undefined) {
                throw new RequiredError('messageIDObject', 'Required parameter messageIDObject was null or undefined when calling pinMessage.');
            }
            const localVarPath = `/pins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof messageIDObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(messageIDObject !== undefined ? messageIDObject : {}) : (messageIDObject || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinMessage(pinID, options = {}) {
            // verify required parameter 'pinID' is not null or undefined
            if (pinID === null || pinID === undefined) {
                throw new RequiredError('pinID', 'Required parameter pinID was null or undefined when calling unpinMessage.');
            }
            const localVarPath = `/pins/{pinID}`
                .replace(`{${"pinID"}}`, encodeURIComponent(String(pinID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PinApi - functional programming interface
 * @export
 */
export const PinApiFp = function (configuration) {
    return {
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessage(pinID, options) {
            const localVarAxiosArgs = PinApiAxiosParamCreator(configuration).getPinnedMessage(pinID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessages(channelID, options) {
            const localVarAxiosArgs = PinApiAxiosParamCreator(configuration).getPinnedMessages(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} messageIDObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessage(messageIDObject, options) {
            const localVarAxiosArgs = PinApiAxiosParamCreator(configuration).pinMessage(messageIDObject, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinMessage(pinID, options) {
            const localVarAxiosArgs = PinApiAxiosParamCreator(configuration).unpinMessage(pinID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PinApi - factory interface
 * @export
 */
export const PinApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ピン留めを取得します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessage(pinID, options) {
            return PinApiFp(configuration).getPinnedMessage(pinID, options)(axios, basePath);
        },
        /**
         * チャンネルのピン留め一覧を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPinnedMessages(channelID, options) {
            return PinApiFp(configuration).getPinnedMessages(channelID, options)(axios, basePath);
        },
        /**
         * チャンネルにメッセージをピン留めします。
         * @param {MessageIDObject} messageIDObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessage(messageIDObject, options) {
            return PinApiFp(configuration).pinMessage(messageIDObject, options)(axios, basePath);
        },
        /**
         * ピン留めを外します。
         * @param {string} pinID 操作の対象となるピン留めID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinMessage(pinID, options) {
            return PinApiFp(configuration).unpinMessage(pinID, options)(axios, basePath);
        },
    };
};
/**
 * PinApi - object-oriented interface
 * @export
 * @class PinApi
 * @extends {BaseAPI}
 */
export class PinApi extends BaseAPI {
    /**
     * ピン留めを取得します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPinnedMessage(pinID, options) {
        return PinApiFp(this.configuration).getPinnedMessage(pinID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのピン留め一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPinnedMessages(channelID, options) {
        return PinApiFp(this.configuration).getPinnedMessages(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージをピン留めします。
     * @param {MessageIDObject} messageIDObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinMessage(messageIDObject, options) {
        return PinApiFp(this.configuration).pinMessage(messageIDObject, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを外します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    unpinMessage(pinID, options) {
        return PinApiFp(this.configuration).unpinMessage(pinID, options)(this.axios, this.basePath);
    }
}
/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options = {}) {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username', 'Required parameter username was null or undefined when calling getPublicUserIcon.');
            }
            const localVarPath = `/public/icon/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function (configuration) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options) {
            const localVarAxiosArgs = PublicApiAxiosParamCreator(configuration).getPublicUserIcon(username, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したユーザーのアイコン画像を取得します。
         * @param {string} username 画像を取得するユーザーのユーザー名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserIcon(username, options) {
            return PublicApiFp(configuration).getPublicUserIcon(username, options)(axios, basePath);
        },
    };
};
/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 指定したユーザーのアイコン画像を取得します。
     * @param {string} username 画像を取得するユーザーのユーザー名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getPublicUserIcon(username, options) {
        return PublicApiFp(this.configuration).getPublicUserIcon(username, options)(this.axios, this.basePath);
    }
}
/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(referenceID, options = {}) {
            // verify required parameter 'referenceID' is not null or undefined
            if (referenceID === null || referenceID === undefined) {
                throw new RequiredError('referenceID', 'Required parameter referenceID was null or undefined when calling deleteSession.');
            }
            const localVarPath = `/users/me/sessions/{referenceID}`
                .replace(`{${"referenceID"}}`, encodeURIComponent(String(referenceID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessions(options = {}) {
            const localVarPath = `/users/me/sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options = {}) {
            const localVarPath = `/users/me/sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function (configuration) {
    return {
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(referenceID, options) {
            const localVarAxiosArgs = SessionsApiAxiosParamCreator(configuration).deleteSession(referenceID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessions(options) {
            const localVarAxiosArgs = SessionsApiAxiosParamCreator(configuration).deleteSessions(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options) {
            const localVarAxiosArgs = SessionsApiAxiosParamCreator(configuration).getSessions(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 対象のセッションをログアウトします。
         * @param {string} referenceID 操作の対象となるセッションの参照ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(referenceID, options) {
            return SessionsApiFp(configuration).deleteSession(referenceID, options)(axios, basePath);
        },
        /**
         * 自分のログインセッションを全てログアウトします。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessions(options) {
            return SessionsApiFp(configuration).deleteSessions(options)(axios, basePath);
        },
        /**
         * 自分のログインセッションリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options) {
            return SessionsApiFp(configuration).getSessions(options)(axios, basePath);
        },
    };
};
/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * 対象のセッションをログアウトします。
     * @param {string} referenceID 操作の対象となるセッションの参照ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    deleteSession(referenceID, options) {
        return SessionsApiFp(this.configuration).deleteSession(referenceID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションを全てログアウトします。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    deleteSessions(options) {
        return SessionsApiFp(this.configuration).deleteSessions(options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    getSessions(options) {
        return SessionsApiFp(this.configuration).getSessions(options)(this.axios, this.basePath);
    }
}
/**
 * StampApi - axios parameter creator
 * @export
 */
export const StampApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling createStamp.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling createStamp.');
            }
            const localVarPath = `/stamps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampID, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling deleteStamp.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStamp(stampID, name, file, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling editStamp.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling getMessageStamps.');
            }
            const localVarPath = `/messages/{messageID}/stamps`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampID, options = {}) {
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling getStamp.');
            }
            const localVarPath = `/stamps/{stampID}`
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampHistory(options = {}) {
            const localVarPath = `/users/me/stamp-history`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(options = {}) {
            const localVarPath = `/stamps`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {MessageStampPost} [messageStampPost]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampMessage(messageID, stampID, messageStampPost, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling stampMessage.');
            }
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling stampMessage.');
            }
            const localVarPath = `/messages/{messageID}/stamps/{stampID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)))
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof messageStampPost !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(messageStampPost !== undefined ? messageStampPost : {}) : (messageStampPost || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstampMessage(messageID, stampID, options = {}) {
            // verify required parameter 'messageID' is not null or undefined
            if (messageID === null || messageID === undefined) {
                throw new RequiredError('messageID', 'Required parameter messageID was null or undefined when calling unstampMessage.');
            }
            // verify required parameter 'stampID' is not null or undefined
            if (stampID === null || stampID === undefined) {
                throw new RequiredError('stampID', 'Required parameter stampID was null or undefined when calling unstampMessage.');
            }
            const localVarPath = `/messages/{messageID}/stamps/{stampID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)))
                .replace(`{${"stampID"}}`, encodeURIComponent(String(stampID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StampApi - functional programming interface
 * @export
 */
export const StampApiFp = function (configuration) {
    return {
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).createStamp(name, file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).deleteStamp(stampID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStamp(stampID, name, file, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).editStamp(stampID, name, file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).getMessageStamps(messageID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).getStamp(stampID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampHistory(options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).getStampHistory(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).getStamps(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {MessageStampPost} [messageStampPost]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampMessage(messageID, stampID, messageStampPost, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).stampMessage(messageID, stampID, messageStampPost, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstampMessage(messageID, stampID, options) {
            const localVarAxiosArgs = StampApiAxiosParamCreator(configuration).unstampMessage(messageID, stampID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StampApi - factory interface
 * @export
 */
export const StampApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * スタンプを新規作成します。
         * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} file 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStamp(name, file, options) {
            return StampApiFp(configuration).createStamp(name, file, options)(axios, basePath);
        },
        /**
         * スタンプを削除します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStamp(stampID, options) {
            return StampApiFp(configuration).deleteStamp(stampID, options)(axios, basePath);
        },
        /**
         * スタンプを修正します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
         * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editStamp(stampID, name, file, options) {
            return StampApiFp(configuration).editStamp(stampID, name, file, options)(axios, basePath);
        },
        /**
         * 指定したメッセージに押されているスタンプを全て取得します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageStamps(messageID, options) {
            return StampApiFp(configuration).getMessageStamps(messageID, options)(axios, basePath);
        },
        /**
         * スタンプの情報を取得します。
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamp(stampID, options) {
            return StampApiFp(configuration).getStamp(stampID, options)(axios, basePath);
        },
        /**
         * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStampHistory(options) {
            return StampApiFp(configuration).getStampHistory(options)(axios, basePath);
        },
        /**
         * 全スタンプのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStamps(options) {
            return StampApiFp(configuration).getStamps(options)(axios, basePath);
        },
        /**
         * 指定したメッセージに指定したスタンプを押します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {MessageStampPost} [messageStampPost]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stampMessage(messageID, stampID, messageStampPost, options) {
            return StampApiFp(configuration).stampMessage(messageID, stampID, messageStampPost, options)(axios, basePath);
        },
        /**
         * 指定したメッセージから指定したスタンプを外します。
         * @param {string} messageID 操作の対象となるメッセージID
         * @param {string} stampID 操作の対象となるスタンプID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstampMessage(messageID, stampID, options) {
            return StampApiFp(configuration).unstampMessage(messageID, stampID, options)(axios, basePath);
        },
    };
};
/**
 * StampApi - object-oriented interface
 * @export
 * @class StampApi
 * @extends {BaseAPI}
 */
export class StampApi extends BaseAPI {
    /**
     * スタンプを新規作成します。
     * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} file 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    createStamp(name, file, options) {
        return StampApiFp(this.configuration).createStamp(name, file, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを削除します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    deleteStamp(stampID, options) {
        return StampApiFp(this.configuration).deleteStamp(stampID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを修正します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    editStamp(stampID, name, file, options) {
        return StampApiFp(this.configuration).editStamp(stampID, name, file, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに押されているスタンプを全て取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getMessageStamps(messageID, options) {
        return StampApiFp(this.configuration).getMessageStamps(messageID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプの情報を取得します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamp(stampID, options) {
        return StampApiFp(this.configuration).getStamp(stampID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStampHistory(options) {
        return StampApiFp(this.configuration).getStampHistory(options)(this.axios, this.basePath);
    }
    /**
     * 全スタンプのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamps(options) {
        return StampApiFp(this.configuration).getStamps(options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {MessageStampPost} [messageStampPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampMessage(messageID, stampID, messageStampPost, options) {
        return StampApiFp(this.configuration).stampMessage(messageID, stampID, messageStampPost, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定したスタンプを外します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    unstampMessage(messageID, stampID, options) {
        return StampApiFp(this.configuration).unstampMessage(messageID, stampID, options)(this.axios, this.basePath);
    }
}
/**
 * StarApi - axios parameter creator
 * @export
 */
export const StarApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaredChannels(options = {}) {
            const localVarPath = `/users/me/stars`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starChannel(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling starChannel.');
            }
            const localVarPath = `/users/me/stars/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarChannel(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling unstarChannel.');
            }
            const localVarPath = `/users/me/stars/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StarApi - functional programming interface
 * @export
 */
export const StarApiFp = function (configuration) {
    return {
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaredChannels(options) {
            const localVarAxiosArgs = StarApiAxiosParamCreator(configuration).getStaredChannels(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starChannel(channelID, options) {
            const localVarAxiosArgs = StarApiAxiosParamCreator(configuration).starChannel(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarChannel(channelID, options) {
            const localVarAxiosArgs = StarApiAxiosParamCreator(configuration).unstarChannel(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * StarApi - factory interface
 * @export
 */
export const StarApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * お気に入りチャンネルリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaredChannels(options) {
            return StarApiFp(configuration).getStaredChannels(options)(axios, basePath);
        },
        /**
         * お気に入りチャンネルリストにチャンネルを追加します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starChannel(channelID, options) {
            return StarApiFp(configuration).starChannel(channelID, options)(axios, basePath);
        },
        /**
         * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarChannel(channelID, options) {
            return StarApiFp(configuration).unstarChannel(channelID, options)(axios, basePath);
        },
    };
};
/**
 * StarApi - object-oriented interface
 * @export
 * @class StarApi
 * @extends {BaseAPI}
 */
export class StarApi extends BaseAPI {
    /**
     * お気に入りチャンネルリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    getStaredChannels(options) {
        return StarApiFp(this.configuration).getStaredChannels(options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストにチャンネルを追加します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    starChannel(channelID, options) {
        return StarApiFp(this.configuration).starChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    unstarChannel(channelID, options) {
        return StarApiFp(this.configuration).unstarChannel(channelID, options)(this.axios, this.basePath);
    }
}
/**
 * UnreadApi - axios parameter creator
 * @export
 */
export const UnreadApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadChannels(options = {}) {
            const localVarPath = `/users/me/unread/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMessages(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling readMessages.');
            }
            const localVarPath = `/users/me/unread/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UnreadApi - functional programming interface
 * @export
 */
export const UnreadApiFp = function (configuration) {
    return {
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadChannels(options) {
            const localVarAxiosArgs = UnreadApiAxiosParamCreator(configuration).getUnreadChannels(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMessages(channelID, options) {
            const localVarAxiosArgs = UnreadApiAxiosParamCreator(configuration).readMessages(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UnreadApi - factory interface
 * @export
 */
export const UnreadApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 未読チャンネル情報のリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadChannels(options) {
            return UnreadApiFp(configuration).getUnreadChannels(options)(axios, basePath);
        },
        /**
         * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMessages(channelID, options) {
            return UnreadApiFp(configuration).readMessages(channelID, options)(axios, basePath);
        },
    };
};
/**
 * UnreadApi - object-oriented interface
 * @export
 * @class UnreadApi
 * @extends {BaseAPI}
 */
export class UnreadApi extends BaseAPI {
    /**
     * 未読チャンネル情報のリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    getUnreadChannels(options) {
        return UnreadApiFp(this.configuration).getUnreadChannels(options)(this.axios, this.basePath);
    }
    /**
     * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    readMessages(channelID, options) {
        return UnreadApiFp(this.configuration).readMessages(channelID, options)(this.axios, this.basePath);
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} userData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMe(userData, options = {}) {
            // verify required parameter 'userData' is not null or undefined
            if (userData === null || userData === undefined) {
                throw new RequiredError('userData', 'Required parameter userData was null or undefined when calling changeMe.');
            }
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof userData !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userData !== undefined ? userData : {}) : (userData || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options = {}) {
            const localVarPath = `/users/me/icon`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} changePassword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePassword, options = {}) {
            // verify required parameter 'changePassword' is not null or undefined
            if (changePassword === null || changePassword === undefined) {
                throw new RequiredError('changePassword', 'Required parameter changePassword was null or undefined when calling changePassword.');
            }
            const localVarPath = `/users/me/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof changePassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(changePassword !== undefined ? changePassword : {}) : (changePassword || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options = {}) {
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options = {}) {
            const localVarPath = `/users/me/icon`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQrCode(options = {}) {
            const localVarPath = `/users/me/qr-code`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling getUserIcon.');
            }
            const localVarPath = `/users/{userID}/icon`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options = {}) {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} userRegister
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userRegister, options = {}) {
            // verify required parameter 'userRegister' is not null or undefined
            if (userRegister === null || userRegister === undefined) {
                throw new RequiredError('userRegister', 'Required parameter userRegister was null or undefined when calling registerUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication cookieAuth required
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof userRegister !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(userRegister !== undefined ? userRegister : {}) : (userRegister || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration) {
    return {
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} userData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMe(userData, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).changeMe(userData, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).changeMyIcon(file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} changePassword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePassword, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).changePassword(changePassword, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getMe(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getMyIcon(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQrCode(options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getQrCode(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userID, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getUser(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userID, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getUserIcon(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getUsers(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} userRegister
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userRegister, options) {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).registerUser(userRegister, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 自分のユーザー情報を変更します。
         * @param {UserData} userData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMe(userData, options) {
            return UserApiFp(configuration).changeMe(userData, options)(axios, basePath);
        },
        /**
         * 自分のアイコンを更新します。
         * @param {any} [file] 1MBまでのpng, jpeg, gif
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyIcon(file, options) {
            return UserApiFp(configuration).changeMyIcon(file, options)(axios, basePath);
        },
        /**
         * 自分のパスワードを変更します。
         * @param {ChangePassword} changePassword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePassword, options) {
            return UserApiFp(configuration).changePassword(changePassword, options)(axios, basePath);
        },
        /**
         * 自分のユーザー情報を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            return UserApiFp(configuration).getMe(options)(axios, basePath);
        },
        /**
         * 自分のアイコン画像を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyIcon(options) {
            return UserApiFp(configuration).getMyIcon(options)(axios, basePath);
        },
        /**
         * 自分のQRコードを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQrCode(options) {
            return UserApiFp(configuration).getQrCode(options)(axios, basePath);
        },
        /**
         * ユーザーの詳細を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userID, options) {
            return UserApiFp(configuration).getUser(userID, options)(axios, basePath);
        },
        /**
         * ユーザーのアイコン画像を取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIcon(userID, options) {
            return UserApiFp(configuration).getUserIcon(userID, options)(axios, basePath);
        },
        /**
         * 全ユーザーのリストを取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options) {
            return UserApiFp(configuration).getUsers(options)(axios, basePath);
        },
        /**
         * ユーザー登録します
         * @param {UserRegister} userRegister
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userRegister, options) {
            return UserApiFp(configuration).registerUser(userRegister, options)(axios, basePath);
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 自分のユーザー情報を変更します。
     * @param {UserData} userData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeMe(userData, options) {
        return UserApiFp(this.configuration).changeMe(userData, options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコンを更新します。
     * @param {any} [file] 1MBまでのpng, jpeg, gif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeMyIcon(file, options) {
        return UserApiFp(this.configuration).changeMyIcon(file, options)(this.axios, this.basePath);
    }
    /**
     * 自分のパスワードを変更します。
     * @param {ChangePassword} changePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changePassword(changePassword, options) {
        return UserApiFp(this.configuration).changePassword(changePassword, options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMe(options) {
        return UserApiFp(this.configuration).getMe(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMyIcon(options) {
        return UserApiFp(this.configuration).getMyIcon(options)(this.axios, this.basePath);
    }
    /**
     * 自分のQRコードを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getQrCode(options) {
        return UserApiFp(this.configuration).getQrCode(options)(this.axios, this.basePath);
    }
    /**
     * ユーザーの詳細を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(userID, options) {
        return UserApiFp(this.configuration).getUser(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのアイコン画像を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserIcon(userID, options) {
        return UserApiFp(this.configuration).getUserIcon(userID, options)(this.axios, this.basePath);
    }
    /**
     * 全ユーザーのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsers(options) {
        return UserApiFp(this.configuration).getUsers(options)(this.axios, this.basePath);
    }
    /**
     * ユーザー登録します
     * @param {UserRegister} userRegister
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    registerUser(userRegister, options) {
        return UserApiFp(this.configuration).registerUser(userRegister, options)(this.axios, this.basePath);
    }
}
/**
 * UserGroupApi - axios parameter creator
 * @export
 */
export const UserGroupApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} addUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMember(groupID, addUserGroup, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling addGroupMember.');
            }
            // verify required parameter 'addUserGroup' is not null or undefined
            if (addUserGroup === null || addUserGroup === undefined) {
                throw new RequiredError('addUserGroup', 'Required parameter addUserGroup was null or undefined when calling addGroupMember.');
            }
            const localVarPath = `/groups/{groupID}/members`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof addUserGroup !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(addUserGroup !== undefined ? addUserGroup : {}) : (addUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} postUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(postUserGroup, options = {}) {
            // verify required parameter 'postUserGroup' is not null or undefined
            if (postUserGroup === null || postUserGroup === undefined) {
                throw new RequiredError('postUserGroup', 'Required parameter postUserGroup was null or undefined when calling createGroup.');
            }
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postUserGroup !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postUserGroup !== undefined ? postUserGroup : {}) : (postUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupMember(groupID, userID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling deleteGroupMember.');
            }
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling deleteGroupMember.');
            }
            const localVarPath = `/groups/{groupID}/members/{userID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)))
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} patchUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGroup(groupID, patchUserGroup, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling editGroup.');
            }
            // verify required parameter 'patchUserGroup' is not null or undefined
            if (patchUserGroup === null || patchUserGroup === undefined) {
                throw new RequiredError('patchUserGroup', 'Required parameter patchUserGroup was null or undefined when calling editGroup.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchUserGroup !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchUserGroup !== undefined ? patchUserGroup : {}) : (patchUserGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling getGroup.');
            }
            const localVarPath = `/groups/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers(groupID, options = {}) {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID', 'Required parameter groupID was null or undefined when calling getGroupMembers.');
            }
            const localVarPath = `/groups/{groupID}/members`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options = {}) {
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroups(options = {}) {
            const localVarPath = `/users/me/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling getUserGroups.');
            }
            const localVarPath = `/users/{userID}/groups`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserGroupApi - functional programming interface
 * @export
 */
export const UserGroupApiFp = function (configuration) {
    return {
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} addUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMember(groupID, addUserGroup, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).addGroupMember(groupID, addUserGroup, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} postUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(postUserGroup, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).createGroup(postUserGroup, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).deleteGroup(groupID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupMember(groupID, userID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).deleteGroupMember(groupID, userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} patchUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGroup(groupID, patchUserGroup, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).editGroup(groupID, patchUserGroup, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).getGroup(groupID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers(groupID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).getGroupMembers(groupID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).getGroups(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroups(options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).getMyGroups(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userID, options) {
            const localVarAxiosArgs = UserGroupApiAxiosParamCreator(configuration).getUserGroups(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserGroupApi - factory interface
 * @export
 */
export const UserGroupApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ユーザーグループにメンバーを追加します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {AddUserGroup} addUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMember(groupID, addUserGroup, options) {
            return UserGroupApiFp(configuration).addGroupMember(groupID, addUserGroup, options)(axios, basePath);
        },
        /**
         * ユーザーグループを作成します
         * @param {PostUserGroup} postUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(postUserGroup, options) {
            return UserGroupApiFp(configuration).createGroup(postUserGroup, options)(axios, basePath);
        },
        /**
         * ユーザーグループを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID, options) {
            return UserGroupApiFp(configuration).deleteGroup(groupID, options)(axios, basePath);
        },
        /**
         * ユーザーグループからメンバーを削除します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupMember(groupID, userID, options) {
            return UserGroupApiFp(configuration).deleteGroupMember(groupID, userID, options)(axios, basePath);
        },
        /**
         * ユーザーグループの情報を変更します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {PatchUserGroup} patchUserGroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editGroup(groupID, patchUserGroup, options) {
            return UserGroupApiFp(configuration).editGroup(groupID, patchUserGroup, options)(axios, basePath);
        },
        /**
         * ユーザーグループを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupID, options) {
            return UserGroupApiFp(configuration).getGroup(groupID, options)(axios, basePath);
        },
        /**
         * ユーザーグループのメンバーのIDを取得します
         * @param {string} groupID 操作の対象となるユーザーグループID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers(groupID, options) {
            return UserGroupApiFp(configuration).getGroupMembers(groupID, options)(axios, basePath);
        },
        /**
         * 全てのユーザーグループを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options) {
            return UserGroupApiFp(configuration).getGroups(options)(axios, basePath);
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGroups(options) {
            return UserGroupApiFp(configuration).getMyGroups(options)(axios, basePath);
        },
        /**
         * 所属するユーザーグループのIDを取得します
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(userID, options) {
            return UserGroupApiFp(configuration).getUserGroups(userID, options)(axios, basePath);
        },
    };
};
/**
 * UserGroupApi - object-oriented interface
 * @export
 * @class UserGroupApi
 * @extends {BaseAPI}
 */
export class UserGroupApi extends BaseAPI {
    /**
     * ユーザーグループにメンバーを追加します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {AddUserGroup} addUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    addGroupMember(groupID, addUserGroup, options) {
        return UserGroupApiFp(this.configuration).addGroupMember(groupID, addUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを作成します
     * @param {PostUserGroup} postUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    createGroup(postUserGroup, options) {
        return UserGroupApiFp(this.configuration).createGroup(postUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    deleteGroup(groupID, options) {
        return UserGroupApiFp(this.configuration).deleteGroup(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループからメンバーを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    deleteGroupMember(groupID, userID, options) {
        return UserGroupApiFp(this.configuration).deleteGroupMember(groupID, userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループの情報を変更します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {PatchUserGroup} patchUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    editGroup(groupID, patchUserGroup, options) {
        return UserGroupApiFp(this.configuration).editGroup(groupID, patchUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroup(groupID, options) {
        return UserGroupApiFp(this.configuration).getGroup(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループのメンバーのIDを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroupMembers(groupID, options) {
        return UserGroupApiFp(this.configuration).getGroupMembers(groupID, options)(this.axios, this.basePath);
    }
    /**
     * 全てのユーザーグループを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroups(options) {
        return UserGroupApiFp(this.configuration).getGroups(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getMyGroups(options) {
        return UserGroupApiFp(this.configuration).getMyGroups(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getUserGroups(userID, options) {
        return UserGroupApiFp(this.configuration).getUserGroups(userID, options)(this.axios, this.basePath);
    }
}
/**
 * UserTagApi - axios parameter creator
 * @export
 */
export const UserTagApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} setTag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userID, setTag, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling addUserTag.');
            }
            // verify required parameter 'setTag' is not null or undefined
            if (setTag === null || setTag === undefined) {
                throw new RequiredError('setTag', 'Required parameter setTag was null or undefined when calling addUserTag.');
            }
            const localVarPath = `/users/{userID}/tags`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof setTag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setTag !== undefined ? setTag : {}) : (setTag || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} setTagLock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLockUserTag(userID, tagID, setTagLock, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling changeLockUserTag.');
            }
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new RequiredError('tagID', 'Required parameter tagID was null or undefined when calling changeLockUserTag.');
            }
            // verify required parameter 'setTagLock' is not null or undefined
            if (setTagLock === null || setTagLock === undefined) {
                throw new RequiredError('setTagLock', 'Required parameter setTagLock was null or undefined when calling changeLockUserTag.');
            }
            const localVarPath = `/users/{userID}/tags/{tagID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof setTagLock !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(setTagLock !== undefined ? setTagLock : {}) : (setTagLock || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(userID, tagID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling deleteUserTag.');
            }
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new RequiredError('tagID', 'Required parameter tagID was null or undefined when calling deleteUserTag.');
            }
            const localVarPath = `/users/{userID}/tags/{tagID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagID, options = {}) {
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new RequiredError('tagID', 'Required parameter tagID was null or undefined when calling getTag.');
            }
            const localVarPath = `/tags/{tagID}`
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userID, options = {}) {
            // verify required parameter 'userID' is not null or undefined
            if (userID === null || userID === undefined) {
                throw new RequiredError('userID', 'Required parameter userID was null or undefined when calling getUserTags.');
            }
            const localVarPath = `/users/{userID}/tags`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserTagApi - functional programming interface
 * @export
 */
export const UserTagApiFp = function (configuration) {
    return {
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} setTag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userID, setTag, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).addUserTag(userID, setTag, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} setTagLock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLockUserTag(userID, tagID, setTagLock, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).changeLockUserTag(userID, tagID, setTagLock, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(userID, tagID, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).deleteUserTag(userID, tagID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagID, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).getTag(tagID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userID, options) {
            const localVarAxiosArgs = UserTagApiAxiosParamCreator(configuration).getUserTags(userID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * UserTagApi - factory interface
 * @export
 */
export const UserTagApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * ユーザーにタグを追加します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {SetTag} setTag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTag(userID, setTag, options) {
            return UserTagApiFp(configuration).addUserTag(userID, setTag, options)(axios, basePath);
        },
        /**
         * タグのロック、アンロックを変更します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {SetTagLock} setTagLock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeLockUserTag(userID, tagID, setTagLock, options) {
            return UserTagApiFp(configuration).changeLockUserTag(userID, tagID, setTagLock, options)(axios, basePath);
        },
        /**
         * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(userID, tagID, options) {
            return UserTagApiFp(configuration).deleteUserTag(userID, tagID, options)(axios, basePath);
        },
        /**
         * 指定されたタグの情報を取得します。
         * @param {string} tagID 操作の対象となるタグID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagID, options) {
            return UserTagApiFp(configuration).getTag(tagID, options)(axios, basePath);
        },
        /**
         * ユーザーのタグのリストを取得します。
         * @param {string} userID 操作の対象となるユーザーID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTags(userID, options) {
            return UserTagApiFp(configuration).getUserTags(userID, options)(axios, basePath);
        },
    };
};
/**
 * UserTagApi - object-oriented interface
 * @export
 * @class UserTagApi
 * @extends {BaseAPI}
 */
export class UserTagApi extends BaseAPI {
    /**
     * ユーザーにタグを追加します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SetTag} setTag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    addUserTag(userID, setTag, options) {
        return UserTagApiFp(this.configuration).addUserTag(userID, setTag, options)(this.axios, this.basePath);
    }
    /**
     * タグのロック、アンロックを変更します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {SetTagLock} setTagLock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    changeLockUserTag(userID, tagID, setTagLock, options) {
        return UserTagApiFp(this.configuration).changeLockUserTag(userID, tagID, setTagLock, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    deleteUserTag(userID, tagID, options) {
        return UserTagApiFp(this.configuration).deleteUserTag(userID, tagID, options)(this.axios, this.basePath);
    }
    /**
     * 指定されたタグの情報を取得します。
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getTag(tagID, options) {
        return UserTagApiFp(this.configuration).getTag(tagID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのタグのリストを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getUserTags(userID, options) {
        return UserTagApiFp(this.configuration).getUserTags(userID, options)(this.axios, this.basePath);
    }
}
/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookID, file, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling changeWebhookIcon.');
            }
            const localVarPath = `/webhooks/{webhookID}/icon`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} postWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhooks(postWebhook, options = {}) {
            // verify required parameter 'postWebhook' is not null or undefined
            if (postWebhook === null || postWebhook === undefined) {
                throw new RequiredError('postWebhook', 'Required parameter postWebhook was null or undefined when calling createWebhooks.');
            }
            const localVarPath = `/webhooks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof postWebhook !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(postWebhook !== undefined ? postWebhook : {}) : (postWebhook || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} patchWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookID, patchWebhook, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling editWebhook.');
            }
            // verify required parameter 'patchWebhook' is not null or undefined
            if (patchWebhook === null || patchWebhook === undefined) {
                throw new RequiredError('patchWebhook', 'Required parameter patchWebhook was null or undefined when calling editWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof patchWebhook !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(patchWebhook !== undefined ? patchWebhook : {}) : (patchWebhook || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling getWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling getWebhookIcon.');
            }
            const localVarPath = `/webhooks/{webhookID}/icon`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options = {}) {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read", "manage_bot"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGitHubWebhook(webhookID, body, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling postGitHubWebhook.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postGitHubWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}/github`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} body
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling postWebhook.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postWebhook.');
            }
            const localVarPath = `/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }
            if (xTRAQChannelId !== undefined && xTRAQChannelId !== null) {
                localVarHeaderParameter['X-TRAQ-Channel-Id'] = String(JSON.stringify(xTRAQChannelId));
            }
            if (xTRAQSignature !== undefined && xTRAQSignature !== null) {
                localVarHeaderParameter['X-TRAQ-Signature'] = String(xTRAQSignature);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function (configuration) {
    return {
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookID, file, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).changeWebhookIcon(webhookID, file, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} postWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhooks(postWebhook, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).createWebhooks(postWebhook, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookID, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).deleteWebhook(webhookID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} patchWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookID, patchWebhook, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).editWebhook(webhookID, patchWebhook, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookID, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).getWebhook(webhookID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookID, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).getWebhookIcon(webhookID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).getWebhooks(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGitHubWebhook(webhookID, body, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).postGitHubWebhook(webhookID, body, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} body
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options) {
            const localVarAxiosArgs = WebhookApiAxiosParamCreator(configuration).postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * 指定したwebhookのアイコンを変更します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeWebhookIcon(webhookID, file, options) {
            return WebhookApiFp(configuration).changeWebhookIcon(webhookID, file, options)(axios, basePath);
        },
        /**
         * webhookを作成します。
         * @param {PostWebhook} postWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhooks(postWebhook, options) {
            return WebhookApiFp(configuration).createWebhooks(postWebhook, options)(axios, basePath);
        },
        /**
         * webhookを削除します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookID, options) {
            return WebhookApiFp(configuration).deleteWebhook(webhookID, options)(axios, basePath);
        },
        /**
         * webhookを修正します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {PatchWebhook} patchWebhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editWebhook(webhookID, patchWebhook, options) {
            return WebhookApiFp(configuration).editWebhook(webhookID, patchWebhook, options)(axios, basePath);
        },
        /**
         * webhookの詳細を取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookID, options) {
            return WebhookApiFp(configuration).getWebhook(webhookID, options)(axios, basePath);
        },
        /**
         * 指定したWebhookのアイコンを取得します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookIcon(webhookID, options) {
            return WebhookApiFp(configuration).getWebhookIcon(webhookID, options)(axios, basePath);
        },
        /**
         * 自分が作成したwebhookの一覧を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options) {
            return WebhookApiFp(configuration).getWebhooks(options)(axios, basePath);
        },
        /**
         * Github-Compatibleなwebhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGitHubWebhook(webhookID, body, options) {
            return WebhookApiFp(configuration).postGitHubWebhook(webhookID, body, options)(axios, basePath);
        },
        /**
         * webhookを送信します。
         * @param {string} webhookID 操作の対象となるWebhookのID
         * @param {string} body
         * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
         * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
         * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options) {
            return WebhookApiFp(configuration).postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options)(axios, basePath);
        },
    };
};
/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 指定したwebhookのアイコンを変更します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    changeWebhookIcon(webhookID, file, options) {
        return WebhookApiFp(this.configuration).changeWebhookIcon(webhookID, file, options)(this.axios, this.basePath);
    }
    /**
     * webhookを作成します。
     * @param {PostWebhook} postWebhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    createWebhooks(postWebhook, options) {
        return WebhookApiFp(this.configuration).createWebhooks(postWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookを削除します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    deleteWebhook(webhookID, options) {
        return WebhookApiFp(this.configuration).deleteWebhook(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * webhookを修正します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {PatchWebhook} patchWebhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    editWebhook(webhookID, patchWebhook, options) {
        return WebhookApiFp(this.configuration).editWebhook(webhookID, patchWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookの詳細を取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhook(webhookID, options) {
        return WebhookApiFp(this.configuration).getWebhook(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したWebhookのアイコンを取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhookIcon(webhookID, options) {
        return WebhookApiFp(this.configuration).getWebhookIcon(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したwebhookの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhooks(options) {
        return WebhookApiFp(this.configuration).getWebhooks(options)(this.axios, this.basePath);
    }
    /**
     * Github-Compatibleなwebhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postGitHubWebhook(webhookID, body, options) {
        return WebhookApiFp(this.configuration).postGitHubWebhook(webhookID, body, options)(this.axios, this.basePath);
    }
    /**
     * webhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {string} body
     * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
     * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options) {
        return WebhookApiFp(this.configuration).postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options)(this.axios, this.basePath);
    }
}
/**
 * WebrtcApi - axios parameter creator
 * @export
 */
export const WebrtcApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * チャンネルのWebRTC状態を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelWebRTCState(channelID, options = {}) {
            // verify required parameter 'channelID' is not null or undefined
            if (channelID === null || channelID === undefined) {
                throw new RequiredError('channelID', 'Required parameter channelID was null or undefined when calling getChannelWebRTCState.');
            }
            const localVarPath = `/channels/{channelID}/webrtc/state`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のWebRTCの状態を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options = {}) {
            const localVarPath = `/webrtc/state`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 自身のWebRTCの状態を変更します。
         * @param {PutWebRTCState} putWebRTCState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebRTCState(putWebRTCState, options = {}) {
            // verify required parameter 'putWebRTCState' is not null or undefined
            if (putWebRTCState === null || putWebRTCState === undefined) {
                throw new RequiredError('putWebRTCState', 'Required parameter putWebRTCState was null or undefined when calling putWebRTCState.');
            }
            const localVarPath = `/webrtc/state`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication traqOAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("traqOAuth2", ["write"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization = (typeof putWebRTCState !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(putWebRTCState !== undefined ? putWebRTCState : {}) : (putWebRTCState || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WebrtcApi - functional programming interface
 * @export
 */
export const WebrtcApiFp = function (configuration) {
    return {
        /**
         * チャンネルのWebRTC状態を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelWebRTCState(channelID, options) {
            const localVarAxiosArgs = WebrtcApiAxiosParamCreator(configuration).getChannelWebRTCState(channelID, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のWebRTCの状態を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options) {
            const localVarAxiosArgs = WebrtcApiAxiosParamCreator(configuration).getWebRTCState(options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 自身のWebRTCの状態を変更します。
         * @param {PutWebRTCState} putWebRTCState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebRTCState(putWebRTCState, options) {
            const localVarAxiosArgs = WebrtcApiAxiosParamCreator(configuration).putWebRTCState(putWebRTCState, options);
            return (axios = globalAxios, basePath = BASE_PATH) => {
                const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * WebrtcApi - factory interface
 * @export
 */
export const WebrtcApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * チャンネルのWebRTC状態を取得します。
         * @param {string} channelID 操作の対象となるチャンネルのID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelWebRTCState(channelID, options) {
            return WebrtcApiFp(configuration).getChannelWebRTCState(channelID, options)(axios, basePath);
        },
        /**
         * 自身のWebRTCの状態を取得します。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebRTCState(options) {
            return WebrtcApiFp(configuration).getWebRTCState(options)(axios, basePath);
        },
        /**
         * 自身のWebRTCの状態を変更します。
         * @param {PutWebRTCState} putWebRTCState
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebRTCState(putWebRTCState, options) {
            return WebrtcApiFp(configuration).putWebRTCState(putWebRTCState, options)(axios, basePath);
        },
    };
};
/**
 * WebrtcApi - object-oriented interface
 * @export
 * @class WebrtcApi
 * @extends {BaseAPI}
 */
export class WebrtcApi extends BaseAPI {
    /**
     * チャンネルのWebRTC状態を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getChannelWebRTCState(channelID, options) {
        return WebrtcApiFp(this.configuration).getChannelWebRTCState(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 自身のWebRTCの状態を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getWebRTCState(options) {
        return WebrtcApiFp(this.configuration).getWebRTCState(options)(this.axios, this.basePath);
    }
    /**
     * 自身のWebRTCの状態を変更します。
     * @param {PutWebRTCState} putWebRTCState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    putWebRTCState(putWebRTCState, options) {
        return WebrtcApiFp(this.configuration).putWebRTCState(putWebRTCState, options)(this.axios, this.basePath);
    }
}
export class Apis extends BaseAPI {
    /**
     * 各チャンネルの最新のメッセージ１件をメッセージ作成日時の降順で取得します。
     * @param {number} [limit] 取得する件数 1-50
     * @param {boolean} [subscribe] 購読チャンネルのみを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    getActivities(limit, subscribe, options) {
        return ActivityApiFp(this.configuration).getActivities(limit, subscribe, options)(this.axios, this.basePath);
    }
    /**
     * ログインを行います。リダイレクトパラメーターが存在する場合はログイン後にリダイレクトします
     * @param {UserLogin} userLogin
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    login(userLogin, redirect, options) {
        return AuthenticationApiFp(this.configuration).login(userLogin, redirect, options)(this.axios, this.basePath);
    }
    /**
     * ログアウトを行います。リダイレクトパラメーターが存在する場合はログアウト後にリダイレクトします
     * @param {string} [redirect] リダイレクト先
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logout(redirect, options) {
        return AuthenticationApiFp(this.configuration).logout(redirect, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {string} clientId
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return AuthorizationApiFp(this.configuration).getOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可エンドポイント
     * @param {string} clientId
     * @param {OAuth2ResponseType} [responseType]
     * @param {string} [redirectUri]
     * @param {string} [scope]
     * @param {string} [state]
     * @param {string} [codeChallenge]
     * @param {string} [codeChallengeMethod]
     * @param {string} [nonce]
     * @param {OAuth2Prompt} [prompt]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options) {
        return AuthorizationApiFp(this.configuration).postOauth2Authorize(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 認可承諾
     * @param {string} submit 承諾する場合は\\\&quot;approve\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2AuthorizeDecide(submit, options) {
        return AuthorizationApiFp(this.configuration).postOauth2AuthorizeDecide(submit, options)(this.axios, this.basePath);
    }
    /**
     * OAuth2 トークンエンドポイント
     * @param {string} grantType
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [clientId]
     * @param {string} [codeVerifier]
     * @param {string} [username]
     * @param {string} [password]
     * @param {string} [scope]
     * @param {string} [refreshToken]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options) {
        return AuthorizationApiFp(this.configuration).postOauth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにBotを参加させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PostBotChannel} postBotChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    addChannelBot(channelID, postBotChannel, options) {
        return BotApiFp(this.configuration).addChannelBot(channelID, postBotChannel, options)(this.axios, this.basePath);
    }
    /**
     * Botの購読イベントを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotEvents} putBotEvents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotEvents(botID, putBotEvents, options) {
        return BotApiFp(this.configuration).changeBotEvents(botID, putBotEvents, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {any} [file] Botユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotIcon(botID, file, options) {
        return BotApiFp(this.configuration).changeBotIcon(botID, file, options)(this.axios, this.basePath);
    }
    /**
     * Botの状態を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PutBotState} putBotState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    changeBotState(botID, putBotState, options) {
        return BotApiFp(this.configuration).changeBotState(botID, putBotState, options)(this.axios, this.basePath);
    }
    /**
     * Botを作成します。
     * @param {PostBot} postBot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    createBots(postBot, options) {
        return BotApiFp(this.configuration).createBots(postBot, options)(this.axios, this.basePath);
    }
    /**
     * Botを削除します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    deleteBot(botID, options) {
        return BotApiFp(this.configuration).deleteBot(botID, options)(this.axios, this.basePath);
    }
    /**
     * Bot情報を変更します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {PatchBot} patchBot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    editBot(botID, patchBot, options) {
        return BotApiFp(this.configuration).editBot(botID, patchBot, options)(this.axios, this.basePath);
    }
    /**
     * Botを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBot(botID, options) {
        return BotApiFp(this.configuration).getBot(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botが参加しているチャンネルのUUIDの配列を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotChannels(botID, options) {
        return BotApiFp(this.configuration).getBotChannels(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botの詳細を取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotDetail(botID, options) {
        return BotApiFp(this.configuration).getBotDetail(botID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したBotのアイコンを取得します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBotIcon(botID, options) {
        return BotApiFp(this.configuration).getBotIcon(botID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したBotの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getBots(options) {
        return BotApiFp(this.configuration).getBots(options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに参加しているBot一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    getChannelBots(channelID, options) {
        return BotApiFp(this.configuration).getChannelBots(channelID, options)(this.axios, this.basePath);
    }
    /**
     * Botの各種トークンを再発行します。
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    reissueBotTokens(botID, options) {
        return BotApiFp(this.configuration).reissueBotTokens(botID, options)(this.axios, this.basePath);
    }
    /**
     * Botをチャンネルから退出させます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {string} botID 操作の対象となるBotのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    removeChannelBot(channelID, botID, options) {
        return BotApiFp(this.configuration).removeChannelBot(channelID, botID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの親チャンネルを変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PutParentChannel} putParentChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    changeChannelParent(channelID, putParentChannel, options) {
        return ChannelApiFp(this.configuration).changeChannelParent(channelID, putParentChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SetChannelTopic} setChannelTopic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    changeChannelTopic(channelID, setChannelTopic, options) {
        return ChannelApiFp(this.configuration).changeChannelTopic(channelID, setChannelTopic, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを作成します。
     * @param {CreateChannel} createChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannel(createChannel, options) {
        return ChannelApiFp(this.configuration).createChannel(createChannel, options)(this.axios, this.basePath);
    }
    /**
     * 子チャンネルを作成します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {CreateChannelChild} createChannelChild
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    createChannelChild(channelID, createChannelChild, options) {
        return ChannelApiFp(this.configuration).createChannelChild(channelID, createChannelChild, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを削除します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    deleteChannel(channelID, options) {
        return ChannelApiFp(this.configuration).deleteChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を変更します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {PatchChannel} patchChannel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    editChannel(channelID, patchChannel, options) {
        return ChannelApiFp(this.configuration).editChannel(channelID, patchChannel, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの情報を返します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannel(channelID, options) {
        return ChannelApiFp(this.configuration).getChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルイベントのリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options) {
        return ChannelApiFp(this.configuration).getChannelEvents(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの統計情報を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelStats(channelID, options) {
        return ChannelApiFp(this.configuration).getChannelStats(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの説明を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelTopic(channelID, options) {
        return ChannelApiFp(this.configuration).getChannelTopic(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 現在のチャンネル閲覧者のリストを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannelViewers(channelID, options) {
        return ChannelApiFp(this.configuration).getChannelViewers(channelID, options)(this.axios, this.basePath);
    }
    /**
     * (すべての)チャンネルのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    getChannels(options) {
        return ChannelApiFp(this.configuration).getChannels(options)(this.axios, this.basePath);
    }
    /**
     * クライアントを登録します。
     * @param {PostClient} postClient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    createClient(postClient, options) {
        return ClientApiFp(this.configuration).createClient(postClient, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントを削除します。 正常に削除された場合、このクライアントを通じての認可は全て取り消されます。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    deleteClient(clientID, options) {
        return ClientApiFp(this.configuration).deleteClient(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したトークンの認可を取り消します。
     * @param {string} oauth2TokenID 操作の対象となるTokenのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    deleteToken(oauth2TokenID, options) {
        return ClientApiFp(this.configuration).deleteToken(oauth2TokenID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClient(clientID, options) {
        return ClientApiFp(this.configuration).getClient(clientID, options)(this.axios, this.basePath);
    }
    /**
     * クライアントの詳細を取得します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClientDetail(clientID, options) {
        return ClientApiFp(this.configuration).getClientDetail(clientID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が登録しているクライアントの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getClients(options) {
        return ClientApiFp(this.configuration).getClients(options)(this.axios, this.basePath);
    }
    /**
     * 自分が許可しているクライアントの一覧とトークン情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    getTokens(options) {
        return ClientApiFp(this.configuration).getTokens(options)(this.axios, this.basePath);
    }
    /**
     * 指定したクライアントIDのクライアントの情報を変更します。
     * @param {string} clientID 操作の対象となるclientのID
     * @param {PatchClient} patchClient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    patchClient(clientID, patchClient, options) {
        return ClientApiFp(this.configuration).patchClient(clientID, patchClient, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルを削除します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    deleteFile(fileID, options) {
        return FileApiFp(this.configuration).deleteFile(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルの中身を取得します。
     * @param {string} fileID 操作の対象となるファイルID
     * @param {number} [dl] ファイルをダウンロードする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFile(fileID, dl, options) {
        return FileApiFp(this.configuration).getFile(fileID, dl, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのメタデータを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileMeta(fileID, options) {
        return FileApiFp(this.configuration).getFileMeta(fileID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したファイルのサムネイルを取得します
     * @param {string} fileID 操作の対象となるファイルID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getFileThumbnail(fileID, options) {
        return FileApiFp(this.configuration).getFileThumbnail(fileID, options)(this.axios, this.basePath);
    }
    /**
     * ファイルをアップロードします
     * @param {any} file ファイル本体
     * @param {string} [aclReadable] ファイルにアクセスすることが可能なユーザーのUUIDの文字列表現をカンマ区切りで連結した文字列、または\\\&#39;all\\\&#39;(デフォルト)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    uploadFile(file, aclReadable, options) {
        return FileApiFp(this.configuration).uploadFile(file, aclReadable, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルを現在見ている人・編集している人を取得します。
     * @param {string} channelId 現在いるチャンネルId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    getHeartbeat(channelId, options) {
        return HeartbeatApiFp(this.configuration).getHeartbeat(channelId, options)(this.axios, this.basePath);
    }
    /**
     * どのチャンネルを見ているか・編集しているかを送信します。
     * @param {Heartbeat} heartbeat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    postHeartbeat(heartbeat, options) {
        return HeartbeatApiFp(this.configuration).postHeartbeat(heartbeat, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを削除します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    deleteMessage(messageID, options) {
        return MessageApiFp(this.configuration).deleteMessage(messageID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを編集します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {SendMessage} sendMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    editMessage(messageID, sendMessage, options) {
        return MessageApiFp(this.configuration).editMessage(messageID, sendMessage, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルに存在するメッセージを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getDirectMessages(userID, limit, offset, since, until, inclusive, order, options) {
        return MessageApiFp(this.configuration).getDirectMessages(userID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessage(messageID, options) {
        return MessageApiFp(this.configuration).getMessage(messageID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルに存在するメッセージを取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {number} [limit] 取得する件数 1-200
     * @param {number} [offset] 取得するオフセット
     * @param {Date} [since] 取得する時間範囲の開始日時
     * @param {Date} [until] 取得する時間範囲の終了日時
     * @param {boolean} [inclusive] 範囲の端を含めるかどうか
     * @param {'asc' | 'desc'} [order] 昇順か降順か
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getMessages(channelID, limit, offset, since, until, inclusive, order, options) {
        return MessageApiFp(this.configuration).getMessages(channelID, limit, offset, since, until, inclusive, order, options)(this.axios, this.basePath);
    }
    /**
     * メッセージ通報を最大50件取得します。
     * @param {number} [p] ページ番号(ゼロオリジン)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    getReports(p, options) {
        return MessageApiFp(this.configuration).getReports(p, options)(this.axios, this.basePath);
    }
    /**
     * DMチャンネルにメッセージを投稿します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SendMessage} sendMessage
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postDirectMessage(userID, sendMessage, embed, options) {
        return MessageApiFp(this.configuration).postDirectMessage(userID, sendMessage, embed, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージを投稿します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {SendMessage} sendMessage
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    postMessage(channelID, sendMessage, embed, options) {
        return MessageApiFp(this.configuration).postMessage(channelID, sendMessage, embed, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージを通報します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {ReportMessage} reportMessage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    reportMessage(messageID, reportMessage, options) {
        return MessageApiFp(this.configuration).reportMessage(messageID, reportMessage, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルの通知状況を変更します。 リクエストに含めなかったユーザーIDのユーザーの通知状況は変更しません。 また、存在しないユーザーのIDを指定した場合は無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {NotificationUsers} notificationUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    changeSubscribers(channelID, notificationUsers, options) {
        return NotificationApiFp(this.configuration).changeSubscribers(channelID, notificationUsers, options)(this.axios, this.basePath);
    }
    /**
     * 通知ストリーム(Server Sent Events)に接続します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    connectNotification(options) {
        return NotificationApiFp(this.configuration).connectNotification(options)(this.axios, this.basePath);
    }
    /**
     * 自分が通知を入れているチャンネルのリストを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getMySubscribeChannels(options) {
        return NotificationApiFp(this.configuration).getMySubscribeChannels(options)(this.axios, this.basePath);
    }
    /**
     * 通知を点けているユーザーのIDの配列を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getSubscribers(channelID, options) {
        return NotificationApiFp(this.configuration).getSubscribers(channelID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーが通知を入れているチャンネルのリストを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getUserSubscribeChannels(userID, options) {
        return NotificationApiFp(this.configuration).getUserSubscribeChannels(userID, options)(this.axios, this.basePath);
    }
    /**
     * FCMデバイスを登録します。
     * @param {FCMToken} fCMToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    registerNotificationDevice(fCMToken, options) {
        return NotificationApiFp(this.configuration).registerNotificationDevice(fCMToken, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを取得します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPinnedMessage(pinID, options) {
        return PinApiFp(this.configuration).getPinnedMessage(pinID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのピン留め一覧を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    getPinnedMessages(channelID, options) {
        return PinApiFp(this.configuration).getPinnedMessages(channelID, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルにメッセージをピン留めします。
     * @param {MessageIDObject} messageIDObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    pinMessage(messageIDObject, options) {
        return PinApiFp(this.configuration).pinMessage(messageIDObject, options)(this.axios, this.basePath);
    }
    /**
     * ピン留めを外します。
     * @param {string} pinID 操作の対象となるピン留めID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinApi
     */
    unpinMessage(pinID, options) {
        return PinApiFp(this.configuration).unpinMessage(pinID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したユーザーのアイコン画像を取得します。
     * @param {string} username 画像を取得するユーザーのユーザー名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    getPublicUserIcon(username, options) {
        return PublicApiFp(this.configuration).getPublicUserIcon(username, options)(this.axios, this.basePath);
    }
    /**
     * 対象のセッションをログアウトします。
     * @param {string} referenceID 操作の対象となるセッションの参照ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    deleteSession(referenceID, options) {
        return SessionsApiFp(this.configuration).deleteSession(referenceID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションを全てログアウトします。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    deleteSessions(options) {
        return SessionsApiFp(this.configuration).deleteSessions(options)(this.axios, this.basePath);
    }
    /**
     * 自分のログインセッションリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    getSessions(options) {
        return SessionsApiFp(this.configuration).getSessions(options)(this.axios, this.basePath);
    }
    /**
     * スタンプを新規作成します。
     * @param {string} name スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} file 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    createStamp(name, file, options) {
        return StampApiFp(this.configuration).createStamp(name, file, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを削除します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    deleteStamp(stampID, options) {
        return StampApiFp(this.configuration).deleteStamp(stampID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプを修正します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {string} [name] スタンプ名(半角英数字と-+_のみを含む32文字以内の文字列)
     * @param {any} [file] 1MBまでのpng, jpeg, gif, svg
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    editStamp(stampID, name, file, options) {
        return StampApiFp(this.configuration).editStamp(stampID, name, file, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに押されているスタンプを全て取得します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getMessageStamps(messageID, options) {
        return StampApiFp(this.configuration).getMessageStamps(messageID, options)(this.axios, this.basePath);
    }
    /**
     * スタンプの情報を取得します。
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamp(stampID, options) {
        return StampApiFp(this.configuration).getStamp(stampID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のスタンプ履歴を最大50件取得します。結果は降順で返されます。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStampHistory(options) {
        return StampApiFp(this.configuration).getStampHistory(options)(this.axios, this.basePath);
    }
    /**
     * 全スタンプのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    getStamps(options) {
        return StampApiFp(this.configuration).getStamps(options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージに指定したスタンプを押します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {MessageStampPost} [messageStampPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    stampMessage(messageID, stampID, messageStampPost, options) {
        return StampApiFp(this.configuration).stampMessage(messageID, stampID, messageStampPost, options)(this.axios, this.basePath);
    }
    /**
     * 指定したメッセージから指定したスタンプを外します。
     * @param {string} messageID 操作の対象となるメッセージID
     * @param {string} stampID 操作の対象となるスタンプID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StampApi
     */
    unstampMessage(messageID, stampID, options) {
        return StampApiFp(this.configuration).unstampMessage(messageID, stampID, options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    getStaredChannels(options) {
        return StarApiFp(this.configuration).getStaredChannels(options)(this.axios, this.basePath);
    }
    /**
     * お気に入りチャンネルリストにチャンネルを追加します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    starChannel(channelID, options) {
        return StarApiFp(this.configuration).starChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * +| お気に入りチャンネルリストから削除します。 既にお気に入りチャンネルリストに無いチャンネルを指定した場合は無視されます(204)。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarApi
     */
    unstarChannel(channelID, options) {
        return StarApiFp(this.configuration).unstarChannel(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 未読チャンネル情報のリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    getUnreadChannels(options) {
        return UnreadApiFp(this.configuration).getUnreadChannels(options)(this.axios, this.basePath);
    }
    /**
     * 指定されたチャンネルの未読メッセージを既読にします。存在しないチャンネルIDを指定した場合は、無視されます。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnreadApi
     */
    readMessages(channelID, options) {
        return UnreadApiFp(this.configuration).readMessages(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を変更します。
     * @param {UserData} userData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeMe(userData, options) {
        return UserApiFp(this.configuration).changeMe(userData, options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコンを更新します。
     * @param {any} [file] 1MBまでのpng, jpeg, gif
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeMyIcon(file, options) {
        return UserApiFp(this.configuration).changeMyIcon(file, options)(this.axios, this.basePath);
    }
    /**
     * 自分のパスワードを変更します。
     * @param {ChangePassword} changePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changePassword(changePassword, options) {
        return UserApiFp(this.configuration).changePassword(changePassword, options)(this.axios, this.basePath);
    }
    /**
     * 自分のユーザー情報を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMe(options) {
        return UserApiFp(this.configuration).getMe(options)(this.axios, this.basePath);
    }
    /**
     * 自分のアイコン画像を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMyIcon(options) {
        return UserApiFp(this.configuration).getMyIcon(options)(this.axios, this.basePath);
    }
    /**
     * 自分のQRコードを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getQrCode(options) {
        return UserApiFp(this.configuration).getQrCode(options)(this.axios, this.basePath);
    }
    /**
     * ユーザーの詳細を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(userID, options) {
        return UserApiFp(this.configuration).getUser(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのアイコン画像を取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserIcon(userID, options) {
        return UserApiFp(this.configuration).getUserIcon(userID, options)(this.axios, this.basePath);
    }
    /**
     * 全ユーザーのリストを取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsers(options) {
        return UserApiFp(this.configuration).getUsers(options)(this.axios, this.basePath);
    }
    /**
     * ユーザー登録します
     * @param {UserRegister} userRegister
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    registerUser(userRegister, options) {
        return UserApiFp(this.configuration).registerUser(userRegister, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループにメンバーを追加します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {AddUserGroup} addUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    addGroupMember(groupID, addUserGroup, options) {
        return UserGroupApiFp(this.configuration).addGroupMember(groupID, addUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを作成します
     * @param {PostUserGroup} postUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    createGroup(postUserGroup, options) {
        return UserGroupApiFp(this.configuration).createGroup(postUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    deleteGroup(groupID, options) {
        return UserGroupApiFp(this.configuration).deleteGroup(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループからメンバーを削除します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    deleteGroupMember(groupID, userID, options) {
        return UserGroupApiFp(this.configuration).deleteGroupMember(groupID, userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループの情報を変更します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {PatchUserGroup} patchUserGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    editGroup(groupID, patchUserGroup, options) {
        return UserGroupApiFp(this.configuration).editGroup(groupID, patchUserGroup, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroup(groupID, options) {
        return UserGroupApiFp(this.configuration).getGroup(groupID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーグループのメンバーのIDを取得します
     * @param {string} groupID 操作の対象となるユーザーグループID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroupMembers(groupID, options) {
        return UserGroupApiFp(this.configuration).getGroupMembers(groupID, options)(this.axios, this.basePath);
    }
    /**
     * 全てのユーザーグループを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getGroups(options) {
        return UserGroupApiFp(this.configuration).getGroups(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getMyGroups(options) {
        return UserGroupApiFp(this.configuration).getMyGroups(options)(this.axios, this.basePath);
    }
    /**
     * 所属するユーザーグループのIDを取得します
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupApi
     */
    getUserGroups(userID, options) {
        return UserGroupApiFp(this.configuration).getUserGroups(userID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーにタグを追加します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {SetTag} setTag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    addUserTag(userID, setTag, options) {
        return UserTagApiFp(this.configuration).addUserTag(userID, setTag, options)(this.axios, this.basePath);
    }
    /**
     * タグのロック、アンロックを変更します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {SetTagLock} setTagLock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    changeLockUserTag(userID, tagID, setTagLock, options) {
        return UserTagApiFp(this.configuration).changeLockUserTag(userID, tagID, setTagLock, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーから指定したタグを削除します。既に存在しないタグを削除しようとした場合は無視されます(204)。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    deleteUserTag(userID, tagID, options) {
        return UserTagApiFp(this.configuration).deleteUserTag(userID, tagID, options)(this.axios, this.basePath);
    }
    /**
     * 指定されたタグの情報を取得します。
     * @param {string} tagID 操作の対象となるタグID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getTag(tagID, options) {
        return UserTagApiFp(this.configuration).getTag(tagID, options)(this.axios, this.basePath);
    }
    /**
     * ユーザーのタグのリストを取得します。
     * @param {string} userID 操作の対象となるユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTagApi
     */
    getUserTags(userID, options) {
        return UserTagApiFp(this.configuration).getUserTags(userID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したwebhookのアイコンを変更します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {any} [file] webhookユーザーのアイコン(1MBまでのpng, jpeg, gif)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    changeWebhookIcon(webhookID, file, options) {
        return WebhookApiFp(this.configuration).changeWebhookIcon(webhookID, file, options)(this.axios, this.basePath);
    }
    /**
     * webhookを作成します。
     * @param {PostWebhook} postWebhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    createWebhooks(postWebhook, options) {
        return WebhookApiFp(this.configuration).createWebhooks(postWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookを削除します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    deleteWebhook(webhookID, options) {
        return WebhookApiFp(this.configuration).deleteWebhook(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * webhookを修正します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {PatchWebhook} patchWebhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    editWebhook(webhookID, patchWebhook, options) {
        return WebhookApiFp(this.configuration).editWebhook(webhookID, patchWebhook, options)(this.axios, this.basePath);
    }
    /**
     * webhookの詳細を取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhook(webhookID, options) {
        return WebhookApiFp(this.configuration).getWebhook(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 指定したWebhookのアイコンを取得します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhookIcon(webhookID, options) {
        return WebhookApiFp(this.configuration).getWebhookIcon(webhookID, options)(this.axios, this.basePath);
    }
    /**
     * 自分が作成したwebhookの一覧を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    getWebhooks(options) {
        return WebhookApiFp(this.configuration).getWebhooks(options)(this.axios, this.basePath);
    }
    /**
     * Github-Compatibleなwebhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postGitHubWebhook(webhookID, body, options) {
        return WebhookApiFp(this.configuration).postGitHubWebhook(webhookID, body, options)(this.axios, this.basePath);
    }
    /**
     * webhookを送信します。
     * @param {string} webhookID 操作の対象となるWebhookのID
     * @param {string} body
     * @param {string} [xTRAQChannelId] 投稿先のチャンネルID(変更する場合)
     * @param {string} [xTRAQSignature] リクエストボディシグネチャ。Secretが設定されている場合は必須
     * @param {number} [embed] メンション・チャンネルリンクを自動埋め込みする場合に1を指定する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options) {
        return WebhookApiFp(this.configuration).postWebhook(webhookID, body, xTRAQChannelId, xTRAQSignature, embed, options)(this.axios, this.basePath);
    }
    /**
     * チャンネルのWebRTC状態を取得します。
     * @param {string} channelID 操作の対象となるチャンネルのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getChannelWebRTCState(channelID, options) {
        return WebrtcApiFp(this.configuration).getChannelWebRTCState(channelID, options)(this.axios, this.basePath);
    }
    /**
     * 自身のWebRTCの状態を取得します。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    getWebRTCState(options) {
        return WebrtcApiFp(this.configuration).getWebRTCState(options)(this.axios, this.basePath);
    }
    /**
     * 自身のWebRTCの状態を変更します。
     * @param {PutWebRTCState} putWebRTCState
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcApi
     */
    putWebRTCState(putWebRTCState, options) {
        return WebrtcApiFp(this.configuration).putWebRTCState(putWebRTCState, options)(this.axios, this.basePath);
    }
}
